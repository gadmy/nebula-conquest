<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nebula Conquest</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
<style>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NEBULA CONQUEST â€” CSS
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Exo 2', sans-serif;
    color: #ccc;
    user-select: none;
}

canvas#gameCanvas {
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: grab;
}

canvas#gameCanvas.grabbing {
    cursor: grabbing;
}

/* â”€â”€ HUD overlay (prÃ©parÃ© pour Ã©tape 4) â”€â”€ */
#hud {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
}

/* â”€â”€ FPS counter (debug) â”€â”€ */
#fps {
    position: fixed;
    top: 8px;
    right: 12px;
    font-family: 'Orbitron', monospace;
    font-size: 12px;
    color: rgba(0, 255, 180, 0.6);
    z-index: 100;
    pointer-events: none;
}

/* â”€â”€ Ã‰crans UI (menu, config, etc.) â”€â”€ */
.screen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
    pointer-events: auto;
}

.screen.hidden { display: none; }
.hidden { display: none !important; }

/* â”€â”€ Ã‰cran titre â”€â”€ */
#titleScreen {
    background: radial-gradient(ellipse at center, rgba(14,27,61,0.85) 0%, rgba(6,8,26,0.95) 100%);
}

#titleScreen h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 52px;
    font-weight: 900;
    color: #C8A0FF;
    text-shadow: 0 0 30px rgba(160,80,255,0.5), 0 0 60px rgba(120,40,200,0.3);
    letter-spacing: 6px;
    margin-bottom: 12px;
}

#titleScreen .subtitle {
    font-family: 'Exo 2', sans-serif;
    font-size: 16px;
    color: rgba(180, 190, 220, 0.6);
    letter-spacing: 3px;
    margin-bottom: 50px;
}

#titleScreen h1 .title-letter {
    display: inline-block;
    opacity: 0;
    transform: translateY(20px);
    animation: letterAppear 0.4s forwards;
}

@keyframes letterAppear {
    to { opacity: 1; transform: translateY(0); }
}

#titleScreen .title-glow {
    animation: titlePulse 3s ease-in-out infinite;
}

@keyframes titlePulse {
    0%, 100% { text-shadow: 0 0 30px rgba(160,80,255,0.5), 0 0 60px rgba(120,40,200,0.3); }
    50% { text-shadow: 0 0 40px rgba(160,80,255,0.7), 0 0 80px rgba(120,40,200,0.4), 0 0 120px rgba(100,30,180,0.2); }
}

#titleScreen canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
}

#titleScreen .btn {
    opacity: 0;
    animation: fadeInUp 0.6s 2s forwards;
}

#titleScreen .subtitle {
    opacity: 0;
    animation: fadeInUp 0.5s 1.5s forwards;
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 15px;
    padding: 14px 40px;
    border: 1px solid rgba(160, 120, 255, 0.4);
    background: rgba(40, 20, 80, 0.5);
    color: #C8A0FF;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.3s;
    border-radius: 4px;
    margin: 6px;
}

.btn:hover {
    background: rgba(80, 40, 140, 0.6);
    border-color: rgba(180, 140, 255, 0.7);
    box-shadow: 0 0 20px rgba(140, 80, 220, 0.3);
}

/* â”€â”€ Lobby & Room â”€â”€ */
.room-slot {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 12px; border-radius: 6px;
    background: rgba(20,15,50,0.5); border: 1px solid rgba(100,70,180,0.2);
}
.room-slot .slot-color {
    width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0;
}
.room-slot .slot-name { flex: 1; color: #E0E7FF; font-size: 13px; }
.room-slot .slot-ready {
    font-family: 'Orbitron',monospace; font-size: 10px;
    letter-spacing: 1px; padding: 2px 8px; border-radius: 3px;
}
.room-slot .slot-ready.yes { color: #4ADE80; background: rgba(34,197,94,0.15); }
.room-slot .slot-ready.no { color: #64748B; background: rgba(100,116,139,0.1); }
.room-slot.empty { border-style: dashed; opacity: 0.4; }
.lobby-room-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 12px; border-radius: 6px; margin-bottom: 6px;
    background: rgba(20,15,50,0.5); border: 1px solid rgba(100,70,180,0.2);
    cursor: pointer; transition: all 0.2s;
}
.lobby-room-row:hover {
    background: rgba(40,30,80,0.6); border-color: rgba(34,197,94,0.4);
}

/* â”€â”€ Ã‰cran config â”€â”€ */
#configScreen {
    background: radial-gradient(ellipse at center, rgba(14,27,61,0.9) 0%, rgba(6,8,26,0.97) 100%);
}

#configScreen h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
    color: #C8A0FF;
    margin-bottom: 30px;
    letter-spacing: 3px;
}

.config-panel {
    background: rgba(20, 15, 50, 0.6);
    border: 1px solid rgba(100, 70, 180, 0.25);
    border-radius: 8px;
    padding: 25px 35px;
    width: 420px;
    max-width: 90vw;
}

.config-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 12px 0;
    font-size: 14px;
}

.config-row label {
    color: rgba(180, 190, 220, 0.8);
    font-family: 'Exo 2', sans-serif;
}

.config-row input[type="range"] {
    width: 140px;
    accent-color: #8B5CF6;
}

.config-row .val {
    color: #C8A0FF;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    min-width: 30px;
    text-align: right;
}

.config-row select {
    background: rgba(30, 20, 60, 0.8);
    border: 1px solid rgba(100, 70, 180, 0.4);
    color: #C8A0FF;
    padding: 4px 8px;
    font-family: 'Exo 2', sans-serif;
    border-radius: 3px;
}

.stat-group { margin: 16px 0 8px; }

.stat-group .stat-title {
    color: rgba(180, 190, 220, 0.6);
    font-size: 12px;
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 8px;
}

.stat-group .points-left {
    color: #FFD700;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    text-align: center;
    margin-bottom: 6px;
}

.color-picker {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 10px 0;
}

.color-swatch {
    width: 30px; height: 30px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
}

.color-swatch:hover { transform: scale(1.2); }
.color-swatch.selected { border-color: #FFF; box-shadow: 0 0 10px rgba(255,255,255,0.5); }

.config-buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-top: 20px;
}

/* â”€â”€ Ã‰cran spawn â”€â”€ */
#spawnScreen .spawn-banner {
    position: fixed;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    color: #FFD700;
    text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    letter-spacing: 2px;
    z-index: 55;
    pointer-events: none;
}

/* â”€â”€ HUD en jeu â”€â”€ */
#gameHud {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 20;
    display: none;
}

#sporeCounter {
    position: absolute;
    top: 12px; left: 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    color: #C8A0FF;
    pointer-events: auto;
}

#sporeCounter .count {
    font-size: 22px;
    color: #FFD700;
}

#evoPanel {
    position: absolute;
    top: 48px; left: 16px;
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    background: rgba(10,8,30,0.75);
    border: 1px solid rgba(100,70,180,0.3);
    border-radius: 6px;
    padding: 8px 12px;
    pointer-events: auto;
    min-width: 260px;
}
#evoPanel .evo-stats {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: 8px;
}
#evoPanel .stat-row {
    display: flex;
    align-items: center;
    gap: 6px;
}
#evoPanel .stat-icon { font-size: 12px; width: 16px; text-align: center; }
#evoPanel .stat-name {
    color: rgba(200,170,255,0.5);
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    width: 55px;
}
#evoPanel .stat-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    color: #E9D5FF;
    width: 20px;
    text-align: center;
}
#evoPanel .stat-bonus {
    font-size: 9px;
    color: #A855F7;
    width: 25px;
}
#evoPanel .stat-effect {
    font-size: 9px;
    color: rgba(200,170,255,0.4);
    flex: 1;
}
#evoPanel .evo-sep {
    height: 1px;
    background: rgba(168,85,247,0.2);
    margin: 4px 0 6px;
}
#evoPanel .evo-multi-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: #C084FC;
    letter-spacing: 1px;
    text-align: center;
    margin-bottom: 5px;
}
#evoPanel .evo-tier {
    display: flex;
    justify-content: center;
    gap: 3px;
    margin-bottom: 5px;
}
#evoPanel .tier-pip {
    width: 16px; height: 16px;
    border-radius: 50%;
    border: 2px solid rgba(168,85,247,0.3);
    background: rgba(0,0,0,0.5);
    transition: all 0.3s;
    display: flex; align-items: center; justify-content: center;
    font-size: 7px; color: transparent;
}
#evoPanel .tier-pip.filled {
    border-color: #A855F7;
    background: radial-gradient(circle, #C084FC, #7C3AED);
    box-shadow: 0 0 6px rgba(168,85,247,0.5);
    color: #fff;
}
#evoPanel .tier-pip.current {
    border-color: #E9D5FF;
    animation: tierPulse 1.5s infinite;
}
#evoPanel .evo-bar-bg {
    width: 100%; height: 6px;
    background: rgba(168,85,247,0.12);
    border-radius: 3px; overflow: hidden;
    margin-bottom: 4px;
}
#evoPanel .evo-bar {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #7C3AED, #C084FC);
    border-radius: 3px;
    transition: width 0.3s;
}
#evoPanel .evo-info {
    font-size: 9px;
    color: rgba(200,170,255,0.5);
    text-align: center;
    margin-bottom: 5px;
}
#evoPanel .evo-sacrifice {
    display: flex;
    align-items: center;
    gap: 6px;
    justify-content: center;
}
#evoPanel .evo-sacrifice label {
    font-size: 9px;
    color: rgba(200,170,255,0.5);
}
#evoPanel .evo-sacrifice input[type="range"] {
    width: 100px;
    accent-color: #A855F7;
}
#evoPanel .evo-sacrifice .sac-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: #C084FC;
    min-width: 30px;
    text-align: right;
}
#evoPanel .evo-choose {
    display: none;
    text-align: center;
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid rgba(168,85,247,0.2);
}
#evoPanel .evo-choose .choose-title {
    font-size: 9px; color: #E9D5FF;
    margin-bottom: 5px;
}
#evoPanel .evo-choose button {
    background: rgba(168,85,247,0.15);
    border: 1px solid rgba(168,85,247,0.4);
    color: #E9D5FF;
    padding: 4px 10px;
    margin: 0 3px;
    cursor: pointer;
    font-family: 'Exo 2', sans-serif;
    font-size: 10px;
    border-radius: 4px;
    transition: all 0.2s;
}
#evoPanel .evo-choose button:hover {
    background: rgba(168,85,247,0.3);
    border-color: #C084FC;
}
#evoPanel .evo-choose .stat-current {
    font-size: 8px; color: rgba(200,170,255,0.4);
}

#scoreBoard {
    position: absolute;
    top: 12px; right: 50px;
    background: rgba(10, 8, 30, 0.7);
    border: 1px solid rgba(100, 70, 180, 0.2);
    border-radius: 6px;
    padding: 10px 14px;
    min-width: 180px;
    pointer-events: auto;
}

.score-row {
    display: flex;
    align-items: center;
    margin: 4px 0;
    font-size: 12px;
    font-family: 'Exo 2', sans-serif;
}

.score-color {
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 8px;
    flex-shrink: 0;
}

.score-name {
    flex: 1;
    color: rgba(200, 210, 230, 0.8);
}

.score-bar-bg {
    width: 60px; height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    margin-left: 8px;
    overflow: hidden;
}

.score-bar {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s;
}

.score-pct {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: rgba(200, 200, 220, 0.6);
    margin-left: 6px;
    min-width: 28px;
    text-align: right;
}

/* â”€â”€ Codex (panneau latÃ©ral au clic astre) â”€â”€ */
#codex {
    position: fixed;
    right: -260px;
    top: 50%;
    transform: translateY(-50%);
    width: 240px;
    background: rgba(10, 8, 35, 0.85);
    border: 1px solid rgba(100, 70, 180, 0.3);
    border-right: none;
    border-radius: 8px 0 0 8px;
    padding: 18px;
    z-index: 30;
    transition: right 0.3s;
    pointer-events: auto;
}

#codex.open { right: 0; }

#codex h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    color: #C8A0FF;
    margin-bottom: 12px;
    letter-spacing: 1px;
}

#codex .codex-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    margin: 6px 0;
    color: rgba(180, 190, 220, 0.7);
}

#codex .codex-row .codex-val {
    color: rgba(220, 225, 240, 0.9);
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
}

#codex .close-btn {
    position: absolute;
    top: 6px; left: 8px;
    cursor: pointer;
    color: rgba(180,180,200,0.5);
    font-size: 16px;
    pointer-events: auto;
}

#codex .close-btn:hover { color: #FFF; }

#codex .codex-symbiose {
    margin: 8px 0 4px;
}

#codex .codex-symbiose .sym-label {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: rgba(180, 190, 220, 0.7);
    margin-bottom: 4px;
}

#codex .codex-symbiose .sym-label .sym-val {
    color: #22C55E;
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
}

#codex .codex-symbiose .sym-bar-bg {
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.08);
    border-radius: 3px;
    overflow: hidden;
}

#codex .codex-symbiose .sym-bar {
    height: 100%;
    background: linear-gradient(90deg, #22C55E, #86EFAC);
    border-radius: 3px;
    transition: width 0.5s;
}

#codex .codex-symbiose .sym-bonus {
    font-size: 10px;
    color: rgba(34, 197, 94, 0.6);
    margin-top: 2px;
    text-align: right;
}

#codex .codex-build {
    margin-top: 6px;
    padding: 6px 0;
    border-top: 1px solid rgba(100,70,180,0.2);
}
#codex .codex-build .build-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: #A78BFA;
    letter-spacing: 1px;
    margin-bottom: 4px;
}
#codex .codex-build .build-radios {
    display: flex; gap: 8px; margin-bottom: 6px;
}
#codex .codex-build .build-radios label {
    font-size: 11px; color: rgba(200,200,220,0.7);
    cursor: pointer; display: flex; align-items: center; gap: 3px;
}
#codex .codex-build .build-radios input[type="radio"] {
    accent-color: #A78BFA;
}
#codex .codex-build .build-info {
    font-size: 10px; color: rgba(200,200,220,0.5);
}
#codex .codex-build .build-count {
    font-size: 11px; color: #C8A0FF; margin-top: 3px;
}
#codex .codex-build .build-progress-bg {
    height: 4px; background: rgba(255,255,255,0.08);
    border-radius: 2px; margin-top: 3px; overflow: hidden;
}
#codex .codex-build .build-progress {
    height: 100%; border-radius: 2px;
    transition: width 0.3s;
}
#codex .codex-build .build-progress.nid { background: linear-gradient(90deg, #22C55E, #4ADE80); }
#codex .codex-build .build-progress.biome { background: linear-gradient(90deg, #3B82F6, #60A5FA); }

/* â”€â”€ Liste planÃ¨tes du joueur â”€â”€ */
#myPlanets {
    position: fixed;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: auto;
    min-width: 78px;
    background: rgba(10, 8, 35, 0.8);
    border: 1px solid rgba(100, 70, 180, 0.2);
    border-left: none;
    border-radius: 0 8px 8px 0;
    padding: 10px 8px;
    z-index: 25;
    pointer-events: auto;
    max-height: 80vh;
    overflow-y: auto;
    overflow-x: hidden;
    display: none;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
}

#myPlanets::-webkit-scrollbar { width: 3px; }
#myPlanets::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }

#myPlanets .mp-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: rgba(200,160,255,0.6);
    text-align: center;
    letter-spacing: 1px;
    margin-bottom: 8px;
}

#myPlanets .mp-sun-group {
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(100, 70, 180, 0.15);
}

#myPlanets .mp-sun-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: rgba(255, 220, 100, 0.5);
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 4px;
    padding-left: 2px;
}
#myPlanets .mp-sun-label .sys-complete {
    color: #FFD700;
    font-size: 8px;
    margin-left: 3px;
    text-shadow: 0 0 6px rgba(255,215,0,0.5);
}

#myPlanets .mp-row {
    display: flex;
    gap: 2px;
    padding-left: 2px;
    overflow-x: auto;
    overflow-y: hidden;
    max-width: 62px;
    transition: max-width 0.3s ease;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
    padding-bottom: 3px;
}

#myPlanets .mp-row::-webkit-scrollbar { height: 3px; }
#myPlanets .mp-row::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }

#myPlanets .mp-sun-group:hover .mp-row {
    max-width: 300px;
}

#myPlanets .mp-item {
    width: 58px;
    min-width: 58px;
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    position: relative;
    padding: 3px;
    border-radius: 6px;
    border: 2px solid transparent;
    transition: all 0.2s;
}

#myPlanets .mp-item:hover {
    border-color: rgba(200, 160, 255, 0.5);
    background: rgba(100, 70, 180, 0.1);
}

#myPlanets .mp-item.active {
    border-color: #FFD700;
    box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    background: rgba(255, 215, 0, 0.05);
}

#myPlanets .mp-item canvas {
    border-radius: 50%;
}

#myPlanets .mp-item .mp-name {
    font-family: 'Exo 2', sans-serif;
    font-size: 7px;
    color: rgba(200, 210, 230, 0.8);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 54px;
    text-align: center;
    margin-bottom: 2px;
}

#myPlanets .mp-type-badge {
    font-family: 'Orbitron', sans-serif;
    font-size: 6px;
    letter-spacing: 0.5px;
    padding: 1px 4px;
    border-radius: 2px;
    margin-bottom: 2px;
}

.planet-badge {
    color: rgba(100, 180, 255, 0.8);
    background: rgba(100, 180, 255, 0.1);
}

.moon-badge {
    color: rgba(200, 200, 220, 0.7);
    background: rgba(200, 200, 220, 0.1);
}

#myPlanets .mp-spores {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: #FFD700;
    margin-top: 1px;
}

/* â”€â”€ Pause overlay â”€â”€ */
.panel-drag-handle {
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 3px 6px;
    background: rgba(100,70,180,0.12);
    border-bottom: 1px solid rgba(100,70,180,0.15);
    border-radius: 6px 6px 0 0;
    user-select: none;
}
.panel-drag-handle:active { cursor: grabbing; }
.panel-drag-handle .panel-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: rgba(200,160,255,0.4);
    letter-spacing: 1px;
}
.panel-drag-handle .panel-collapse {
    cursor: pointer;
    font-size: 12px;
    color: rgba(200,160,255,0.4);
    transition: transform 0.2s;
    line-height: 1;
}
.panel-drag-handle .panel-collapse:hover { color: rgba(200,160,255,0.8); }
.panel-collapsed > *:not(.panel-drag-handle) { display: none !important; }
.panel-collapsed { min-height: auto !important; max-height: none !important; height: auto !important; overflow: hidden !important; }
#eventLog {
    position: fixed;
    bottom: 12px;
    left: 90px;
    width: 280px;
    max-height: 200px;
    background: rgba(6,8,26,0.85);
    border: 1px solid rgba(100,70,180,0.3);
    border-radius: 6px;
    z-index: 25;
    pointer-events: auto;
    display: none;
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    overflow: hidden;
}
#eventLog .log-header {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 8px;
    border-bottom: 1px solid rgba(100,70,180,0.2);
    flex-wrap: wrap;
}
#eventLog .log-header .log-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: rgba(200,160,255,0.6);
    letter-spacing: 1px;
    margin-right: auto;
}
#eventLog .log-filter {
    padding: 2px 6px;
    border-radius: 3px;
    border: 1px solid rgba(100,70,180,0.3);
    background: rgba(100,70,180,0.1);
    color: rgba(200,200,220,0.6);
    font-size: 8px;
    cursor: pointer;
    font-family: 'Exo 2', sans-serif;
    transition: all 0.2s;
}
#eventLog .log-filter.active {
    background: rgba(100,70,180,0.3);
    color: #c8a0ff;
    border-color: rgba(160,120,255,0.5);
}
#eventLog .log-body {
    max-height: 160px;
    overflow-y: auto;
    padding: 4px 0;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
}
#eventLog .log-body::-webkit-scrollbar { width: 3px; }
#eventLog .log-body::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }
#eventLog .log-entry {
    padding: 3px 8px;
    color: rgba(200,210,230,0.7);
    cursor: pointer;
    transition: background 0.15s;
    display: flex;
    gap: 6px;
    align-items: baseline;
}
#eventLog .log-entry:hover { background: rgba(100,70,180,0.1); }
#eventLog .log-entry .log-time {
    font-family: 'Orbitron', sans-serif;
    font-size: 8px;
    color: rgba(200,200,220,0.4);
    min-width: 35px;
}
#eventLog .log-entry .log-icon { font-size: 10px; }
#eventLog .log-entry .log-text { flex: 1; }
#pauseOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 60;
}

#pauseOverlay.active { display: flex; }

#pauseOverlay h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 36px;
    color: #C8A0FF;
    margin-bottom: 30px;
    letter-spacing: 4px;
}

/* â”€â”€ ContrÃ´le volume â”€â”€ */
#volumeControl {
    position: fixed;
    bottom: 12px;
    right: 12px;
    z-index: 25;
    display: flex;
    align-items: center;
    gap: 6px;
    pointer-events: auto;
    opacity: 0.5;
    transition: opacity 0.3s;
}
#volumeControl:hover { opacity: 1; }
#volumeControl .vol-icon {
    font-size: 16px;
    cursor: pointer;
    color: rgba(200,160,255,0.7);
}
#volumeControl input[type="range"] {
    width: 70px;
    accent-color: #8B5CF6;
}

/* â”€â”€ Minimap â”€â”€ */
/* â•â•â• ZOOM UI â•â•â• */
#uiZoomControl {
    position: fixed;
    bottom: 178px;
    right: 90px;
    width: 160px;
    z-index: 23;
    display: none;
    pointer-events: auto;
    text-align: center;
}
#uiZoomControl label {
    font-family: 'Orbitron', sans-serif;
    font-size: 8px;
    color: rgba(200,170,255,0.4);
    letter-spacing: 1px;
}
#uiZoomControl input[type="range"] {
    width: 100%;
    accent-color: #A78BFA;
    margin-top: 2px;
}
#uiZoomControl .uz-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: #C8A0FF;
}

#minimap {
    position: fixed;
    bottom: 12px;
    right: 90px;
    width: 160px;
    height: 160px;
    background: rgba(6, 8, 26, 0.85);
    border: 1px solid rgba(100, 70, 180, 0.3);
    border-radius: 6px;
    z-index: 22;
    pointer-events: auto;
    cursor: pointer;
    display: none;
}

#minimap canvas {
    width: 100%;
    height: 100%;
    border-radius: 5px;
}

/* â”€â”€ Compteur temps â”€â”€ */
#gameTimer {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    color: rgba(200, 200, 220, 0.5);
    letter-spacing: 1px;
    pointer-events: none;
}

/* â”€â”€ Indicateurs hors-Ã©cran â”€â”€ */
.offscreen-indicator {
    position: fixed;
    width: 0; height: 0;
    z-index: 21;
    pointer-events: none;
}

/* â”€â”€ Transitions â”€â”€ */
#screenFade {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s;
}

#screenFade.active { opacity: 1; }

/* â”€â”€ Loading screen â”€â”€ */
#loadingScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #06081A;
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#loadingScreen.hidden { display: none; }

#loadingScreen h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 24px;
    color: #C8A0FF;
    letter-spacing: 4px;
    margin-bottom: 30px;
}

#loadingBar {
    width: 250px;
    height: 4px;
    background: rgba(255,255,255,0.08);
    border-radius: 2px;
    overflow: hidden;
}

#loadingBarFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #8B5CF6, #C8A0FF);
    border-radius: 2px;
    transition: width 0.2s;
}

#loadingText {
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    color: rgba(180, 190, 220, 0.4);
    margin-top: 12px;
    letter-spacing: 1px;
}

/* â”€â”€ Ã‰cran de fin â”€â”€ */
#endScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 70;
}

#endScreen.active { display: flex; }

#endScreen h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 42px;
    letter-spacing: 4px;
    margin-bottom: 10px;
}

#endScreen h1.victory { color: #FFD700; text-shadow: 0 0 30px rgba(255,215,0,0.5); }
#endScreen h1.defeat { color: #EF4444; text-shadow: 0 0 30px rgba(239,68,68,0.4); }

#endScreen .end-subtitle {
    font-family: 'Exo 2', sans-serif;
    font-size: 16px;
    color: rgba(200,210,230,0.6);
    margin-bottom: 30px;
}

#endScreen .end-stats {
    background: rgba(20, 15, 50, 0.6);
    border: 1px solid rgba(100, 70, 180, 0.25);
    border-radius: 8px;
    padding: 20px 30px;
    margin-bottom: 25px;
    min-width: 300px;
}

#endScreen .end-stat-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-family: 'Exo 2', sans-serif;
    font-size: 14px;
    color: rgba(180,190,220,0.7);
}

#endScreen .end-stat-row .end-stat-val {
    color: #C8A0FF;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
}

#endScreen .end-buttons { display: flex; gap: 12px; }


</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
#authScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: linear-gradient(180deg, #162650, #0a0e28);
}
#authScreen input:focus {
    border-color: #8B5CF6;
    box-shadow: 0 0 8px rgba(139,92,246,0.3);
}
#authScreen .btn { font-size: 14px; padding: 10px 20px; }
</style>
</head>
<body>

<!-- â•â•â• Ã‰CRAN TITRE â•â•â• -->
<!-- â•â•â• Ã‰CRAN AUTH â•â•â• -->
<div id="authScreen" class="screen">
    <h1 class="title-glow" style="font-family:'Orbitron',monospace; font-size:2.5rem; color:#E0E7FF; text-shadow:0 0 30px rgba(139,92,246,0.5); margin-bottom:30px;">NEBULA CONQUEST</h1>
    <div id="authBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(139,92,246,0.3); border-radius:12px; padding:30px; max-width:360px; margin:0 auto; text-align:center;">
        <div id="authStep1">
            <p style="color:#94A3B8; margin-bottom:16px; font-size:14px;">Connectez-vous ou crÃ©ez un compte</p>
            <input type="email" id="authEmail" placeholder="votre@email.com" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <input type="password" id="authPassword" placeholder="Mot de passe (6 car. min)" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <button class="btn" id="btnAuthLogin" style="width:100%; margin-top:4px;">CONNEXION</button>
            <button class="btn" id="btnAuthSignup" style="width:100%; margin-top:8px; background:rgba(139,92,246,0.2); border:1px solid rgba(139,92,246,0.4);">CRÃ‰ER UN COMPTE</button>
            <p id="authMsg" style="color:#8B5CF6; margin-top:12px; font-size:13px; min-height:20px;"></p>
        </div>
        <div id="authStep2" style="display:none;">
            <p style="color:#94A3B8; margin-bottom:16px; font-size:14px;">Choisissez votre pseudo de commandant</p>
            <input type="text" id="authPseudo" placeholder="Pseudo (3-20 car.)" maxlength="20" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <button class="btn" id="btnAuthPseudo" style="width:100%; margin-top:4px;">CONFIRMER</button>
            <p id="pseudoMsg" style="color:#8B5CF6; margin-top:12px; font-size:13px; min-height:20px;"></p>
        </div>
    </div>
</div>

<div id="titleScreen" class="screen hidden">
    <canvas id="titleBgCanvas"></canvas>
    <h1 id="titleText" class="title-glow"></h1>
    <div class="subtitle">CONQUÃŠTE SPATIALE EN TEMPS RÃ‰EL</div>
    <button class="btn" id="btnNewGame">NOUVELLE PARTIE</button>
    <button class="btn" id="btnMulti" style="margin-top:8px; background:rgba(34,197,94,0.15); border:1px solid rgba(34,197,94,0.4); color:#4ADE80;">MULTIJOUEUR</button>
    <button class="btn" id="btnLeaderboard" style="margin-top:8px; background:rgba(139,92,246,0.2); border:1px solid rgba(139,92,246,0.4);">CLASSEMENT</button>
</div>

<!-- â•â•â• Ã‰CRAN LEADERBOARD â•â•â• -->
<div id="leaderboardScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#E0E7FF; text-shadow:0 0 20px rgba(139,92,246,0.4); margin-bottom:20px;">CLASSEMENT</h2>
    <div id="leaderboardBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(139,92,246,0.3); border-radius:12px; padding:20px; max-width:500px; margin:0 auto; max-height:60vh; overflow-y:auto;">
        <table style="width:100%; border-collapse:collapse; font-size:14px;">
            <thead>
                <tr style="color:#8B5CF6; border-bottom:1px solid rgba(139,92,246,0.3);">
                    <th style="padding:8px; text-align:left;">#</th>
                    <th style="padding:8px; text-align:left;">Joueur</th>
                    <th style="padding:8px; text-align:center;">Victoires</th>
                    <th style="padding:8px; text-align:center;">Parties</th>
                    <th style="padding:8px; text-align:center;">%</th>
                </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
        </table>
        <p id="leaderboardEmpty" style="color:#94A3B8; text-align:center; padding:20px; display:none;">Aucune partie enregistrÃ©e.</p>
    </div>
    <button class="btn" id="btnLeaderboardBack" style="margin-top:16px;">RETOUR</button>
</div>

<!-- â•â•â• Ã‰CRAN LOBBY MULTI â•â•â• -->
<div id="lobbyScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#4ADE80; text-shadow:0 0 20px rgba(34,197,94,0.4); margin-bottom:20px;">MULTIJOUEUR</h2>
    <div id="lobbyBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(34,197,94,0.3); border-radius:12px; padding:20px; max-width:520px; margin:0 auto; max-height:60vh; overflow-y:auto;">
        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;">
            <span style="color:#94A3B8; font-size:13px;">Parties ouvertes</span>
            <button class="btn" id="btnCreateRoom" style="font-size:12px; padding:8px 16px; background:rgba(34,197,94,0.2); border-color:rgba(34,197,94,0.5); color:#4ADE80;">+ CRÃ‰ER</button>
        </div>
        <div id="lobbyRoomList" style="min-height:60px;">
            <p style="color:#64748B; text-align:center; padding:20px; font-size:13px;">Chargement...</p>
        </div>
    </div>
    <button class="btn" id="btnLobbyBack" style="margin-top:16px;">RETOUR</button>
</div>

<!-- â•â•â• Ã‰CRAN ROOM (salle d'attente) â•â•â• -->
<div id="roomScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#4ADE80; text-shadow:0 0 20px rgba(34,197,94,0.4); margin-bottom:6px;">SALLE D'ATTENTE</h2>
    <p id="roomCode" style="font-family:'Orbitron',monospace; font-size:11px; color:#64748B; letter-spacing:2px; margin-bottom:16px;"></p>
    <div id="roomBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(34,197,94,0.3); border-radius:12px; padding:20px; max-width:420px; margin:0 auto;">
        <div id="roomSlots" style="display:flex; flex-direction:column; gap:8px;"></div>
        <div style="display:flex; justify-content:center; gap:10px; margin-top:16px;">
            <button class="btn" id="btnRoomReady" style="font-size:13px; padding:10px 24px; background:rgba(34,197,94,0.2); border-color:rgba(34,197,94,0.5); color:#4ADE80;">PRÃŠT</button>
            <button class="btn" id="btnRoomStart" style="font-size:13px; padding:10px 24px; background:rgba(234,179,8,0.2); border-color:rgba(234,179,8,0.5); color:#FBBF24; display:none;">LANCER</button>
        </div>
    </div>
    <button class="btn" id="btnRoomLeave" style="margin-top:16px; font-size:12px; padding:8px 20px;">QUITTER</button>
</div>

<!-- â•â•â• Ã‰CRAN CONFIG â•â•â• -->
<div id="configScreen" class="screen hidden">
    <h2>CONFIGURATION</h2>
    <div class="config-panel">
        <div class="config-row">
            <label>Soleils</label>
            <input type="range" id="cfgSuns" min="1" max="8" value="4">
            <span class="val" id="cfgSunsVal">4</span>
        </div>
        <div class="config-row">
            <label>Joueurs</label>
            <input type="range" id="cfgPlayers" min="2" max="10" value="4">
            <span class="val" id="cfgPlayersVal">4</span>
        </div>
        <div class="config-row">
            <label>DifficultÃ© IA</label>
            <select id="cfgDifficulty">
                <option value="easy">Facile</option>
                <option value="normal" selected>Normal</option>
                <option value="brutal">Brutal</option>
            </select>
        </div>

        <div class="config-row">
            <label>IA</label>
            <select id="cfgIA">
                <option value="on" selected>ActivÃ©e</option>
                <option value="off">DÃ©sactivÃ©e</option>
            </select>
        </div>
        <div class="config-row">
            <label>Vaisseaux ennemis</label>
            <input type="range" id="cfgCleaners" min="1" max="25" value="3">
            <span class="val" id="cfgCleanersVal">3</span>
        </div>

        <div class="config-row">
            <label>Amas de mÃ©tÃ©orites</label>
            <select id="cfgAsteroids">
                <option value="on" selected>ActivÃ©s</option>
                <option value="off">DÃ©sactivÃ©s</option>
            </select>
        </div>

        <div class="stat-group">
            <div class="stat-title">ATTRIBUTS DU JOUEUR</div>
            <div class="points-left">Points restants : <span id="pointsLeft">10</span></div>
            <div class="config-row">
                <label>Croissance</label>
                <input type="range" id="statGrowth" min="0" max="10" value="0">
                <span class="val" id="statGrowthVal">0</span>
            </div>
            <div class="config-row">
                <label>VÃ©locitÃ©</label>
                <input type="range" id="statVelocity" min="0" max="10" value="0">
                <span class="val" id="statVelocityVal">0</span>
            </div>
            <div class="config-row">
                <label>DensitÃ©</label>
                <input type="range" id="statDensity" min="0" max="10" value="0">
                <span class="val" id="statDensityVal">0</span>
            </div>
        </div>

        <div class="stat-group">
            <div class="stat-title">COULEUR D'Ã‰QUIPE</div>
            <div class="color-picker" id="colorPicker"></div>
        </div>

        <div class="config-buttons">
            <button class="btn" id="btnBack">RETOUR</button>
            <button class="btn" id="btnStart">LANCER</button>
        </div>
    </div>
</div>

<!-- â•â•â• BANNIÃˆRE SPAWN â•â•â• -->
<div id="spawnBanner" class="hidden" style="position:fixed;top:20px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;color:#FFD700;text-shadow:0 0 15px rgba(255,215,0,0.4);letter-spacing:2px;z-index:55;pointer-events:none;">CHOISISSEZ VOTRE PLANÃˆTE DE DÃ‰PART</div>

<!-- â•â•â• LOADING â•â•â• -->
<div id="loadingScreen">
    <h2>NEBULA CONQUEST</h2>
    <div id="loadingBar"><div id="loadingBarFill"></div></div>
    <div id="loadingText">Initialisation...</div>
</div>

<!-- â•â•â• FADE â•â•â• -->
<div id="screenFade"></div>

<!-- â•â•â• CANVAS â•â•â• -->
<canvas id="gameCanvas"></canvas>
<div id="fps">-- FPS</div>

<!-- â•â•â• HUD EN JEU â•â•â• -->
<div id="gameHud">
    <div id="sporeCounter" title="Total de spores sur tous vos astres">SPORES <span class="count" id="sporeCount">0</span></div>
    <div id="evoPanel">
        <div class="evo-stats">
            <div class="stat-row" title="Multiplie la vitesse de production de spores sur vos planÃ¨tes (+30% par point)"><span class="stat-icon">ğŸŒ±</span><span class="stat-name">Growth</span><span class="stat-val" id="evoStatGrowth">3</span><span class="stat-bonus" id="evoStatGrowthBonus"></span><span class="stat-effect" id="evoStatGrowthFx"></span></div>
            <div class="stat-row" title="Augmente la vitesse de dÃ©placement des jets de spores (+6 par point)"><span class="stat-icon">âš¡</span><span class="stat-name">Velocity</span><span class="stat-val" id="evoStatVelocity">4</span><span class="stat-bonus" id="evoStatVelocityBonus"></span><span class="stat-effect" id="evoStatVelocityFx"></span></div>
            <div class="stat-row" title="Augmente les spores dÃ©livrÃ©es Ã  l'impact (+5% par point)"><span class="stat-icon">ğŸ’</span><span class="stat-name">Density</span><span class="stat-val" id="evoStatDensity">3</span><span class="stat-bonus" id="evoStatDensityBonus"></span><span class="stat-effect" id="evoStatDensityFx"></span></div>
        </div>
        <div class="evo-sep"></div>
        <div class="evo-multi-title" title="Sacrifiez une partie de votre production pour gagner des paliers d'Ã©volution. Chaque palier donne +1 point de stat au choix.">âœ¦ MULTIPLICITÃ‰ âœ¦</div>
        <div class="evo-tier" id="evoTierPips"></div>
        <div class="evo-bar-bg"><div class="evo-bar" id="evoBar"></div></div>
        <div class="evo-info" id="evoInfo">Palier 0/10 â€” 0 / 500 spores</div>
        <div class="evo-sacrifice">
            <label title="Pourcentage de production redirigÃ© vers l'Ã©volution (rÃ©duit la production de spores)">Sacrifice</label>
            <input type="range" id="evoSacrifice" min="0" max="50" value="0" step="5">
            <span class="sac-val" id="evoSacVal">0%</span>
        </div>
        <div class="evo-choose" id="evoChoose">
            <div class="choose-title">â¬† CHOISISSEZ UN BONUS â¬†</div>
            <button id="evoGrowth">ğŸŒ± Growth <div class="stat-current" id="evoGrowthCur"></div></button>
            <button id="evoVelocity">âš¡ Velocity <div class="stat-current" id="evoVelocityCur"></div></button>
            <button id="evoDensity">ğŸ’ Density <div class="stat-current" id="evoDensityCur"></div></button>
        </div>
    </div>
    <div id="gameTimer">00:00</div>
    <div id="scoreBoard"></div>
</div>

<!-- â•â•â• MINIMAP â•â•â• -->
<div id="uiZoomControl">
    <label>TAILLE UI</label>
    <input type="range" id="uiZoomSlider" min="60" max="140" value="100" step="5">
    <span class="uz-val" id="uiZoomVal">100%</span>
    <br><span id="uiResetBtn" style="font-family:'Orbitron',sans-serif;font-size:7px;color:rgba(200,170,255,0.5);cursor:pointer;letter-spacing:1px;margin-top:3px;display:inline-block;" title="RÃ©initialiser positions des panneaux">âŸ² RESET POSITIONS</span>
</div>
<div id="minimap"><canvas id="minimapCanvas" width="160" height="160"></canvas></div>

<!-- â•â•â• MES PLANÃˆTES â•â•â• -->

<div id="myPlanets">
    <div class="mp-title">MES ASTRES</div>
    <div id="myPlanetsList"></div>
</div>

<!-- â•â•â• CODEX â•â•â• -->
<div id="eventLog">
    <div class="log-header">
        <span class="log-title">Ã‰VÃ‰NEMENTS</span>
        <span class="log-filter active" data-cat="all">Tous</span>
        <span class="log-filter" data-cat="neutral">Neutres</span>
        <span class="log-filter" data-cat="war">Guerres</span>
        <span class="log-filter" data-cat="mine">Mes astres</span>
        <span class="log-filter" data-cat="build">Constructions</span>
    </div>
    <div class="log-body" id="eventLogBody"></div>
</div>

<div id="codex">
    <span class="close-btn" id="codexClose">âœ•</span>
    <h3 id="codexName">â€”</h3>
    <div id="codexPreview" style="text-align:center;margin:8px 0;"></div>
    <div class="codex-row"><span>Type</span><span class="codex-val" id="codexType">â€”</span></div>
    <div class="codex-row"><span>Radius</span><span class="codex-val" id="codexRadius">â€”</span></div>
    <div class="codex-row" title="DÃ©termine la vitesse de production de spores (plus c'est haut, mieux c'est)"><span>Flore</span><span class="codex-val" id="codexFlore">â€”</span></div>
    <div class="codex-row" title="DÃ©fense naturelle : absorbe les spores ennemies lors d'une conquÃªte"><span>Faune</span><span class="codex-val" id="codexFaune">â€”</span></div>
    <div class="codex-row"><span>PropriÃ©taire</span><span class="codex-val" id="codexOwner">â€”</span></div>
    <div class="codex-row" title="Nombre de spores actuellement stockÃ©es sur cet astre"><span>Spores</span><span class="codex-val" id="codexSpores">â€”</span></div>
    <div class="codex-symbiose" id="codexSymbiose" style="display:none;">
        <div class="sym-label" title="Augmente avec le temps de possession (+20% prod max pour planÃ¨tes, +10% pour lunes)"><span>Symbiose</span><span class="sym-val" id="codexSymVal">0%</span></div>
        <div class="sym-bar-bg"><div class="sym-bar" id="codexSymBar" style="width:0%"></div></div>
        <div class="sym-bonus" id="codexSymBonus"></div>
    </div>
    <div class="codex-build" id="codexBuild" style="display:none;">
        <div class="build-title">PRODUCTION</div>
        <div class="build-radios">
            <label><input type="radio" name="buildMode" value="off" checked> Off</label>
            <label title="Construit un nid : +0.2% de production locale par nid"><input type="radio" name="buildMode" value="nid"> Nid</label>
            <label title="Construit un biome : +0.2% de dÃ©fense locale par biome (rÃ©duit l'attaque ennemie)"><input type="radio" name="buildMode" value="biome"> Biome</label>
        </div>
        <div class="build-count" id="codexBuildCount"></div>
        <div class="build-info" id="codexBuildInfo"></div>
        <div class="build-progress-bg"><div class="build-progress" id="codexBuildBar" style="width:0%"></div></div>
    </div>
</div>

<!-- â•â•â• PAUSE â•â•â• -->
<div id="pauseOverlay">
    <h2>PAUSE</h2>
    <button class="btn" id="btnResume">REPRENDRE</button>
    <button class="btn" id="btnQuit">QUITTER</button>
</div>

<script>
/* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   NEBULA CONQUEST â€” JAVASCRIPT
   Version: 1.1.0

   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   DEV LOG
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   v2.4.6 | 2026-02-27 | Multijoueur â€” Lobby & Rooms
     - Bouton MULTIJOUEUR sur l'Ã©cran titre
     - Ã‰cran lobby : liste des parties ouvertes en temps rÃ©el
     - Ã‰cran salle d'attente : slots joueurs, statut prÃªt, code room
     - CrÃ©ation / rejoindre / quitter une room via Supabase
     - Supabase Realtime : sync automatique des joueurs dans la room
     - Bouton PRÃŠT et LANCER (hÃ´te uniquement, quand tous prÃªts)
     - Tables game_rooms et game_room_players avec RLS

   v2.4.5 | 2026-02-27 | Panneaux UI â€” Scale, Snap & Reset
     - Zoom UI (slider taille) affecte dÃ©sormais TOUS les panneaux (eventLog, codex, sporeCounter, scoreBoard)
     - Drag des panneaux prÃ©serve le scale UI en cours
     - 8 panneaux draggables : Spores, Ã‰volution, Scores, Minimap, Taille UI, Mes Astres, Ã‰vÃ©nements, Codex
     - Tableau des scores (scoreBoard) et compteur Spores rendus interactifs (pointer-events)
     - Handle du scoreBoard prÃ©servÃ© lors des mises Ã  jour dynamiques du contenu
     - Accrochage magnÃ©tique (snap) entre panneaux au relÃ¢chement du drag (14px)
     - Snap aux bords de l'Ã©cran
     - Bouton âŸ² RESET POSITIONS pour rÃ©initialiser toute la disposition UI
     - Reset remet aussi le slider de taille Ã  100%

   v2.4.3 | 2026-02-27 | Gameplay avancÃ© & UI
     - ParamÃ¨tres de partie : soleils (1-8), joueurs (2-10), IA on/off, vaisseaux (1-25), mÃ©tÃ©orites on/off
     - 3 types de ceintures d'astÃ©roÃ¯des : noir (Ã·2 spores), rouge (dÃ©viation), vert (split Ã—5)
     - 3 types de vaisseaux ennemis : rouge (attaque), vert (Ã—2 boost), noir (renvoi Ã  la base)
     - Graphismes amÃ©liorÃ©s : mÃ©tÃ©orites polygonales, vaisseaux dÃ©taillÃ©s avec cockpit et traÃ®nÃ©e
     - Vaisseaux patrouillent entre planÃ¨tes (navigation intelligente)
     - Jets renvoyÃ©s par vaisseaux noirs suivent la cible en temps rÃ©el (homing)
     - Journal d'Ã©vÃ©nements avec filtres (Tous/Neutres/Guerres/Mes astres/Constructions)
     - Ã‰vÃ©nements cliquables pour naviguer vers le lieu de l'action
     - IcÃ´nes colorÃ©es selon le joueur dans le journal
     - ContrÃ´le Nid/Biome/Off par systÃ¨me solaire dans le panneau gauche
     - Panneaux draggables et rÃ©tractables (6 panneaux)
     - Sauvegarde positions des panneaux dans Supabase (profil joueur)
     - Synchronisation curseurs config au dÃ©marrage
     - Espacement orbites solaires augmentÃ© (pas de chevauchement avec mÃ©tÃ©orites)
     - Collision mÃ©tÃ©orites par proximitÃ© rÃ©elle d'amas (plus de faux positifs)

   v2.4.2 | 2026-02-27 | Mise en ligne & Auth
     - DÃ©ploiement GitHub Pages (gadmy.github.io/nebula-conquest)
     - IntÃ©gration Supabase Auth (inscription email + mot de passe)
     - Ã‰cran de login avec choix de pseudo Ã  la premiÃ¨re connexion
     - Tables Supabase : profiles, games, leaderboard (vue)
     - Row Level Security (RLS) sur toutes les tables
     - Sauvegarde automatique des parties en fin de game
     - Ã‰cran Classement (leaderboard) accessible depuis le menu titre

   v2.4.1 | 2026-02-26 | Nettoyage debug & config
     - Suppression complÃ¨te du code debug (CSS, HTML, JS)
     - Suppression panneaux debug F2-F7
     - Config par dÃ©faut : 4 soleils, 4 joueurs, stats 0/0/0
     - Hitbox amÃ©liorÃ©es : lunes +12, petites planÃ¨tes +10
     - Couleurs ciel Ã©claircies (RGB 22,38,78)
     - Vitesse jets : 0.25 â†’ 0.70
     - Suppression fonction orpheline generateBackgroundFromConfig
     - Correction rÃ©fÃ©rence BG_CFG

   v2.4.0 | 2026-02-25 | Optimisation performances
     - Ã‰toiles de base prÃ©-rendues sur canvas offscreen (âˆ’2500 draw calls)
     - Amas stellaires prÃ©-rendus sur canvas offscreen (âˆ’660 draw calls)
     - LOD dynamique selon le zoom (3 niveaux de dÃ©tail)
     - Cache gradients Ã©toiles brillantes, soleils, atmosphÃ¨res planÃ©taires
     - Jets optimisÃ©s : traÃ®ne simplifiÃ©e, sparkles LOD
     - Array allBodies prÃ©-calculÃ© (âˆ’11 allocations/frame)
     - Minimap throttle (toutes les 15 frames)
     - FPS adaptatif (auto-LOD si FPS < 25)

   v2.3.0 | 2026-02-25 | ComÃ¨tes, dÃ©bris & effets d'impact
     - ComÃ¨tes destructrices (dÃ©truisent les spores au contact d'une planÃ¨te)
     - DÃ©bris au premier plan (effet parallaxe profondeur)
     - Debug F5 (vaisseaux/jets) et F6 (comÃ¨tes)
     - Effets d'impact sur soleils et trou noir

   v2.2.0 | 2026-02-25 | UX â€” Interface adaptable
     - Jauge de taille d'interface au-dessus de la minimap
     - Scroll horizontal dans "Mes Astres" pour les systÃ¨mes avec beaucoup de planÃ¨tes
     - Clic sur un astre dans "Mes Astres" ouvre aussi le codex

   v2.1.0 | 2026-02-25 | MultiplicitÃ©
     - Sacrifice : slider 0-50% de production globale dÃ©diÃ© Ã  l'Ã©volution
     - 10 paliers, coÃ»t croissant (500 * 1.8^N)
     - Chaque palier = +1 point de stat (growth, velocity ou density)
     - Choix du stat Ã  chaque palier atteint
     - IA utilise aussi le systÃ¨me de multiplicitÃ©

   v2.0.0 | 2026-02-25 | Nids & Biomes
     - Mode production par planÃ¨te : OFF / NID / BIOME (radio dans codex)
     - Activation = maxSpores Ã· 3, production allouÃ©e au compteur
     - CoÃ»t nid/biome = maxSpores, infini par planÃ¨te
     - Nid : +0.2% production locale par nid
     - Biome : +0.2% dÃ©fense locale par biome (coÃ»t conquÃªte augmentÃ©)
     - Reset Ã  la conquÃªte, IA utilise aussi

   v1.9.0 | 2026-02-25 | Fond spatial 5 couches
     - Couche 1 : voiles galactiques immenses (gradient + blobs irrÃ©guliers)
     - Couche 2 : 10 nÃ©buleuses denses avec rim lighting et cÅ“ur lumineux
     - Couche 3 : filaments de gaz (traÃ®nÃ©es longues)
     - Couche 4 : 12 amas stellaires (distribution gaussienne)
     - Couche 5 : 25 Ã©toiles brillantes avec diffraction 8 branches + scintillement
     - 2500 Ã©toiles de base + 40 particules cosmiques + Ã©toiles filantes
     - Parallaxe individuelle par objet, drift et rotation

   v1.8.0 | 2026-02-24 | Polish final
     - Animation titre : lettres qui apparaissent une par une
     - Ã‰toiles filantes en fond sur l'Ã©cran titre
     - Ã‰cran de chargement avec progression rÃ©elle
     - Transitions fade entre les Ã©crans
     - Panneau debug cachÃ© (F2 toggle conservÃ©)
     - Nettoyage commentaires

   v1.7.0 | 2026-02-24 | Performance
     - Pool d'objets pour jets, impacts et effets
     - Cache des Ã©lÃ©ments DOM frÃ©quemment accÃ©dÃ©s
     - Throttle scoreboard (innerHTML moins frÃ©quent)
     - Optimisation drawJets (moins de createRadialGradient)
     - RÃ©duction allocations dans les boucles de rendu

   v1.6.0 | 2026-02-24 | Audio avancÃ©
     - Ambiance adaptative (tension quand attaquÃ©, calme sinon)
     - Son de clic sur les boutons du menu
     - Son d'orbite subtil quand zoomÃ© sur une planÃ¨te
     - Variation de pitch sur les sons existants

   v1.5.0 | 2026-02-24 | Interface avancÃ©e
     - Minimap (coin bas-droit, vue globale, rectangle de vue)
     - Indicateurs hors-Ã©cran (flÃ¨ches colorÃ©es pour jets ennemis)
     - Compteur de temps de partie dans le HUD
     - Transitions fluides entre Ã©crans (fade 0.5s)
     - Ã‰cran de chargement avec barre de progression

   v1.4.0 | 2026-02-24 | Fond spatial amÃ©liorÃ©
     - Parallaxe 3 couches (nÃ©buleuses lentes, Ã©toiles moyennes, poussiÃ¨re rapide)
     - Particules ambiantes flottantes (poussiÃ¨re cosmique)
     - Ã‰toiles filantes occasionnelles (1 toutes les 5-10s)

   v1.3.0 | 2026-02-24 | Textures & rendu amÃ©liorÃ©s
     - Anneaux pour les planÃ¨tes gazeuses
     - AtmosphÃ¨re lumineuse (halo colorÃ©, ocean/ice/gas)
     - Lunes variÃ©es (glace, roche sombre, volcanique)
     - Ã‰clairage directionnel des soleils sur planÃ¨tes proches
     - Animation d'impact (onde de choc + particules Ã©clats)

   v1.2.0 | 2026-02-24 | Symbiose
     - PropriÃ©tÃ© symbiose (0-100%) sur chaque astre possÃ©dÃ©
     - Croissance : 100% en 10 min (planÃ¨tes), 100% en 5 min (lunes)
     - Reset Ã  0 si l'astre change de propriÃ©taire
     - Bonus production : +20% Ã  100% (planÃ¨tes), +10% (lunes)
     - Barre de symbiose dans le codex
     - Indicateur symbiose dans le panneau Mes PlanÃ¨tes
     - Les IAs bÃ©nÃ©ficient aussi de la symbiose

   v1.1.0 | 2026-02-24 | Polish interface
     - Panneau planÃ¨tes : groupÃ© par systÃ¨me solaire, dÃ©ploiement au survol
     - IcÃ´ne du soleil dans le label de chaque groupe
     - Badge PLANÃˆTE / LUNE sur chaque astre
     - Codex : aperÃ§u texture 80px de l'astre sÃ©lectionnÃ©
     - Zoom max augmentÃ© Ã  x10
     - Valeurs jets ajustÃ©es (core:2, speed:0.70)

   v1.0.0 | 2026-02-24 | Ã‰tape 10 â€” Polish & optimisation
     - Culling : ne dessine que les astres visibles Ã  l'Ã©cran
     - Batch rendering des Ã©toiles de fond
     - Optimisation des collisions (grille spatiale)
     - Ã‰quilibrage Flore/Faune/vitesses orbites
     - Ã‰cran de fin complet avec stats dÃ©taillÃ©es
     - Boutons Rejouer/Menu fonctionnels
     - Nettoyage du code et commentaires
     - Compatible Chrome/Firefox/Safari/Edge
     - GitHub Pages ready (fichier unique)

   v0.9.0 | 2026-02-24 | Ã‰tape 9 â€” Audio gÃ©nÃ©ratif
     - Web Audio API : aucun fichier externe
     - Ambiance spatiale : drone basse frÃ©quence modulÃ©
     - Son de lancement de jet (texture granulaire)
     - Son de fusion sur astre ami (accord harmonique)
     - Son de conquÃªte/Ã©closion (accord ascendant)
     - Son de neutralisation (collision sourde)
     - Son de vaisseau nettoyeur (ping directionnel)
     - Son de victoire/dÃ©faite (sÃ©quence mÃ©lodique)
     - ContrÃ´le du volume gÃ©nÃ©ral

   v0.8.0 | 2026-02-24 | Ã‰tape 8 â€” Obstacles & dangers
     - Trou noir : gravitÃ© active courbant les jets
     - Zone de destruction visible (jets trop proches dÃ©truits)
     - Vaisseaux nettoyeurs : patrouille entre systÃ¨mes solaires
     - Nettoyeurs tirent sur les jets Ã  portÃ©e (rÃ©duction de spores)
     - Nettoyeurs invincibles (contournement uniquement)
     - Trajectoires semi-alÃ©atoires lisibles Ã  court terme
     - Scaling : 1 vaisseau â‰¤5 planÃ¨tes, 2 pour 5-8, 3 pour 8-10

   v0.7.0 | 2026-02-24 | Ã‰tape 7 â€” Intelligence artificielle
     - IA Facile : cibles alÃ©atoires, rÃ©action lente (3s)
     - IA Normale : Ã©value Flore+proximitÃ©, interception basique, rÃ©action 1.5s
     - IA Brutale : interception orbitale, coordination multi-astres, rÃ©action 0.5s
     - Gestion attaque/dÃ©fense : garde des rÃ©serves sur astres exposÃ©s
     - Les IAs jouent selon les mÃªmes rÃ¨gles que le joueur humain

   v0.6.0 | 2026-02-24 | Ã‰tape 6 â€” ConquÃªte & Ã©conomie
     - Indicateur visuel de conquÃªte (chiffre flottant au-dessus des astres)
     - Animation d'Ã©closion Ã  100% de conquÃªte
     - RÃ©gÃ©nÃ©ration de la Faune si attaque interrompue
     - Condition de victoire : 80% de la masse totale
     - Ã‰limination : plus d'astres + plus de jets â†’ mode spectateur
     - Ã‰cran de fin avec stats et boutons Rejouer/Quitter
     - Affichage spores sur chaque astre possÃ©dÃ©

   v0.5.0 | 2026-02-24 | Ã‰tape 5 â€” MÃ©canique de spores
     - Lancement de jets : clic maintenu sur astre â†’ glisser â†’ relÃ¢cher
     - PrÃ©visualisation trajectoire (70% en pointillÃ©s bioluminescents)
     - Trajectoire courbÃ©e par gravitÃ© du trou noir
     - Jets rendus comme gerbes bioluminescentes avec traÃ®ne
     - Taille/intensitÃ© proportionnelles au nombre de spores
     - Collision jet-astre (dÃ©pÃ´t de spores)
     - Neutralisation de jets croisÃ©s (proportionnelle)
     - Jets comme entitÃ©s uniques (jamais de spore individuelle)

   v0.4.0 | 2026-02-24 | Ã‰tape 4 â€” Interface & menus
     - Ã‰cran titre avec bouton Nouvelle Partie
     - Config : soleils (4-20), joueurs (2-8), difficultÃ© IA
     - RÃ©partition des 10 points (Croissance, VÃ©locitÃ©, DensitÃ©)
     - SÃ©lecteur de couleur d'Ã©quipe
     - Phase de sÃ©lection de planÃ¨te de dÃ©part
     - HUD : compteur spores, tableau des scores
     - Panneau codex au clic sur un astre
     - Pause (mode solo)
     - Machine Ã  Ã©tats : menu â†’ config â†’ spawn â†’ game â†’ end

   v0.3.0 | 2026-02-24 | Ã‰tape 3 â€” Rendu visuel des astres
     - Textures procÃ©durales pour planÃ¨tes (continents, mers, dÃ©serts, gazeuses)
     - Textures cachÃ©es sur canvas hors-Ã©cran (perf)
     - Soleils avec pulsation animÃ©e
     - Trou noir avec disque d'accrÃ©tion rotatif
     - Lunes avec surface cratÃ©risÃ©e
     - Types de planÃ¨tes : rocheuse, gazeuse, glaciale, dÃ©sertique, ocÃ©anique

   v0.2.0 | 2026-02-24 | Ã‰tape 2 â€” GÃ©nÃ©ration de l'univers
     - Trou noir central avec zone de danger
     - Soleils en orbite autour du trou noir (4-20)
     - PlanÃ¨tes en orbite autour des soleils (2-10 par soleil)
     - Lunes en orbite autour des planÃ¨tes (0-3 par planÃ¨te)
     - GÃ©nÃ©rateur de noms procÃ©duraux
     - PropriÃ©tÃ©s : Radius, Flore, Faune
     - Animation continue de toutes les orbites

   v0.1.0 | 2026-02-24 | Ã‰tape 1 â€” Squelette & Canvas
     - Structure HTML/CSS de base (single file)
     - Canvas plein Ã©cran avec fond Ã©toilÃ©
     - Boucle de jeu (requestAnimationFrame + delta time)
     - SystÃ¨me de camÃ©ra : zoom (molette), panoramique (clic droit + drag)
     - Objet gameState centralisÃ©
     - Compteur FPS (debug)
     - GÃ©nÃ©ration d'Ã©toiles de fond (dÃ©cor statique)

   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
   MÃ‰THODE DE TRAVAIL
   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   Ã‰tapes du projet :
     1. âœ… Squelette & Canvas
     2. âœ… GÃ©nÃ©ration de l'univers
     3. âœ… Rendu visuel des astres
     4. âœ… Interface & menus
     5. âœ… MÃ©canique de spores
     6. âœ… ConquÃªte & Ã©conomie
     7. âœ… Intelligence artificielle
     8. âœ… Obstacles & dangers
     9. âœ… Audio gÃ©nÃ©ratif
    10. âœ… Polish & optimisation
    
   Post-v1.0 â€” AmÃ©liorations :
    v1.1  âœ… Polish interface (panneau planÃ¨tes, codex image, zoom x10)
    v1.2  âœ… Symbiose (bonus production +20% planÃ¨tes / +10% lunes)
    v1.3  âœ… Textures & rendu (anneaux gazeuses, atmosphÃ¨re, Ã©clairage, impacts)
    v1.4  âœ… Fond spatial (parallaxe 3 couches, particules, Ã©toiles filantes)
    v1.5  âœ… Interface avancÃ©e (minimap, indicateurs hors-Ã©cran, compteur temps, transitions)
    v1.6  âœ… Audio avancÃ© (ambiance adaptative, sons clic, son orbite, variation pitch)
    v1.7  âœ… Performance (pool objets, cache gradients, batch particules, throttle DOM)
    v1.8  âœ… Polish final (animation titre, Ã©cran chargement, nettoyage, suppression debug)

   â”€â”€ PHASE 2 : MÃ©caniques avancÃ©es â”€â”€
    v1.9  âœ… Fond spatial 5 couches (voiles, nÃ©buleuses, filaments, amas, Ã©toiles)
    v2.0  âœ… Nids & Biomes (production alternative par planÃ¨te, +0.2% prod/dÃ©fense local)
    v2.1  âœ… MultiplicitÃ© (jauge Ã©volution, consomme spores, 10 paliers, +1 stat/palier)
    v2.2  âœ… UX â€” Interface adaptable (zoom UI, scroll astres, clicâ†’codex)
    v2.3  âœ… ComÃ¨tes, dÃ©bris & effets d'impact
    v2.4  âœ… Optimisation performances (LOD, cache offscreen, FPS adaptatif)

   â”€â”€ PHASE 3 : Mise en ligne & multijoueur â”€â”€
    v2.4.1 âœ… Nettoyage debug & config (suppression debug F2-F7, rÃ©glages par dÃ©faut)
    v2.4.2 âœ… Mise en ligne & Auth (GitHub Pages, Supabase, login, pseudo, leaderboard)
    v2.4.3 âœ… Gameplay avancÃ© & UI (astÃ©roÃ¯des, vaisseaux 3 types, journal, panneaux draggables)
    v2.4.5 âœ… Panneaux UI (scale tous panneaux, snap magnÃ©tique, reset positions, 8 panneaux draggables)
    v2.4.6 ğŸ”§ Multijoueur & minification

   Protocole par session :
     1. Uploader le fichier HTML actuel
     2. PrÃ©ciser la fonctionnalitÃ© ou correction souhaitÃ©e
     3. Claude analyse et propose une stratÃ©gie
     4. Modifications en CHERCHE/REMPLACE (â‰¤150 car.)
     5. Appliquer chaque modification par copier-coller
     6. Tester dans le navigateur aprÃ¨s chaque changement
     7. Valider ou signaler un problÃ¨me
     8. ItÃ©rer jusqu'Ã  complÃ©tion

   RÃ¨gles :
     - Jamais de rÃ©Ã©criture en bloc
     - Tester aprÃ¨s chaque CHERCHE/REMPLACE
     - Un problÃ¨me = on corrige avant de continuer
     - Versionnement dÃ©cidÃ© par le dÃ©veloppeur uniquement
     - Backup avant chaque session
   â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GAME STATE â€” Objet central
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const gameState = {
    // â”€â”€ Machine Ã  Ã©tats â”€â”€
    phase: 'title',  // 'title' | 'config' | 'spawn' | 'game' | 'paused' | 'end'

    // â”€â”€ Canvas & rendu â”€â”€
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,

    // â”€â”€ CamÃ©ra â”€â”€
    camera: {
        x: 0,        // position monde (centre de vue)
        y: 0,
        zoom: 1,
        minZoom: 0.05,
        maxZoom: 10,
        zoomSpeed: 0.1
    },

    // â”€â”€ Boucle de jeu â”€â”€
    running: false,
    lastTime: 0,
    deltaTime: 0,

    // â”€â”€ Input â”€â”€
    input: {
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        cameraStartX: 0,
        cameraStartY: 0,
        mouseX: 0,
        mouseY: 0
    },

    // â”€â”€ DÃ©cor (5 couches de profondeur) â”€â”€
    bgVeils: [],          // couche 1 : voiles galactiques (trÃ¨s lent)
    bgNebulae: [],        // couche 2 : nÃ©buleuses denses (lent)
    bgFilaments: [],      // couche 3 : filaments de gaz (moyen)
    bgStarClusters: [],   // couche 4 : amas stellaires (moyen-rapide)
    bgBrightStars: [],    // couche 5 : Ã©toiles brillantes (rapide)
    bgBaseStars: [],      // Ã©toiles simples de fond
    cosmicDust: [],       // particules ambiantes
    shootingStars: [],    // Ã©toiles filantes
    shootingStarTimer: 0,
    comets: [],           // comÃ¨tes destructrices
    cometTimer: 0,
    foregroundDebris: [],  // dÃ©bris premier plan
    time: 0,              // temps total Ã©coulÃ© (pour animations)

    // â”€â”€ Performance â”€â”€
    allBodies: [],         // planets + moons (recalculÃ© Ã  la conquÃªte)
    lod: 2,               // 0=low, 1=mid, 2=high
    lodAutoTimer: 0,       // timer pour FPS adaptatif
    lodFpsAccum: 0,        // accumulateur FPS pour moyenne
    lodFpsSamples: 0,      // nombre d'Ã©chantillons FPS
    bgStarsCache: null,    // canvas offscreen Ã©toiles de base
    bgClustersCache: [],   // canvas offscreen par cluster

    // â”€â”€ FPS â”€â”€
    fps: 0,
    fpsFrames: 0,
    fpsLastCheck: 0,

    // â”€â”€ Univers (prÃ©parÃ© pour Ã©tape 2) â”€â”€
    blackHole: null,
    suns: [],
    planets: [],
    moons: [],

    // â”€â”€ Joueurs (prÃ©parÃ© pour Ã©tape 4) â”€â”€
    players: [],

    // â”€â”€ Jets (prÃ©parÃ© pour Ã©tape 5) â”€â”€
    jets: [],

    // â”€â”€ Vaisseaux nettoyeurs â”€â”€
    cleaners: [],

    // â”€â”€ Amas de mÃ©tÃ©orites â”€â”€
    asteroidBelts: [],

    // â”€â”€ Audio â”€â”€
    audio: {
        ctx: null,
        masterGain: null,
        ambDrone: null,
        volume: 0.4,
        muted: false,
        initialized: false,
        tension: 0,
        tensionTarget: 0,
        orbitHum: null,
        orbitHumGain: null
    },

    // â”€â”€ Config partie â”€â”€
    config: {
        sunCount: 4,
        playerCount: 4,
        difficulty: 'normal',  // 'easy' | 'normal' | 'brutal'
        useIA: true,
        cleanerCount: 3,
        useAsteroids: true
    },

    // â”€â”€ Joueur humain stats â”€â”€
    playerStats: {
        growth: 3,
        velocity: 4,
        density: 3
    },
    playerColor: '#8B5CF6',

    // â”€â”€ Couleurs disponibles â”€â”€
    teamColors: ['#8B5CF6','#EC4899','#EF4444','#F97316','#EAB308','#22C55E','#06B6D4','#3B82F6','#A855F7','#F472B6'],

    // â”€â”€ Codex â”€â”€
    selectedBody: null,
    codexOpen: false,

    // â”€â”€ Effets visuels conquÃªte â”€â”€
    conquestEffects: [],   // {x, y, text, color, age, maxAge}
    bloomEffects: [],      // {body, age, maxAge, color}
    impactEffects: [],     // {x, y, color, particles[], age, maxAge}

    // â”€â”€ Log d'Ã©vÃ©nements â”€â”€
    eventLog: [],

    // â”€â”€ Stats de partie â”€â”€
    gameStats: {
        jetsLaunched: 0,
        jetsNeutralized: 0,
        bodiesConquered: 0,
        sporesProduced: 0,
        timeElapsed: 0
    },

    // â”€â”€ Lancement de jets â”€â”€
    launching: false,
    launchSource: null,
    launchPreview: [],
    mouseWorldX: 0,
    mouseWorldY: 0
};


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CACHE DOM
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const DOM = {};
function cacheDom() {
    DOM.fps = document.getElementById('fps');
    DOM.sporeCount = document.getElementById('sporeCount');
    DOM.scoreBoard = document.getElementById('scoreBoard');
    DOM.gameTimer = document.getElementById('gameTimer');
    DOM.codexName = document.getElementById('codexName');
    DOM.codexType = document.getElementById('codexType');
    DOM.codexRadius = document.getElementById('codexRadius');
    DOM.codexFlore = document.getElementById('codexFlore');
    DOM.codexFaune = document.getElementById('codexFaune');
    DOM.codexOwner = document.getElementById('codexOwner');
    DOM.codexSpores = document.getElementById('codexSpores');
    DOM.codexSymVal = document.getElementById('codexSymVal');
    DOM.codexSymBar = document.getElementById('codexSymBar');
    DOM.codexSymBonus = document.getElementById('codexSymBonus');
    DOM.codexSymbiose = document.getElementById('codexSymbiose');
    DOM.codexPreview = document.getElementById('codexPreview');
    DOM.codex = document.getElementById('codex');
    DOM.myPlanetsList = document.getElementById('myPlanetsList');
    DOM.myPlanets = document.getElementById('myPlanets');
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INITIALISATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function init() {
    // Canvas setup
    gameState.canvas = document.getElementById('gameCanvas');
    gameState.ctx = gameState.canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Cache DOM
    cacheDom();

    // Input listeners
    setupInput();

    // Interface
    setupUI();

    // Cacher le loading
    hideLoading();

    // DÃ©marrer sur l'Ã©cran titre
    setPhase('title');
}

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    gameState.width = window.innerWidth;
    gameState.height = window.innerHeight;
    gameState.canvas.width = gameState.width * dpr;
    gameState.canvas.height = gameState.height * dpr;
    gameState.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FOND SPATIAL (prÃ©-rendu sur canvas hors-Ã©cran)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateBackground() {
    const rng = mulberry32(42);
    const cfg = window._bgCfg || {};
    const spread = cfg.spread || 14000;

    // â•â• COUCHE 0 : Ã‰toiles de base (fond dense) â•â•
    gameState.bgBaseStars = [];
    const starColors = ['200,215,255','255,220,180','180,200,255','255,200,200','220,255,220'];
    const starsCount = cfg.starsCount || 2500;
    const starsPrlxBase = cfg.starsPrlx || 0.25;
    const starsSpread = cfg.starsSpread || 14000;
    for (let i = 0; i < starsCount; i++) {
        gameState.bgBaseStars.push({
            x: (rng() - 0.5) * starsSpread,
            y: (rng() - 0.5) * starsSpread,
            size: rng() * 1.2 + 0.4,
            alpha: rng() * 0.5 + 0.15,
            color: starColors[Math.floor(rng() * starColors.length)],
            parallax: starsPrlxBase + rng() * 0.1
        });
    }

    // â•â• COUCHE 1 : Voiles galactiques (trÃ¨s lents, immenses) â•â•
    gameState.bgVeils = [];
    const veilPals = [
        { c: [15, 25, 70], h: [40, 60, 140] },  // bleu profond
        { c: [50, 15, 60], h: [90, 30, 110] },   // violet
        { c: [20, 40, 55], h: [30, 70, 90] },    // bleu-vert
        { c: [45, 20, 25], h: [80, 35, 45] },    // brun-rouge
    ];
    const veilCount = cfg.veilsCount || 4;
    const veilSizeMin = cfg.veilsSizeMin || 2500;
    const veilSizeVar = cfg.veilsSizeVar || 3000;
    const veilAlphaBase = cfg.veilsAlpha || 0.08;
    for (let i = 0; i < veilCount; i++) {
        const vp = veilPals[i % veilPals.length];
        const vw = veilSizeMin + rng() * veilSizeVar;
        const vh = 600 + rng() * 1200;
        const texW = Math.ceil(vw * 0.5);
        const texH = Math.ceil(vh * 0.5);
        const tc = document.createElement('canvas');
        tc.width = texW; tc.height = texH;
        const tcx = tc.getContext('2d');

        // Gradient linÃ©aire principal (bande allongÃ©e)
        const angle = rng() * Math.PI;
        const cos = Math.cos(angle), sin = Math.sin(angle);
        const gMain = tcx.createLinearGradient(
            texW/2 - cos*texW/2, texH/2 - sin*texH/2,
            texW/2 + cos*texW/2, texH/2 + sin*texH/2
        );
        gMain.addColorStop(0, 'rgba(0,0,0,0)');
        gMain.addColorStop(0.2, `rgba(${vp.c[0]},${vp.c[1]},${vp.c[2]}, ${veilAlphaBase * 0.5})`);
        gMain.addColorStop(0.5, `rgba(${vp.h[0]},${vp.h[1]},${vp.h[2]}, ${veilAlphaBase})`);
        gMain.addColorStop(0.8, `rgba(${vp.c[0]},${vp.c[1]},${vp.c[2]}, ${veilAlphaBase * 0.5})`);
        gMain.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gMain;
        tcx.fillRect(0, 0, texW, texH);

        // Superposer des blobs diffus pour rendre irrÃ©gulier
        for (let b = 0; b < 12; b++) {
            const bx = rng() * texW;
            const by = rng() * texH;
            const br = texH * (0.3 + rng() * 0.5);
            const gB = tcx.createRadialGradient(bx, by, 0, bx, by, br);
            gB.addColorStop(0, `rgba(${vp.h[0]},${vp.h[1]},${vp.h[2]}, ${0.03 + rng()*0.05})`);
            gB.addColorStop(0.6, `rgba(${vp.c[0]},${vp.c[1]},${vp.c[2]}, 0.02)`);
            gB.addColorStop(1, 'rgba(0,0,0,0)');
            tcx.fillStyle = gB;
            tcx.beginPath();
            tcx.arc(bx, by, br, 0, Math.PI * 2);
            tcx.fill();
        }

        // Fade radial pour adoucir les bords
        const gFade = tcx.createRadialGradient(texW/2, texH/2, 0, texW/2, texH/2, texW/2);
        gFade.addColorStop(0, 'rgba(0,0,0,0)');
        gFade.addColorStop(0.7, 'rgba(0,0,0,0)');
        gFade.addColorStop(1, `rgba(${14},${27},${61}, 1)`);
        tcx.fillStyle = gFade;
        tcx.fillRect(0, 0, texW, texH);

        const veilSpread = cfg.veilsSpread || 10000;
        const veilPrlx = cfg.veilsPrlx || 0.10;
        gameState.bgVeils.push({
            x: (rng() - 0.5) * veilSpread,
            y: (rng() - 0.5) * veilSpread,
            w: vw, h: vh,
            texture: tc,
            rotation: rng() * Math.PI * 2,
            rotSpeed: (rng() - 0.5) * 0.0005,
            vx: (rng() - 0.5) * 0.5,
            vy: (rng() - 0.5) * 0.5,
            parallax: veilPrlx + rng() * 0.08
        });
    }

    // â•â• COUCHE 2 : NÃ©buleuses denses irrÃ©guliÃ¨res â•â•
    gameState.bgNebulae = [];
    const nebPals = [
        { c1: [60, 20, 100], c2: [130, 50, 180], rim: [180, 100, 255] },  // violet
        { c1: [15, 50, 90],  c2: [30, 100, 160], rim: [80, 180, 255] },   // bleu
        { c1: [90, 25, 40],  c2: [160, 50, 60],  rim: [255, 120, 100] },  // rouge
        { c1: [20, 70, 65],  c2: [40, 140, 120], rim: [80, 255, 220] },   // turquoise
        { c1: [80, 50, 15],  c2: [150, 90, 30],  rim: [255, 180, 60] },   // dorÃ©
        { c1: [70, 20, 70],  c2: [120, 40, 100], rim: [200, 100, 180] },  // magenta
        { c1: [15, 40, 80],  c2: [30, 80, 130],  rim: [60, 160, 220] },   // bleu acier
        { c1: [50, 60, 20],  c2: [90, 110, 40],  rim: [160, 200, 80] },   // vert nÃ©buleux
    ];

    const nebCount = cfg.nebCount || 10;
    const nebRadMin = cfg.nebRadMin || 400;
    const nebRadVar = cfg.nebRadVar || 700;
    const nebAlpha = cfg.nebAlpha || 0.10;
    const nebBlobCount = cfg.nebBlobs || 8;
    const nebSoft = cfg.nebSoft || 0.60;
    const nebStretch = cfg.nebStretch || 1.0;
    for (let n = 0; n < nebCount; n++) {
        const pal = nebPals[n % nebPals.length];
        const nebR = nebRadMin + rng() * nebRadVar;
        const stretchX = 1.0 + (rng() * (nebStretch - 1.0));
        const stretchY = 1.0 + (rng() * (nebStretch - 1.0));
        const texW = Math.ceil(nebR * 2.8 * Math.max(stretchX, 1));
        const texH = Math.ceil(nebR * 2.8 * Math.max(stretchY, 1));
        const tc = document.createElement('canvas');
        tc.width = texW; tc.height = texH;
        const tcx = tc.getContext('2d');
        const halfW = texW / 2;
        const halfH = texH / 2;

        // Ã‰tirer le contexte pour allongement
        tcx.save();
        tcx.translate(halfW, halfH);
        tcx.scale(stretchX, 1.0 / stretchX);
        tcx.translate(-halfW, -halfH);

        const half = Math.min(halfW, halfH);

        // Forme irrÃ©guliÃ¨re : blobs dÃ©centrÃ©s superposÃ©s
        const blobCount = nebBlobCount + Math.floor(rng() * 7);
        const alpha = nebAlpha + rng() * 0.12;
        for (let b = 0; b < blobCount; b++) {
            const bx = half + (rng() - 0.5) * half * 1.1;
            const by = half + (rng() - 0.5) * half * 1.1;
            const br = half * (0.2 + rng() * 0.45);
            const gB = tcx.createRadialGradient(bx, by, 0, bx, by, br);
            const mix = rng();
            const r = Math.round(pal.c1[0] * (1-mix) + pal.c2[0] * mix);
            const g = Math.round(pal.c1[1] * (1-mix) + pal.c2[1] * mix);
            const bv = Math.round(pal.c1[2] * (1-mix) + pal.c2[2] * mix);
            gB.addColorStop(0, `rgba(${r},${g},${bv}, ${alpha + 0.08})`);
            gB.addColorStop(0.3, `rgba(${r},${g},${bv}, ${alpha})`);
            gB.addColorStop(0.7, `rgba(${pal.c1[0]},${pal.c1[1]},${pal.c1[2]}, ${alpha * 0.3})`);
            gB.addColorStop(1, 'rgba(0,0,0,0)');
            tcx.fillStyle = gB;
            tcx.beginPath();
            tcx.arc(bx, by, br, 0, Math.PI * 2);
            tcx.fill();
        }

        // Rim lighting (bord lumineux d'un cÃ´tÃ©)
        const rimAngle = rng() * Math.PI * 2;
        const rimX = half + Math.cos(rimAngle) * half * 0.4;
        const rimY = half + Math.sin(rimAngle) * half * 0.4;
        const gRim = tcx.createRadialGradient(rimX, rimY, half * 0.3, rimX, rimY, half * 0.9);
        gRim.addColorStop(0, `rgba(${pal.rim[0]},${pal.rim[1]},${pal.rim[2]}, 0.12)`);
        gRim.addColorStop(0.4, `rgba(${pal.rim[0]},${pal.rim[1]},${pal.rim[2]}, 0.04)`);
        gRim.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gRim;
        tcx.beginPath();
        tcx.arc(half, half, half * 0.9, 0, Math.PI * 2);
        tcx.fill();

        // CÅ“ur lumineux
        const gCore = tcx.createRadialGradient(half, half, 0, half, half, half * 0.25);
        gCore.addColorStop(0, `rgba(${pal.rim[0]},${pal.rim[1]},${pal.rim[2]}, 0.15)`);
        gCore.addColorStop(0.5, `rgba(${pal.c2[0]},${pal.c2[1]},${pal.c2[2]}, 0.06)`);
        gCore.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gCore;
        tcx.beginPath();
        tcx.arc(half, half, half * 0.25, 0, Math.PI * 2);
        tcx.fill();

        // Micro-Ã©toiles internes
        for (let s = 0; s < 30; s++) {
            const sx = half + (rng() - 0.5) * half * 1.4;
            const sy = half + (rng() - 0.5) * half * 1.4;
            const ss = rng() * 2 + 0.5;
            tcx.fillStyle = `rgba(${pal.rim[0]},${pal.rim[1]},${pal.rim[2]}, ${rng()*0.3+0.1})`;
            tcx.beginPath();
            tcx.arc(sx, sy, ss, 0, Math.PI * 2);
            tcx.fill();
        }

        tcx.restore(); // fin du scale/stretch

        // Fade doux des bords (softness contrÃ´le la zone de fondu)
        tcx.globalCompositeOperation = 'destination-in';
        const gFade = tcx.createRadialGradient(halfW, halfH, 0, halfW, halfH, Math.max(halfW, halfH));
        gFade.addColorStop(0, 'rgba(0,0,0,1)');
        gFade.addColorStop(nebSoft, 'rgba(0,0,0,1)');
        gFade.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gFade;
        tcx.fillRect(0, 0, texW, texH);
        tcx.globalCompositeOperation = 'source-over';

        const nebSpread2 = cfg.nebSpread || 12000;
        const nebPrlxBase = cfg.nebPrlx || 0.20;
        gameState.bgNebulae.push({
            x: (rng() - 0.5) * nebSpread2,
            y: (rng() - 0.5) * nebSpread2,
            radius: nebR,
            texture: tc,
            rotation: rng() * Math.PI * 2,
            rotSpeed: (rng() - 0.5) * 0.002,
            vx: (rng() - 0.5) * 1.5,
            vy: (rng() - 0.5) * 1.5,
            parallax: nebPrlxBase + rng() * 0.1
        });
    }

    // â•â• COUCHE 3 : Filaments de gaz (traÃ®nÃ©es longues) â•â•
    gameState.bgFilaments = [];
    const filColors = [
        [60, 80, 160], [120, 50, 100], [40, 100, 100],
        [100, 70, 40], [80, 40, 120], [50, 90, 70]
    ];
    const filCount = cfg.filCount || 8;
    const filLenMin = cfg.filLenMin || 800;
    const filThick = cfg.filThick || 40;
    const filPrlxBase = cfg.filPrlx || 0.35;
    for (let i = 0; i < filCount; i++) {
        const fc = filColors[i % filColors.length];
        const fw = filLenMin + rng() * 1500;
        const fh = filThick + rng() * 30;
        const tc = document.createElement('canvas');
        tc.width = Math.ceil(fw * 0.3); tc.height = Math.ceil(fh * 3);
        const tcx = tc.getContext('2d');
        // Gradient horizontal (longueur)
        const gF = tcx.createLinearGradient(0, 0, tc.width, 0);
        gF.addColorStop(0, 'rgba(0,0,0,0)');
        gF.addColorStop(0.15, `rgba(${fc[0]},${fc[1]},${fc[2]}, 0.04)`);
        gF.addColorStop(0.5, `rgba(${fc[0]+30},${fc[1]+20},${fc[2]+30}, 0.08)`);
        gF.addColorStop(0.85, `rgba(${fc[0]},${fc[1]},${fc[2]}, 0.04)`);
        gF.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gF;
        tcx.fillRect(0, 0, tc.width, tc.height);
        // Fade vertical TRANSPARENT (plus de fond opaque)
        tcx.globalCompositeOperation = 'destination-in';
        const gV = tcx.createLinearGradient(0, 0, 0, tc.height);
        gV.addColorStop(0, 'rgba(0,0,0,0)');
        gV.addColorStop(0.25, 'rgba(0,0,0,1)');
        gV.addColorStop(0.75, 'rgba(0,0,0,1)');
        gV.addColorStop(1, 'rgba(0,0,0,0)');
        tcx.fillStyle = gV;
        tcx.fillRect(0, 0, tc.width, tc.height);
        tcx.globalCompositeOperation = 'source-over';

        const filSpread2 = cfg.filSpread || spread;
        gameState.bgFilaments.push({
            x: (rng() - 0.5) * filSpread2,
            y: (rng() - 0.5) * filSpread2,
            w: fw, h: fh * 3,
            texture: tc,
            rotation: rng() * Math.PI * 2,
            vx: (rng() - 0.5) * 2,
            vy: (rng() - 0.5) * 2,
            parallax: filPrlxBase + rng() * 0.1
        });
    }

    // â•â• COUCHE 4 : Amas stellaires (groupes denses d'Ã©toiles) â•â•
    gameState.bgStarClusters = [];
    const clusCount = cfg.clusCount || 12;
    const clusRadBase = cfg.clusRad || 150;
    const clusPrlxBase = cfg.clusPrlx || 0.50;
    for (let i = 0; i < clusCount; i++) {
        const clusSpread2 = cfg.clusSpread || spread;
        const cx2 = (rng() - 0.5) * clusSpread2;
        const cy = (rng() - 0.5) * clusSpread2;
        const clusterR = clusRadBase + rng() * 150;
        const count = 30 + Math.floor(rng() * 50);
        const clusterStars = [];
        const cc = starColors[Math.floor(rng() * starColors.length)];
        for (let s = 0; s < count; s++) {
            // Distribution gaussienne (somme de randoms)
            const gx = ((rng()+rng()+rng())/3 - 0.5) * 2;
            const gy = ((rng()+rng()+rng())/3 - 0.5) * 2;
            clusterStars.push({
                ox: gx * clusterR,
                oy: gy * clusterR,
                size: rng() * 1.2 + 0.3,
                alpha: rng() * 0.5 + 0.2,
                color: rng() > 0.3 ? cc : starColors[Math.floor(rng() * starColors.length)]
            });
        }
        gameState.bgStarClusters.push({
            x: cx2, y: cy,
            stars: clusterStars,
            parallax: clusPrlxBase + rng() * 0.15,
            vx: (rng() - 0.5) * 1,
            vy: (rng() - 0.5) * 1
        });
    }

    // â•â• COUCHE 5 : Ã‰toiles brillantes premier plan â•â•
    gameState.bgBrightStars = [];
    const brightColors = ['220,230,255','255,200,150','180,200,255','255,180,180','200,255,220'];
    const brightCount = cfg.brightCount || 25;
    const brightSizeBase = cfg.brightSize || 2.0;
    const brightPrlxBase = cfg.brightPrlx || 0.65;
    const brightSpread2 = cfg.brightSpread || spread;
    for (let i = 0; i < brightCount; i++) {
        gameState.bgBrightStars.push({
            x: (rng() - 0.5) * brightSpread2,
            y: (rng() - 0.5) * brightSpread2,
            size: rng() * brightSizeBase + 1.5,
            alpha: rng() * 0.4 + 0.4,
            color: brightColors[Math.floor(rng() * brightColors.length)],
            parallax: brightPrlxBase + rng() * 0.15,
            hasDiffraction: rng() > 0.3,
            phase: rng() * Math.PI * 2
        });
    }

    // â•â• Particules ambiantes (poussiÃ¨re cosmique) â•â•
    gameState.cosmicDust = [];
    const rng4 = mulberry32(55);
    for (let i = 0; i < 40; i++) {
        gameState.cosmicDust.push({
            x: (rng4() - 0.5) * 15000,
            y: (rng4() - 0.5) * 15000,
            vx: (rng4() - 0.5) * 3,
            vy: (rng4() - 0.5) * 3,
            size: rng4() * 2 + 0.5,
            alpha: rng4() * 0.12 + 0.03,
            phase: rng4() * Math.PI * 2
        });
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE â€” Caches offscreen (Ã©toiles, clusters, halos)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function buildBgStarsCache() {
    const stars = gameState.bgBaseStars;
    if (stars.length === 0) return;
    // Calcul des bornes
    let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
    for (const s of stars) {
        if (s.x < minX) minX = s.x;
        if (s.x > maxX) maxX = s.x;
        if (s.y < minY) minY = s.y;
        if (s.y > maxY) maxY = s.y;
    }
    const pad = 10;
    const w = Math.ceil(maxX - minX + pad * 2);
    const h = Math.ceil(maxY - minY + pad * 2);
    // Limiter taille max canvas (mÃ©moire GPU)
    const maxDim = 4096;
    const scale = Math.min(1, maxDim / Math.max(w, h));
    const cw = Math.ceil(w * scale);
    const ch = Math.ceil(h * scale);
    const c = document.createElement('canvas');
    c.width = cw; c.height = ch;
    const ctx = c.getContext('2d');
    for (const s of stars) {
        const sx = (s.x - minX + pad) * scale;
        const sy = (s.y - minY + pad) * scale;
        ctx.fillStyle = `rgba(${s.color}, ${s.alpha})`;
        ctx.beginPath();
        ctx.arc(sx, sy, Math.max(s.size * scale, 0.5), 0, Math.PI * 2);
        ctx.fill();
    }
    // Parallaxe moyenne du groupe
    let pSum = 0;
    for (const s of stars) pSum += s.parallax;
    gameState.bgStarsCache = {
        canvas: c, offX: minX - pad, offY: minY - pad,
        w: w, h: h, scale: scale,
        parallax: pSum / stars.length
    };
}

function buildBgClustersCache() {
    gameState.bgClustersCache = [];
    for (const cl of gameState.bgStarClusters) {
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
        for (const s of cl.stars) {
            if (s.ox < minX) minX = s.ox;
            if (s.ox > maxX) maxX = s.ox;
            if (s.oy < minY) minY = s.oy;
            if (s.oy > maxY) maxY = s.oy;
        }
        const pad = 10;
        const w = Math.ceil(maxX - minX + pad * 2);
        const h = Math.ceil(maxY - minY + pad * 2);
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        for (const s of cl.stars) {
            ctx.fillStyle = `rgba(${s.color}, ${s.alpha})`;
            ctx.beginPath();
            ctx.arc(s.ox - minX + pad, s.oy - minY + pad, s.size, 0, Math.PI * 2);
            ctx.fill();
        }
        gameState.bgClustersCache.push({
            canvas: c, offX: minX - pad, offY: minY - pad, w: w, h: h
        });
    }
}

function buildBrightStarsCache() {
    for (const s of gameState.bgBrightStars) {
        const r = s.size * 5;
        const dim = Math.ceil(r * 2 + 4);
        const c = document.createElement('canvas');
        c.width = dim; c.height = dim;
        const ctx = c.getContext('2d');
        const cx = dim / 2, cy = dim / 2;
        const gh = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        gh.addColorStop(0, `rgba(${s.color}, 0.35)`);
        gh.addColorStop(0.5, `rgba(${s.color}, 0.08)`);
        gh.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gh;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        s._haloCache = c;
    }
}

function buildSunHaloCache() {
    for (const sun of gameState.suns) {
        const haloR = sun.radius * 3;
        const dim = Math.ceil(haloR * 2 + 4);
        const c = document.createElement('canvas');
        c.width = dim; c.height = dim;
        const ctx = c.getContext('2d');
        const cx = dim / 2, cy = dim / 2;
        const g = ctx.createRadialGradient(cx, cy, sun.radius * 0.3, cx, cy, haloR);
        g.addColorStop(0, sun.color + '50');
        g.addColorStop(0.5, sun.color + '15');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, haloR, 0, Math.PI * 2);
        ctx.fill();
        sun._haloCache = c;
        sun._haloDim = dim;
        sun._haloR = haloR;
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TEXTURES PROCÃ‰DURALES (canvas hors-Ã©cran)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function createPlanetTexture(planet) {
    const size = Math.max(Math.floor(planet.radius * 2 * 3), 16);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    // Type de planÃ¨te basÃ© sur le nom (seed dÃ©terministe)
    const seed = planet.name.charCodeAt(0) + planet.name.charCodeAt(1) * 7;
    const types = ['rocky','ocean','desert','gas','ice'];
    planet.planetType = types[seed % types.length];

    const palettes = {
        rocky:  { base: '#8B7355', c1: '#6B5B45', c2: '#A09070', sea: null },
        ocean:  { base: '#2266AA', c1: '#1B5090', c2: '#33AACC', sea: '#1A4477' },
        desert: { base: '#C4A35A', c1: '#B8943F', c2: '#D4B870', sea: null },
        gas:    { base: '#C9956B', c1: '#B07850', c2: '#DDB88A', sea: null },
        ice:    { base: '#A0C4D8', c1: '#88B0CC', c2: '#C8E0F0', sea: '#7099B8' }
    };
    const pal = palettes[planet.planetType];

    // Fond circulaire
    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Base
    cx.fillStyle = pal.base;
    cx.fillRect(0, 0, size, size);

    // Bruit pseudo-alÃ©atoire pour les continents/bandes
    const rng = mulberry32(seed);

    if (planet.planetType === 'gas') {
        // Bandes horizontales pour gazeuses
        for (let y = 0; y < size; y += 3) {
            const intensity = Math.sin(y * 0.3 + rng() * 6) * 0.3;
            cx.fillStyle = intensity > 0 ? pal.c2 + '80' : pal.c1 + '60';
            cx.fillRect(0, y, size, 2);
        }
    } else {
        // Continents / taches
        const patches = 4 + Math.floor(rng() * 6);
        for (let i = 0; i < patches; i++) {
            const px = rng() * size;
            const py = rng() * size;
            const pr = rng() * r * 0.6 + r * 0.15;
            const g = cx.createRadialGradient(px, py, 0, px, py, pr);
            g.addColorStop(0, pal.c1 + 'AA');
            g.addColorStop(0.6, pal.c2 + '66');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            cx.fillStyle = g;
            cx.beginPath();
            cx.arc(px, py, pr, 0, Math.PI * 2);
            cx.fill();
        }

        // Mers si applicable
        if (pal.sea) {
            const seaPatches = 2 + Math.floor(rng() * 3);
            for (let i = 0; i < seaPatches; i++) {
                const sx = rng() * size;
                const sy = rng() * size;
                const sr = rng() * r * 0.5 + r * 0.1;
                const g = cx.createRadialGradient(sx, sy, 0, sx, sy, sr);
                g.addColorStop(0, pal.sea + 'BB');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                cx.fillStyle = g;
                cx.beginPath();
                cx.arc(sx, sy, sr, 0, Math.PI * 2);
                cx.fill();
            }
        }
    }

    // Ombre sphÃ©rique (Ã©clairage)
    const gShade = cx.createRadialGradient(half * 0.7, half * 0.7, 0, half, half, r);
    gShade.addColorStop(0, 'rgba(255,255,255,0.15)');
    gShade.addColorStop(0.5, 'rgba(0,0,0,0)');
    gShade.addColorStop(1, 'rgba(0,0,0,0.4)');
    cx.fillStyle = gShade;
    cx.fillRect(0, 0, size, size);

    // AtmosphÃ¨re (pour ocean, ice, gas)
    const atmoColors = {
        ocean: 'rgba(60, 140, 255, 0.12)',
        ice: 'rgba(150, 210, 255, 0.10)',
        gas: 'rgba(200, 160, 100, 0.08)',
        rocky: null,
        desert: null
    };
    const atmoCol = atmoColors[planet.planetType];
    if (atmoCol) {
        planet._hasAtmosphere = true;
        planet._atmoColor = atmoCol;
    }

    // Anneaux pour gazeuses
    if (planet.planetType === 'gas') {
        planet._hasRings = true;
        planet._ringColor1 = pal.c2 + '40';
        planet._ringColor2 = pal.c1 + '20';
        planet._ringTilt = 0.3 + rng() * 0.4;
    }

    planet._texture = c;
}

function createMoonTexture(moon) {
    const size = Math.max(Math.floor(moon.radius * 2 * 3), 10);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Type de lune (seed dÃ©terministe)
    const seed = moon.name.charCodeAt(0) + moon.name.charCodeAt(1) * 3;
    const rng = mulberry32(seed);
    const moonTypes = ['rock', 'ice', 'dark', 'volcanic'];
    moon.moonType = moonTypes[seed % moonTypes.length];

    const moonPalettes = {
        rock:     { base: '#9A9AAA', crater: 'rgba(60,60,70,0.5)', highlight: 'rgba(255,255,255,0.12)' },
        ice:      { base: '#B8D8E8', crater: 'rgba(80,100,120,0.4)', highlight: 'rgba(200,230,255,0.18)' },
        dark:     { base: '#4A4A55', crater: 'rgba(20,20,30,0.6)', highlight: 'rgba(180,180,200,0.08)' },
        volcanic: { base: '#6A4A3A', crater: 'rgba(200,60,20,0.5)', highlight: 'rgba(255,120,40,0.15)' }
    };
    const mp = moonPalettes[moon.moonType];

    // Base
    cx.fillStyle = mp.base;
    cx.fillRect(0, 0, size, size);

    // Variation de surface
    for (let i = 0; i < 3; i++) {
        const vx = rng() * size;
        const vy = rng() * size;
        const vr = rng() * r * 0.5 + r * 0.2;
        const g = cx.createRadialGradient(vx, vy, 0, vx, vy, vr);
        g.addColorStop(0, mp.base + '80');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = g;
        cx.beginPath();
        cx.arc(vx, vy, vr, 0, Math.PI * 2);
        cx.fill();
    }

    // CratÃ¨res
    const craters = 3 + Math.floor(rng() * 5);
    for (let i = 0; i < craters; i++) {
        const cx2 = rng() * size;
        const cy2 = rng() * size;
        const cr = rng() * r * 0.3 + 1;
        const g = cx.createRadialGradient(cx2, cy2, 0, cx2, cy2, cr);
        g.addColorStop(0, mp.crater);
        g.addColorStop(0.7, mp.crater);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = g;
        cx.beginPath();
        cx.arc(cx2, cy2, cr, 0, Math.PI * 2);
        cx.fill();

        // LiserÃ© de cratÃ¨re (rebord lumineux)
        cx.strokeStyle = mp.highlight;
        cx.lineWidth = 0.5;
        cx.beginPath();
        cx.arc(cx2, cy2, cr, 0, Math.PI * 2);
        cx.stroke();
    }

    // Points lumineux volcaniques
    if (moon.moonType === 'volcanic') {
        for (let i = 0; i < 4; i++) {
            const lx = rng() * size;
            const ly = rng() * size;
            const lr = rng() * 2 + 0.5;
            const g = cx.createRadialGradient(lx, ly, 0, lx, ly, lr * 2);
            g.addColorStop(0, 'rgba(255, 80, 20, 0.6)');
            g.addColorStop(0.5, 'rgba(255, 40, 0, 0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            cx.fillStyle = g;
            cx.beginPath();
            cx.arc(lx, ly, lr * 2, 0, Math.PI * 2);
            cx.fill();
        }
    }

    // Reflets glacÃ©s
    if (moon.moonType === 'ice') {
        for (let i = 0; i < 3; i++) {
            const lx = rng() * size;
            const ly = rng() * size;
            const lr = rng() * r * 0.15 + 1;
            cx.fillStyle = 'rgba(220, 240, 255, 0.15)';
            cx.beginPath();
            cx.arc(lx, ly, lr, 0, Math.PI * 2);
            cx.fill();
        }
    }

    // Ombre sphÃ©rique
    const gShade = cx.createRadialGradient(half * 0.7, half * 0.7, 0, half, half, r);
    gShade.addColorStop(0, mp.highlight);
    gShade.addColorStop(0.5, 'rgba(0,0,0,0)');
    gShade.addColorStop(1, 'rgba(0,0,0,0.35)');
    cx.fillStyle = gShade;
    cx.fillRect(0, 0, size, size);

    moon._texture = c;
}

function createSunTexture(sun) {
    const size = Math.floor(sun.radius * 2 * 3);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Gradient de base
    const g = cx.createRadialGradient(half * 0.8, half * 0.8, 0, half, half, r);
    g.addColorStop(0, '#FFFFFF');
    g.addColorStop(0.2, sun.color);
    g.addColorStop(1, sun.color + '88');
    cx.fillStyle = g;
    cx.fillRect(0, 0, size, size);

    // Taches solaires
    const seed = sun.name.charCodeAt(0) * 13;
    const rng = mulberry32(seed);
    for (let i = 0; i < 3; i++) {
        const sx = half + (rng() - 0.5) * r;
        const sy = half + (rng() - 0.5) * r;
        const sr = rng() * r * 0.2 + 2;
        const gs = cx.createRadialGradient(sx, sy, 0, sx, sy, sr);
        gs.addColorStop(0, 'rgba(0,0,0,0.15)');
        gs.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = gs;
        cx.beginPath();
        cx.arc(sx, sy, sr, 0, Math.PI * 2);
        cx.fill();
    }

    sun._texture = c;
}

// PRNG dÃ©terministe (mulberry32)
function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        var t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GÃ‰NÃ‰RATEUR DE NOMS PROCÃ‰DURAUX
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateName() {
    const prefixes = ['Zan','Kry','Vel','Xor','Neb','Thal','Aur','Pyx','Cel','Dra','Ith','Vor','Syn','Pal','Eri','Omi','Zet','Sig','Cor','Lyr'];
    const mids = ['a','o','u','i','e','an','on','ar','el','is','ax','um','al','en','os','ir'];
    const suffixes = ['th','ra','nis','xis','ton','ria','mus','pha','dis','lux','vyn','don','zar','mir','bus','tis'];
    return prefixes[Math.floor(Math.random()*prefixes.length)]
        + mids[Math.floor(Math.random()*mids.length)]
        + suffixes[Math.floor(Math.random()*suffixes.length)];
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// GÃ‰NÃ‰RATION DE L'UNIVERS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateUniverse() {
    const cfg = gameState.config;
    const sunCount = cfg.sunCount;

    // â”€â”€ Trou noir central â”€â”€
    gameState.blackHole = {
        x: 0, y: 0,
        radius: 300,
        dangerZone: 300,
        gravityRange: 1500,
        gravityStrength: 1260
    };

    // â”€â”€ Soleils â”€â”€
    gameState.suns = [];
    gameState.planets = [];
    gameState.moons = [];

    const baseOrbitRadius = 800;
    const orbitSpacing = 750;

    for (let s = 0; s < sunCount; s++) {
        const angle = Math.random() * Math.PI * 2;
        const orbitR = baseOrbitRadius + s * orbitSpacing + (Math.random() - 0.5) * 200;
        const speed = (0.02 + Math.random() * 0.015) / (1 + s * 0.15);

        const sun = {
            type: 'sun',
            name: generateName(),
            radius: 25 + Math.random() * 20,
            orbitRadius: orbitR,
            orbitSpeed: speed,
            angle: angle,
            x: 0, y: 0,
            color: ['#FFE44D','#FFB830','#FF8C42','#FF6B6B','#7CB9FF'][Math.floor(Math.random()*5)],
            planets: []
        };

        // Position initiale
        sun.x = Math.cos(sun.angle) * sun.orbitRadius;
        sun.y = Math.sin(sun.angle) * sun.orbitRadius;

        // â”€â”€ PlanÃ¨tes pour ce soleil â”€â”€
        const planetCount = 2 + Math.floor(Math.random() * 9); // 2-10
        const pBaseOrbit = sun.radius * 2.5 + 30;
        const pSpacing = 35 + Math.random() * 25;

        for (let p = 0; p < planetCount; p++) {
            const pOrbitR = pBaseOrbit + p * pSpacing + Math.random() * 20;
            const pSpeed = (0.08 + Math.random() * 0.06) / (1 + p * 0.2);
            const pAngle = Math.random() * Math.PI * 2;
            const pRadius = 5 + Math.random() * 12;

            const planet = {
                type: 'planet',
                name: generateName(),
                radius: pRadius,
                flore: Math.floor(Math.random() * 101),
                faune: Math.floor(Math.random() * 101),
                _baseFaune: 0,
                symbiosis: 0,
                symOwnerTime: 0,
                buildMode: 'off',
                buildProgress: 0,
                nids: 0,
                biomes: 0,
                orbitRadius: pOrbitR,
                orbitSpeed: pSpeed,
                angle: pAngle,
                parent: sun,
                x: 0, y: 0,
                owner: null,
                spores: 0,
                maxSpores: Math.floor(pRadius * 50),
                moons: []
            };

            planet._baseFaune = planet.faune;
            planet.x = sun.x + Math.cos(planet.angle) * planet.orbitRadius;
            planet.y = sun.y + Math.sin(planet.angle) * planet.orbitRadius;

            // â”€â”€ Lunes (0-3, pas pour toutes) â”€â”€
            const hasMoons = Math.random() > 0.4;
            if (hasMoons) {
                const moonCount = 1 + Math.floor(Math.random() * 3);
                for (let m = 0; m < moonCount; m++) {
                    const mOrbitR = planet.radius * 2 + 8 + m * 12 + Math.random() * 5;
                    const mSpeed = 0.15 + Math.random() * 0.2;
                    const mRadius = 2 + Math.random() * 4;

                    const moon = {
                        type: 'moon',
                        name: generateName(),
                        radius: mRadius,
                        flore: Math.floor(Math.random() * 51),
                        faune: Math.floor(Math.random() * 61),
                        symbiosis: 0,
                        symOwnerTime: 0,
                        buildMode: 'off',
                        buildProgress: 0,
                        nids: 0,
                        biomes: 0,
                        orbitRadius: mOrbitR,
                        orbitSpeed: mSpeed,
                        angle: Math.random() * Math.PI * 2,
                        parent: planet,
                        x: 0, y: 0,
                        owner: null,
                        spores: 0,
                        maxSpores: Math.floor(mRadius * 50)
                    };

                    moon.x = planet.x + Math.cos(moon.angle) * moon.orbitRadius;
                    moon.y = planet.y + Math.sin(moon.angle) * moon.orbitRadius;

                    planet.moons.push(moon);
                    gameState.moons.push(moon);
                }
            }

            sun.planets.push(planet);
            gameState.planets.push(planet);
        }

        gameState.suns.push(sun);
    }

    // â”€â”€ Vaisseaux nettoyeurs â”€â”€
    gameState.cleaners = [];
    const cleanerCount = gameState.config.cleanerCount || 3;

    const clTypes = ['red', 'green', 'dark'];
    for (let c = 0; c < cleanerCount; c++) {
        const angle = (c / cleanerCount) * Math.PI * 2 + Math.random() * 0.5;
        const dist = 400 + Math.random() * 2000;
        gameState.cleaners.push({
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            angle: angle,
            turnTimer: 0,
            turnInterval: 4 + Math.random() * 6,
            detectionRange: 200,
            fireRate: 1.5,
            fireTimer: 0,
            size: 8,
            type: clTypes[c % 3]
        });
    }

    // â”€â”€ Amas de mÃ©tÃ©orites â”€â”€
    gameState.asteroidBelts = [];
    if (gameState.config.useAsteroids) {
        const beltTypes = ['dark', 'red', 'green'];
        for (const sun of gameState.suns) {
            const lastPlanet = sun.planets[sun.planets.length - 1];
            const beltRadius = lastPlanet ? lastPlanet.orbitRadius + 150 + Math.random() * 80 : sun.radius * 6 + 120;
            const asteroidCount = 4 + Math.floor(Math.random() * 7);
            const rocks = [];
            for (let a = 0; a < asteroidCount; a++) {
                const rockType = beltTypes[Math.floor(Math.random() * 3)];
                const aAngle = (a / asteroidCount) * Math.PI * 2 + (Math.random() - 0.5) * 0.4;
                const rOff = (Math.random() - 0.5) * 25;
                const rockCount = 3 + Math.floor(Math.random() * 4);
                const subRocks = [];
                for (let r = 0; r < rockCount; r++) {
                    // Base gris/marron/noir
                    const baseR = 50 + Math.floor(Math.random() * 50);
                    const baseG = 40 + Math.floor(Math.random() * 40);
                    const baseB = 35 + Math.floor(Math.random() * 35);
                    // Touche de couleur selon le type (1 rocher sur 3)
                    let cr = baseR, cg = baseG, cb = baseB;
                    if (r % 3 === 0) {
                        if (rockType === 'dark') { cr -= 15; cg -= 15; cb -= 10; }
                        else if (rockType === 'red') { cr += 60; cg -= 10; cb -= 10; }
                        else { cr -= 10; cg += 50; cb -= 10; }
                    }
                    subRocks.push({
                        offX: (Math.random() - 0.5) * 16,
                        offY: (Math.random() - 0.5) * 16,
                        size: 2 + Math.random() * 4,
                        color: `rgb(${Math.max(0,cr)},${Math.max(0,cg)},${Math.max(0,cb)})`
                    });
                }
                rocks.push({
                    angle: aAngle,
                    radiusOff: rOff,
                    subRocks: subRocks,
                    type: rockType
                });
            }
            gameState.asteroidBelts.push({
                sun: sun,
                radius: beltRadius,
                orbitSpeed: 0.008 + Math.random() * 0.006,
                rocks: rocks
            });
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE â€” allBodies cache
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function rebuildAllBodies() {
    gameState.allBodies = gameState.planets.concat(gameState.moons);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PERFORMANCE â€” LOD dynamique + FPS adaptatif
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateLOD(dt) {
    const z = gameState.camera.zoom;
    let zoomLod = 2;
    if (z < 0.35) zoomLod = 0;
    else if (z < 0.6) zoomLod = 1;

    gameState.lodFpsAccum += gameState.fps;
    gameState.lodFpsSamples++;
    gameState.lodAutoTimer += dt;
    let fpsLod = 2;
    if (gameState.lodAutoTimer >= 1.5 && gameState.lodFpsSamples > 0) {
        const avgFps = gameState.lodFpsAccum / gameState.lodFpsSamples;
        if (avgFps < 25) fpsLod = 0;
        else if (avgFps < 40) fpsLod = 1;
        gameState.lodAutoTimer = 0;
        gameState.lodFpsAccum = 0;
        gameState.lodFpsSamples = 0;
    } else {
        fpsLod = gameState.lod;
    }

    gameState.lod = Math.min(zoomLod, fpsLod);
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATE â€” Orbites
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateOrbits(dt) {
    // Soleils autour du trou noir
    for (let i = 0; i < gameState.suns.length; i++) {
        const sun = gameState.suns[i];
        sun.angle += sun.orbitSpeed * dt;
        sun.x = Math.cos(sun.angle) * sun.orbitRadius;
        sun.y = Math.sin(sun.angle) * sun.orbitRadius;

        // PlanÃ¨tes autour du soleil
        for (let j = 0; j < sun.planets.length; j++) {
            const planet = sun.planets[j];
            planet.angle += planet.orbitSpeed * dt;
            planet.x = sun.x + Math.cos(planet.angle) * planet.orbitRadius;
            planet.y = sun.y + Math.sin(planet.angle) * planet.orbitRadius;

            // Lunes autour de la planÃ¨te
            for (let k = 0; k < planet.moons.length; k++) {
                const moon = planet.moons[k];
                moon.angle += moon.orbitSpeed * dt;
                moon.x = planet.x + Math.cos(moon.angle) * moon.orbitRadius;
                moon.y = planet.y + Math.sin(moon.angle) * moon.orbitRadius;
            }
        }
    }

    // Amas de mÃ©tÃ©orites
    for (const belt of gameState.asteroidBelts) {
        for (const rock of belt.rocks) {
            rock.angle += belt.orbitSpeed * dt;
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INTERFACE â€” Setup UI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupUI() {
    // â”€â”€ Couleurs d'Ã©quipe â”€â”€
    const picker = document.getElementById('colorPicker');
    gameState.teamColors.forEach((col, i) => {
        const swatch = document.createElement('div');
        swatch.className = 'color-swatch' + (col === gameState.playerColor ? ' selected' : '');
        swatch.style.background = col;
        swatch.addEventListener('click', () => {
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
            swatch.classList.add('selected');
            gameState.playerColor = col;
        });
        picker.appendChild(swatch);
    });

    // â”€â”€ Sliders config â”€â”€
    const cfgSuns = document.getElementById('cfgSuns');
    const cfgPlayers = document.getElementById('cfgPlayers');
    cfgSuns.addEventListener('input', () => {
        document.getElementById('cfgSunsVal').textContent = cfgSuns.value;
        gameState.config.sunCount = parseInt(cfgSuns.value);
    });
    cfgPlayers.addEventListener('input', () => {
        document.getElementById('cfgPlayersVal').textContent = cfgPlayers.value;
        gameState.config.playerCount = parseInt(cfgPlayers.value);
    });
    const cfgIA = document.getElementById('cfgIA');
    const cfgDifficulty = document.getElementById('cfgDifficulty');
    cfgIA.addEventListener('change', () => {
        gameState.config.useIA = cfgIA.value === 'on';
        cfgDifficulty.disabled = !gameState.config.useIA;
        cfgDifficulty.style.opacity = gameState.config.useIA ? '1' : '0.3';
    });
    const cfgCleaners = document.getElementById('cfgCleaners');
    cfgCleaners.addEventListener('input', () => {
        document.getElementById('cfgCleanersVal').textContent = cfgCleaners.value;
        gameState.config.cleanerCount = parseInt(cfgCleaners.value);
    });
    const cfgAsteroids = document.getElementById('cfgAsteroids');
    cfgAsteroids.addEventListener('change', () => {
        gameState.config.useAsteroids = cfgAsteroids.value === 'on';
    });

    // â”€â”€ Sliders stats (total = 10) â”€â”€
    const sliders = ['statGrowth', 'statVelocity', 'statDensity'];
    const keys = ['growth', 'velocity', 'density'];
    // Synchroniser les sliders avec les valeurs par dÃ©faut
    sliders.forEach((id, idx) => {
        document.getElementById(id).value = gameState.playerStats[keys[idx]];
        document.getElementById(id + 'Val').textContent = gameState.playerStats[keys[idx]];
        document.getElementById(id).addEventListener('input', () => {
            enforceStatPoints(idx);
        });
    });
    document.getElementById('cfgSunsVal').textContent = gameState.config.sunCount;
    document.getElementById('cfgSuns').value = gameState.config.sunCount;
    document.getElementById('cfgPlayersVal').textContent = gameState.config.playerCount;
    document.getElementById('cfgPlayers').value = gameState.config.playerCount;
    document.getElementById('cfgCleanersVal').textContent = gameState.config.cleanerCount;
    document.getElementById('cfgCleaners').value = gameState.config.cleanerCount;
    enforceStatPoints(0);

    // â”€â”€ Boutons navigation â”€â”€
    document.getElementById('btnNewGame').addEventListener('click', () => { ensureAudio(); playClickSound(); fadeTransition(() => setPhase('config')); });
    document.getElementById('btnBack').addEventListener('click', () => { playClickSound(); fadeTransition(() => setPhase('title')); });
    document.getElementById('btnStart').addEventListener('click', () => { playClickSound(); fadeTransition(() => startGame()); });
    document.getElementById('btnResume').addEventListener('click', () => { playClickSound(); togglePause(); });
    document.getElementById('btnQuit').addEventListener('click', () => { playClickSound(); setPhase('title'); });
    document.getElementById('codexClose').addEventListener('click', closeCodex);
    document.getElementById('btnReplay').addEventListener('click', () => { hideEndScreen(); startGame(); });
    setupMinimap();
    setupVolumeControl();
    document.getElementById('btnEndQuit').addEventListener('click', () => { hideEndScreen(); setPhase('title'); });

    // â”€â”€ Touche Ã‰chap pour pause â”€â”€
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (gameState.phase === 'game') togglePause();
            else if (gameState.phase === 'paused') togglePause();
        }
    });
}

function enforceStatPoints(changedIdx) {
    const ids = ['statGrowth', 'statVelocity', 'statDensity'];
    const keys = ['growth', 'velocity', 'density'];
    const vals = ids.map(id => parseInt(document.getElementById(id).value));
    const total = vals.reduce((a, b) => a + b, 0);

    if (total > 10) {
        // RÃ©duire les autres proportionnellement
        const excess = total - 10;
        const others = [0, 1, 2].filter(i => i !== changedIdx);
        let remaining = excess;
        for (const oi of others) {
            const reduce = Math.min(vals[oi], Math.ceil(remaining / (others.length - others.indexOf(oi))));
            vals[oi] -= reduce;
            remaining -= reduce;
            if (remaining <= 0) break;
        }
        ids.forEach((id, i) => document.getElementById(id).value = vals[i]);
    }

    ids.forEach((id, i) => {
        gameState.playerStats[keys[i]] = vals[i];
        document.getElementById(id + 'Val').textContent = vals[i];
    });
    const used = vals.reduce((a, b) => a + b, 0);
    document.getElementById('pointsLeft').textContent = 10 - used;
}

function setPhase(phase) {
    gameState.phase = phase;

    // Cacher tous les Ã©crans
    document.getElementById('authScreen').classList.add('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('leaderboardScreen').classList.add('hidden');
    document.getElementById('eventLog').style.display = 'none';
    document.getElementById('configScreen').classList.add('hidden');
    document.getElementById('lobbyScreen').classList.add('hidden');
    document.getElementById('roomScreen').classList.add('hidden');
    document.getElementById('spawnBanner').classList.add('hidden');
    document.getElementById('gameHud').style.display = 'none';
    document.getElementById('pauseOverlay').classList.remove('active');
    document.getElementById('endScreen').classList.remove('active');
    document.getElementById('gameCanvas').style.display = 'none';

    document.getElementById('myPlanets').style.display = 'none';
    document.getElementById('minimap').style.display = 'none';

    switch (phase) {
        case 'title':
            document.getElementById('titleScreen').classList.remove('hidden');
            gameState.running = false;
            stopAmbiance();
            animateTitleScreen();
            break;
        case 'lobby':
            document.getElementById('lobbyScreen').classList.remove('hidden');
            document.getElementById('titleScreen').classList.add('hidden');
            loadRoomList();
            break;
        case 'room':
            document.getElementById('roomScreen').classList.remove('hidden');
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('titleScreen').classList.add('hidden');
            break;
        case 'config':
            document.getElementById('configScreen').classList.remove('hidden');
            break;
        case 'spawn':
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('spawnBanner').classList.remove('hidden');
            break;
        case 'game':
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('spawnBanner').classList.add('hidden');
            document.getElementById('gameHud').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('uiZoomControl').style.display = 'block';
            document.getElementById('eventLog').style.display = 'block';
            initPanels();
            break;
        case 'paused':
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameHud').style.display = 'block';
            document.getElementById('pauseOverlay').classList.add('active');
            break;
    }
}

function togglePause() {
    if (gameState.phase === 'game') {
        gameState.phase = 'paused';
        setPhase('paused');
    } else if (gameState.phase === 'paused') {
        gameState.phase = 'game';
        setPhase('game');
    }
}

function startGame() {
    // Afficher le loading
    document.getElementById('loadingScreen').classList.remove('hidden');
    updateLoadingBar(0, 'GÃ©nÃ©ration de l\'espace...');

    // Lire la difficultÃ©
    gameState.config.difficulty = document.getElementById('cfgDifficulty').value;
    gameState.config.useIA = document.getElementById('cfgIA').value === 'on';
    gameState.config.cleanerCount = parseInt(document.getElementById('cfgCleaners').value);
    gameState.config.useAsteroids = document.getElementById('cfgAsteroids').value === 'on';

    // GÃ©nÃ©rer l'univers avec progression
    setTimeout(() => {
        updateLoadingBar(15, 'NÃ©buleuses et Ã©toiles...');
        if (!window._bgCfg) window._bgCfg = {};
        generateBackground();
        generateForegroundDebris();

        setTimeout(() => {
            updateLoadingBar(35, 'SystÃ¨mes solaires...');
            generateUniverse();

            setTimeout(() => {
                updateLoadingBar(55, 'Textures des soleils...');
                gameState.suns.forEach(s => createSunTexture(s));

                setTimeout(() => {
                    updateLoadingBar(70, 'Textures des planÃ¨tes...');
                    gameState.planets.forEach(p => createPlanetTexture(p));

                    setTimeout(() => {
                        updateLoadingBar(85, 'Textures des lunes...');
                        gameState.moons.forEach(m => createMoonTexture(m));

                        setTimeout(() => {
                            updateLoadingBar(92, 'Caches performances...');
                            buildBgLayerTextures();
            buildBgStarsCache();
                            buildBgClustersCache();
                            buildBrightStarsCache();
                            buildSunHaloCache();
                            setTimeout(() => {
                                updateLoadingBar(100, 'PrÃªt !');
                                setTimeout(() => {
                                    document.getElementById('loadingScreen').classList.add('hidden');
                                    finishStartGame();
                                }, 300);
                            }, 50);
                        }, 50);
                    }, 50);
                }, 50);
            }, 50);
        }, 50);
    }, 50);
}

function finishStartGame() {

    // Reset stats
    gameState.gameStats = {
        jetsLaunched: 0, jetsNeutralized: 0,
        bodiesConquered: 0, sporesProduced: 0, timeElapsed: 0
    };
    gameState.jets = [];
    gameState.conquestEffects = [];
    gameState.bloomEffects = [];
    gameState.impactEffects = [];
    gameState.time = 0;
    _lastScoreHash = '';

    // CrÃ©er les joueurs
    createPlayers();

    // Calculer le rayon max de l'univers
    let maxR = 0;
    for (const p of gameState.planets) {
        const d = Math.sqrt(p.x*p.x + p.y*p.y) + p.radius;
        if (d > maxR) maxR = d;
    }
    for (const m of gameState.moons) {
        const d = Math.sqrt(m.x*m.x + m.y*m.y) + m.radius;
        if (d > maxR) maxR = d;
    }
    gameState.universeRadius = maxR + 200;
    rebuildAllBodies();
    // Ajuster le dÃ©zoom min pour voir tout l'univers
    const screenMin = Math.min(gameState.width, gameState.height);
    gameState.camera.minZoom = Math.max(0.02, screenMin / (gameState.universeRadius * 2.2));

    // Centrer la camÃ©ra et zoom adaptÃ©
    gameState.camera.x = 0;
    gameState.camera.y = 0;
    gameState.camera.zoom = 0.3;

    // Lancer la boucle si pas encore active
    if (!gameState.running) {
        gameState.running = true;
        gameState.lastTime = performance.now();
        gameState.fpsLastCheck = performance.now();
        requestAnimationFrame(gameLoop);
    }

    // Audio
    ensureAudio();
    startAmbiance();

    // Phase spawn
    setPhase('spawn');
}

function createPlayers() {
    gameState.players = [];
    const colors = [...gameState.teamColors];

    // Joueur humain
    gameState.players.push({
        id: 0,
        name: 'Joueur',
        color: gameState.playerColor,
        isHuman: true,
        stats: { ...gameState.playerStats },
        bodies: [],
        totalSpores: 0,
        alive: true,
        spawnPlanet: null,
        multiTier: 0,
        multiProgress: 0,
        multiSacrifice: 0
    });

    // Retirer la couleur du joueur humain
    const usedIdx = colors.indexOf(gameState.playerColor);
    if (usedIdx >= 0) colors.splice(usedIdx, 1);

    // IAs
    for (let i = 1; i < gameState.config.playerCount; i++) {
        const aiColor = colors[i % colors.length];
        // Stats alÃ©atoires pour les IAs (total = 10)
        const s1 = Math.floor(Math.random() * 5) + 1;
        const s2 = Math.floor(Math.random() * (10 - s1)) + 1;
        const s3 = 10 - s1 - s2;
        gameState.players.push({
            id: i,
            name: 'IA-' + i,
            color: aiColor,
            isHuman: false,
            stats: { growth: s1, velocity: s2, density: s3 },
            bodies: [],
            totalSpores: 0,
            alive: true,
            spawnPlanet: null,
            aiTimer: 0,
            aiCooldown: gameState.config.difficulty === 'easy' ? 3 : gameState.config.difficulty === 'normal' ? 1.5 : 0.5,
            multiTier: 0,
            multiProgress: 0,
            multiSacrifice: 0
        });
    }
}// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MULTIPLICITÃ‰ â€” Fonctions
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function getMultiTierCost(currentTier) {
    return Math.floor(500 * Math.pow(1.8, currentTier));
}

function aiChooseMultiStat(player) {
    // IA : boost le stat le plus faible
    const s = player.stats;
    const min = Math.min(s.growth, s.velocity, s.density);
    if (s.growth === min) s.growth++;
    else if (s.density === min) s.density++;
    else s.velocity++;
    player.multiTier++;
}

function applyMultiChoice(player, stat) {
    player.stats[stat]++;
    player.multiTier++;
    player._multiPending = false;
    if (player === gameState.players[0]) {
        addEvent('build', 'âœ¦', `MultiplicitÃ© palier ${player.multiTier} â€” ${stat} +1`, null, gameState.players[0]?.color);
    }
}

function updateMultiPanel() {
    const panel = document.getElementById('evoPanel');
    if (!panel || gameState.phase !== 'game') return;

    const human = gameState.players[0];
    if (!human || !human.alive) return;

    // Pips
    const pipsEl = document.getElementById('evoTierPips');
    let pipsHtml = '';
    for (let i = 0; i < 10; i++) {
        const filled = i < human.multiTier ? 'filled' : '';
        const current = i === human.multiTier && human.multiTier < 10 ? 'current' : '';
        const label = i < human.multiTier ? (i + 1) : '';
        pipsHtml += `<div class="tier-pip ${filled} ${current}">${label}</div>`;
    }
    pipsEl.innerHTML = pipsHtml;

    // Barre de progression
    const cost = getMultiTierCost(human.multiTier);
    const pct = human.multiTier >= 10 ? 100 : Math.min(100, (human.multiProgress / cost) * 100);
    document.getElementById('evoBar').style.width = pct + '%';

    // Info
    const info = human.multiTier >= 10
        ? 'Ã‰VOLUTION MAXIMALE'
        : `Palier ${human.multiTier}/10 â€” ${Math.floor(human.multiProgress)} / ${cost} spores`;
    document.getElementById('evoInfo').textContent = info;

    // Slider
    document.getElementById('evoSacVal').textContent = human.multiSacrifice + '%';

    // Choix de stat en attente ?
    const chooseEl = document.getElementById('evoChoose');
    if (human._multiPending) {
        chooseEl.style.display = 'block';
        document.getElementById('evoGrowthCur').textContent = `(${human.stats.growth})`;
        document.getElementById('evoVelocityCur').textContent = `(${human.stats.velocity})`;
        document.getElementById('evoDensityCur').textContent = `(${human.stats.density})`;
    } else {
        chooseEl.style.display = 'none';
    }

    // Mise Ã  jour panneau stats + effets
    const s = human.stats;
    const base = gameState.playerStats || { growth: 3, velocity: 4, density: 3 };
    document.getElementById('evoStatGrowth').textContent = s.growth;
    document.getElementById('evoStatVelocity').textContent = s.velocity;
    document.getElementById('evoStatDensity').textContent = s.density;
    const gB = s.growth - base.growth;
    const vB = s.velocity - base.velocity;
    const dB = s.density - base.density;
    document.getElementById('evoStatGrowthBonus').textContent = gB > 0 ? `+${gB}` : '';
    document.getElementById('evoStatVelocityBonus').textContent = vB > 0 ? `+${vB}` : '';
    document.getElementById('evoStatDensityBonus').textContent = dB > 0 ? `+${dB}` : '';
    // Effets concrets
    const velSpeed = 20 + s.velocity * 6;
    const densPct = Math.round(s.density * 5);
    document.getElementById('evoStatGrowthFx').textContent = `Ã—${(1 + s.growth * 0.3).toFixed(1)} prod`;
    document.getElementById('evoStatVelocityFx').textContent = `${velSpeed} vitesse`;
    document.getElementById('evoStatDensityFx').textContent = `+${densPct}% impact`;
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// JETS DE SPORES â€” Physique
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// CODEX â€” Panneau latÃ©ral
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function openCodex(body) {
    gameState.selectedBody = body;
    gameState.codexOpen = true;
    document.getElementById('codexName').textContent = body.name;

    // AperÃ§u texture
    const previewEl = document.getElementById('codexPreview');
    previewEl.innerHTML = '';
    if (body._texture) {
        const preview = document.createElement('canvas');
        const size = 80;
        preview.width = size;
        preview.height = size;
        preview.style.cssText = 'border-radius:50%;border:2px solid rgba(100,70,180,0.3);';
        const pctx = preview.getContext('2d');
        pctx.drawImage(body._texture, 0, 0, size, size);
        previewEl.appendChild(preview);
    }

    document.getElementById('codexType').textContent = body.type === 'sun' ? 'Soleil' : body.type === 'planet' ? 'PlanÃ¨te' : 'Lune';
    document.getElementById('codexRadius').textContent = Math.round(body.radius);
    document.getElementById('codexFlore').textContent = body.flore !== undefined ? body.flore : 'â€”';
    document.getElementById('codexFaune').textContent = body.faune !== undefined ? body.faune : 'â€”';
    const owner = body.owner !== null && body.owner !== undefined
        ? gameState.players[body.owner]?.name || 'Inconnu'
        : 'Neutre';
    document.getElementById('codexOwner').textContent = owner;
    document.getElementById('codexSpores').textContent = body.spores !== undefined ? Math.floor(body.spores) : 'â€”';

    // Symbiose
    const symEl = document.getElementById('codexSymbiose');
    if (body.owner !== null && body.symbiosis !== undefined) {
        symEl.style.display = 'block';
        const pct = Math.floor(body.symbiosis);
        document.getElementById('codexSymVal').textContent = pct + '%';
        document.getElementById('codexSymBar').style.width = pct + '%';
        const bonusMax = body.type === 'planet' ? 20 : 10;
        const bonusCurrent = (pct / 100 * bonusMax).toFixed(1);
        document.getElementById('codexSymBonus').textContent = '+' + bonusCurrent + '% production';
    } else {
        symEl.style.display = 'none';
    }

    // Nids & Biomes
    const buildEl = document.getElementById('codexBuild');
    if (body.owner === 0 && body.type !== 'sun') {
        buildEl.style.display = 'block';
        // SÃ©lectionner le bon radio
        document.querySelectorAll('input[name="buildMode"]').forEach(r => {
            r.checked = (r.value === (body.buildMode || 'off'));
        });
        updateCodexBuild(body);
    } else if (body.owner !== null && body.type !== 'sun') {
        // Afficher en lecture seule pour les autres joueurs
        buildEl.style.display = 'block';
        document.querySelectorAll('input[name="buildMode"]').forEach(r => {
            r.checked = (r.value === (body.buildMode || 'off'));
            r.disabled = true;
        });
        updateCodexBuild(body);
    } else {
        buildEl.style.display = 'none';
    }

    document.getElementById('codex').classList.add('open');
}

function updateCodexBuild(body) {
    const countEl = document.getElementById('codexBuildCount');
    const infoEl = document.getElementById('codexBuildInfo');
    const barEl = document.getElementById('codexBuildBar');

    const nids = body.nids || 0;
    const biomes = body.biomes || 0;
    const nidBonus = (nids * 0.2).toFixed(1);
    const biomeBonus = (biomes * 0.2).toFixed(1);

    let countText = '';
    if (nids > 0) countText += `ğŸªº ${nids} nid${nids>1?'s':''} (+${nidBonus}% prod)`;
    if (biomes > 0) countText += `${nids>0?' | ':''}ğŸ›¡ ${biomes} biome${biomes>1?'s':''} (+${biomeBonus}% dÃ©f)`;
    if (!countText) countText = 'Aucune construction';
    countEl.textContent = countText;

    if (body.buildMode === 'nid' || body.buildMode === 'biome') {
        const pct = Math.floor((body.buildProgress / body.maxSpores) * 100);
        infoEl.textContent = `Max spores: ${Math.floor(body.maxSpores / 3)} | CoÃ»t: ${body.maxSpores} | Progression: ${pct}%`;
        barEl.style.width = pct + '%';
        barEl.className = 'build-progress ' + body.buildMode;
    } else {
        infoEl.textContent = `Max spores: ${body.maxSpores}`;
        barEl.style.width = '0%';
    }
}

function closeCodex() {
    gameState.codexOpen = false;
    gameState.selectedBody = null;
    document.getElementById('codex').classList.remove('open');
    // RÃ©activer les radios
    document.querySelectorAll('input[name="buildMode"]').forEach(r => r.disabled = false);
}

// Listener changement mode nid/biome
document.querySelectorAll('input[name="buildMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        const body = gameState.selectedBody;
        if (!body || body.owner !== 0) return;
        body.buildMode = e.target.value;
        if (body.buildMode === 'off') body.buildProgress = 0;
        updateCodexBuild(body);
    });
});


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// HUD â€” Mise Ã  jour
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateHUD() {
    if (gameState.phase !== 'game') return;

    // Recalculer totalSpores pour chaque joueur
    for (const player of gameState.players) {
        let total = 0;
        for (const body of player.bodies) {
            total += body.spores;
        }
        player.totalSpores = total;
    }

    // Compteur spores joueur humain
    const human = gameState.players[0];
    if (human && DOM.sporeCount) {
        DOM.sporeCount.textContent = Math.floor(human.totalSpores);
    }

    // Tableau des scores
    updateScoreBoard();

    // Timer
    updateGameTimer();

    // Minimap (throttle toutes les 15 frames)
    if (gameState._hudCounter % 15 === 0) drawMinimap();

    // Codex si ouvert
    if (gameState.codexOpen && gameState.selectedBody) {
        openCodex(gameState.selectedBody);
    }
}

let _lastScoreHash = '';
function updateScoreBoard() {
    const board = DOM.scoreBoard;
    if (!board) return;
    const totalBodies = gameState.planets.length + gameState.moons.length;

    // Calculer un hash rapide pour Ã©viter innerHTML inutile
    let hash = '';
    let html = '';
    for (const player of gameState.players) {
        if (!player.alive) continue;
        const owned = player.bodies ? player.bodies.length : 0;
        const pct = totalBodies > 0 ? Math.round((owned / totalBodies) * 100) : 0;
        hash += player.id + ':' + pct + ',';
        html += `<div class="score-row">
            <div class="score-color" style="background:${player.color}"></div>
            <span class="score-name">${player.name}</span>
            <div class="score-bar-bg"><div class="score-bar" style="width:${pct}%;background:${player.color}"></div></div>
            <span class="score-pct">${pct}%</span>
        </div>`;
    }

    if (hash !== _lastScoreHash) {
        _lastScoreHash = hash;
        const handle = board.querySelector('.panel-drag-handle');
        board.innerHTML = html;
        if (handle) board.insertBefore(handle, board.firstChild);
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SPAWN â€” SÃ©lection de planÃ¨te de dÃ©part
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function handleSpawnClick(worldX, worldY) {
    // Trouver la planÃ¨te la plus proche du clic
    let closest = null;
    let closestDist = Infinity;
    for (const p of gameState.planets) {
        if (p.owner !== null) continue; // dÃ©jÃ  prise
        const dx = p.x - worldX;
        const dy = p.y - worldY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < p.radius + 10 && dist < closestDist) {
            closest = p;
            closestDist = dist;
        }
    }

    if (!closest) return;

    // Assigner au joueur humain
    const human = gameState.players[0];
    closest.owner = 0;
    closest.spores = closest.maxSpores * 0.5;
    human.bodies = [closest];
    human.spawnPlanet = closest;

    // Spawn automatique des IAs
    autoSpawnAIs();

    // Passer en jeu
    setPhase('game');
}

function autoSpawnAIs() {
    const available = gameState.planets.filter(p => p.owner === null);
    for (let i = 1; i < gameState.players.length; i++) {
        if (available.length === 0) break;
        // Choisir une planÃ¨te Ã©loignÃ©e des autres joueurs
        let bestPlanet = null;
        let bestScore = -1;
        for (const p of available) {
            let minDist = Infinity;
            for (const other of gameState.players) {
                if (other.id >= i || !other.spawnPlanet) continue;
                const dx = p.x - other.spawnPlanet.x;
                const dy = p.y - other.spawnPlanet.y;
                minDist = Math.min(minDist, Math.sqrt(dx*dx + dy*dy));
            }
            const score = minDist + p.flore * 2;
            if (score > bestScore) {
                bestScore = score;
                bestPlanet = p;
            }
        }
        if (bestPlanet) {
            bestPlanet.owner = i;
            bestPlanet.spores = bestPlanet.maxSpores * 0.5;
            gameState.players[i].bodies = [bestPlanet];
            gameState.players[i].spawnPlanet = bestPlanet;
            available.splice(available.indexOf(bestPlanet), 1);
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFETS COSMIQUES â€” Particules & Ã©toiles filantes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCosmicEffects(dt) {
    const t = gameState.time;

    // Drift des couches de fond
    for (const v of gameState.bgVeils) {
        v.x += v.vx * dt; v.y += v.vy * dt;
        v.rotation += v.rotSpeed * dt;
    }
    for (const n of gameState.bgNebulae) {
        n.x += n.vx * dt; n.y += n.vy * dt;
        n.rotation += n.rotSpeed * dt;
    }
    for (const f of gameState.bgFilaments) {
        f.x += f.vx * dt; f.y += f.vy * dt;
    }
    for (const c of gameState.bgStarClusters) {
        c.x += c.vx * dt; c.y += c.vy * dt;
    }

    // Particules ambiantes
    for (const p of gameState.cosmicDust) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        // LÃ©gÃ¨re oscillation
        p.x += Math.sin(t * 0.5 + p.phase) * 0.3 * dt;
        p.y += Math.cos(t * 0.4 + p.phase) * 0.3 * dt;
    }

    // Ã‰toiles filantes
    gameState.shootingStarTimer -= dt;
    if (gameState.shootingStarTimer <= 0) {
        gameState.shootingStarTimer = 0.5 + Math.random() * 1.0;
        // Spawner dans la zone visible Ã©largie
        const cam = gameState.camera;
        const range = 5000 / cam.zoom;
        const angle = -0.8 + Math.random() * 0.4;
        const speed = 800 + Math.random() * 1200;
        gameState.shootingStars.push({
            x: cam.x + (Math.random() - 0.5) * range,
            y: cam.y - range * 0.4 + Math.random() * range * 0.2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.8 + Math.random() * 1.5,
            age: 0,
            length: 60 + Math.random() * 120,
            brightness: 0.5 + Math.random() * 0.5
        });
    }

    for (let i = gameState.shootingStars.length - 1; i >= 0; i--) {
        const s = gameState.shootingStars[i];
        s.age += dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        if (s.age >= s.life) gameState.shootingStars.splice(i, 1);
    }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// COMÃˆTES DESTRUCTRICES
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateComets(dt) {
    gameState.cometTimer -= dt;
    if (gameState.cometTimer <= 0) {
        gameState.cometTimer = COMET_CFG.freq * (0.7 + Math.random() * 0.6);
        const cam = gameState.camera;
        const range = (gameState.universeRadius || 6000) * 2;
        const angle = Math.random() * Math.PI * 2;
        const startDist = range * 0.8;
        const cx = Math.cos(angle) * startDist;
        const cy = Math.sin(angle) * startDist;
        // Viser un point alÃ©atoire dans l'univers
        const targetAngle = angle + Math.PI + (Math.random() - 0.5) * 1.2;
        const spd = COMET_CFG.speed + Math.random() * COMET_CFG.speed * 0.5;
        gameState.comets.push({
            x: cx, y: cy,
            vx: Math.cos(targetAngle) * spd,
            vy: Math.sin(targetAngle) * spd,
            size: COMET_CFG.size * (0.6 + Math.random() * 0.8),
            tail: COMET_CFG.tail * (0.7 + Math.random() * 0.6),
            life: range * 2 / spd,
            age: 0,
            color: ['#88DDFF','#AAEEFF','#FFCC66','#FF9966'][Math.floor(Math.random()*4)]
        });
    }

    for (let i = gameState.comets.length - 1; i >= 0; i--) {
        const c = gameState.comets[i];
        c.age += dt;
        c.x += c.vx * dt;
        c.y += c.vy * dt;

        if (c.age >= c.life) { gameState.comets.splice(i, 1); continue; }

        // Collision avec planÃ¨tes et lunes â†’ dÃ©truire les spores
        const bodies = gameState.allBodies;
        for (const body of bodies) {
            const dx = body.x - c.x;
            const dy = body.y - c.y;
            if (Math.sqrt(dx*dx + dy*dy) < body.radius + c.size) {
                body.spores = 0;
                spawnImpact(c.x, c.y, c.color);
                gameState.comets.splice(i, 1);
                break;
            }
        }
    }
}

function drawComets(ctx) {
    for (const c of gameState.comets) {
        const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
        const dx = -c.vx / spd;
        const dy = -c.vy / spd;

        // TraÃ®ne
        const g = ctx.createLinearGradient(c.x, c.y, c.x + dx * c.tail, c.y + dy * c.tail);
        g.addColorStop(0, c.color);
        g.addColorStop(0.3, c.color + '80');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.strokeStyle = g;
        ctx.lineWidth = c.size * 0.6;
        ctx.beginPath();
        ctx.moveTo(c.x, c.y);
        ctx.lineTo(c.x + dx * c.tail, c.y + dy * c.tail);
        ctx.stroke();

        // TÃªte
        ctx.fillStyle = c.color;
        ctx.shadowColor = c.color;
        ctx.shadowBlur = c.size * 2;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DÃ‰BRIS PREMIER PLAN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateForegroundDebris() {
    gameState.foregroundDebris = [];
    const count = COMET_CFG.fgDebris;
    for (let i = 0; i < count; i++) {
        gameState.foregroundDebris.push({
            offX: (Math.random() - 0.5) * 2,
            offY: (Math.random() - 0.5) * 2,
            size: 2 + Math.random() * 8,
            speed: 0.3 + Math.random() * 0.7,
            angle: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 2,
            type: ['rock','dust','ice'][Math.floor(Math.random()*3)],
            alpha: 0.15 + Math.random() * 0.25,
            parallax: 1.5 + Math.random() * 1.5
        });
    }
}

function drawForegroundDebris(ctx) {
    const cam = gameState.camera;
    const t = gameState.time;
    const w = gameState.width;
    const h = gameState.height;

    for (const d of gameState.foregroundDebris) {
        // Position relative Ã  la camÃ©ra avec forte parallaxe (premier plan)
        const px = ((d.offX * 5000 - cam.x * d.parallax + t * d.speed * 100) % (w / cam.zoom * 2));
        const py = ((d.offY * 5000 - cam.y * d.parallax + t * d.speed * 50) % (h / cam.zoom * 2));
        // Convertir en screen coords
        const sx = w / 2 + px * cam.zoom;
        const sy = h / 2 + py * cam.zoom;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(t * d.rotSpeed);
        ctx.globalAlpha = d.alpha;

        if (d.type === 'rock') {
            ctx.fillStyle = '#665544';
            ctx.beginPath();
            const s = d.size * cam.zoom * 0.5;
            ctx.moveTo(-s, -s*0.6);
            ctx.lineTo(s*0.8, -s);
            ctx.lineTo(s, s*0.5);
            ctx.lineTo(-s*0.3, s);
            ctx.closePath();
            ctx.fill();
        } else if (d.type === 'dust') {
            ctx.fillStyle = 'rgba(180,160,200,0.5)';
            const s = d.size * cam.zoom * 0.4;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillStyle = 'rgba(200,230,255,0.6)';
            const s = d.size * cam.zoom * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(s*0.3, -s*0.3, s*0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }
}

function drawCosmicEffects(ctx) {
    const t = gameState.time;
    const z = gameState.camera.zoom;

    // Particules ambiantes
    for (const p of gameState.cosmicDust) {
        const flicker = p.alpha * (0.7 + Math.sin(t * 2 + p.phase) * 0.3);
        ctx.fillStyle = `rgba(180, 200, 240, ${flicker})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    }

    // Ã‰toiles filantes
    for (const s of gameState.shootingStars) {
        const progress = s.age / s.life;
        const alpha = s.brightness * (progress < 0.2 ? progress / 0.2 : 1 - (progress - 0.2) / 0.8);
        const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
        const dirX = s.vx / speed;
        const dirY = s.vy / speed;
        const tailX = s.x - dirX * s.length;
        const tailY = s.y - dirY * s.length;

        // TraÃ®ne dÃ©gradÃ©e
        const g = ctx.createLinearGradient(tailX, tailY, s.x, s.y);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(0.7, `rgba(200, 220, 255, ${alpha * 0.3})`);
        g.addColorStop(1, `rgba(255, 255, 255, ${alpha})`);
        ctx.strokeStyle = g;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(s.x, s.y);
        ctx.stroke();

        // Point lumineux en tÃªte
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// SPORES â€” GÃ©nÃ©ration passive
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateSporeGeneration(dt) {
    const bodies = gameState.allBodies;
    for (const body of bodies) {
        // RÃ©gÃ©nÃ©ration de Faune sur astres neutres non conquis
        if (body.owner === null && body._baseFaune !== undefined && body.faune < body._baseFaune) {
            body.faune += 2 * dt; // rÃ©gÃ©nÃ©ration lente
            if (body.faune > body._baseFaune) body.faune = body._baseFaune;
        }

        if (body.owner === null) continue;

        // Mise Ã  jour symbiose
        body.symOwnerTime += dt;
        const symMaxTime = body.type === 'planet' ? 600 : 300; // 10min planÃ¨tes, 5min lunes
        body.symbiosis = Math.min(100, (body.symOwnerTime / symMaxTime) * 100);

        if (body.flore <= 0) continue;
        const player = gameState.players[body.owner];
        if (!player) continue;

        // Bonus symbiose : +20% planÃ¨tes, +10% lunes Ã  100%
        const symBonusMax = body.type === 'planet' ? 0.20 : 0.10;
        const symBonus = 1 + (body.symbiosis / 100) * symBonusMax;

        // Bonus nids : +0.2% production locale par nid
        const nidBonus = 1 + (body.nids || 0) * 0.002;

        // Bonus systÃ¨me complet : +3% si toutes planÃ¨tes+lunes du soleil au mÃªme owner
        let sysBonus = 1;
        const bodySun = body.type === 'planet' ? body.parent : (body.parent.parent || null);
        if (bodySun && isSystemComplete(bodySun, body.owner)) sysBonus = 1.03;

        const rate = (body.flore / 100) * (1 + player.stats.growth * 0.3) * 2 * symBonus * nidBonus * sysBonus;

        // Mode construction : production allouÃ©e au compteur
        if (body.buildMode === 'nid' || body.buildMode === 'biome') {
            body.buildProgress += rate * dt;
            // VÃ©rifier si construction terminÃ©e
            if (body.buildProgress >= body.maxSpores) {
                body.buildProgress -= body.maxSpores;
                if (body.buildMode === 'nid') {
                    body.nids = (body.nids || 0) + 1;
                    if (body.owner === 0) addEvent('build', 'ğŸ—ï¸', `Nid construit sur ${body.name} (${body.nids})`, body, gameState.players[0]?.color);
                } else {
                    body.biomes = (body.biomes || 0) + 1;
                    if (body.owner === 0) addEvent('build', 'ğŸ›¡ï¸', `Biome construit sur ${body.name} (${body.biomes})`, body, gameState.players[0]?.color);
                }
            }
            // Max spores rÃ©duit Ã  1/3
            const reducedMax = Math.floor(body.maxSpores / 3);
            if (body.spores > reducedMax) {
                body.spores -= (body.spores - reducedMax) * 0.5 * dt;
            }
        } else {
            // MultiplicitÃ© : sacrifice d'une partie de la production
            const sacPct = (player.multiSacrifice || 0) / 100;
            const sacAmount = rate * sacPct * dt;
            const prodAmount = rate * (1 - sacPct) * dt;

            body.spores += prodAmount;
            gameState.gameStats.sporesProduced += prodAmount;

            // Accumuler les spores sacrifiÃ©es dans la jauge multiplicitÃ©
            if (sacPct > 0 && player.multiTier < 10) {
                player.multiProgress += sacAmount;
                const tierCost = getMultiTierCost(player.multiTier);
                if (player.multiProgress >= tierCost) {
                    player.multiProgress -= tierCost;
                    if (player.isHuman) {
                        player._multiPending = true;
                    } else {
                        aiChooseMultiStat(player);
                    }
                }
            }

            // DÃ©croissance si au-dessus du max
            if (body.spores > body.maxSpores) {
                body.spores -= (body.spores - body.maxSpores) * 0.5 * dt;
            }
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// JETS DE SPORES â€” Physique
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function computeTrajectory(startX, startY, dirX, dirY, speed, steps) {
    const bh = gameState.blackHole;
    const points = [];
    let x = startX, y = startY;
    let vx = dirX * speed, vy = dirY * speed;
    const dt = 0.4;

    for (let i = 0; i < steps; i++) {
        // GravitÃ© du trou noir (trÃ¨s lÃ©gÃ¨re)
        const dx = bh.x - x;
        const dy = bh.y - y;
        const distSq = dx * dx + dy * dy;
        const dist = Math.sqrt(distSq);

        if (dist < bh.dangerZone * 0.4) break;

        // GravitÃ© du trou noir : 1/dist pour courbes visibles
        const gRange = bh.gravityRange || 1500;
        if (dist < gRange) {
            const G = bh.gravityStrength || 500;
            // Falloff progressif vers le bord de portÃ©e
            const edgeFade = 1 - Math.pow(dist / gRange, 2);
            const gravity = G / (dist + 50) * edgeFade;
            const factor = gravity * dt;
            vx += (dx / dist) * factor;
            vy += (dy / dist) * factor;
        }

        x += vx * dt;
        y += vy * dt;
        points.push({ x, y });
    }
    return points;
}

function launchJet(source, dirX, dirY) {
    const player = gameState.players[source.owner];
    if (!player) return;

    const sporeCount = Math.floor(source.spores * 0.5);
    if (sporeCount < 5) return;
    source.spores -= sporeCount;

    const speed = 20 + player.stats.velocity * 6;
    const traj = computeTrajectory(source.x, source.y, dirX, dirY, speed, 400);

    // GÃ©nÃ©rer des particules scintillantes autour du jet
    const sparkles = [];
    for (let i = 0; i < 12; i++) {
        sparkles.push({
            offX: 0, offY: 0,
            angle: Math.random() * Math.PI * 2,
            speed: 0.3 + Math.random() * 0.8,
            radius: 1 + Math.random() * 2,
            phase: Math.random() * Math.PI * 2
        });
    }

    gameState.gameStats.jetsLaunched++;
    playLaunchSound();
    gameState.jets.push({
        owner: source.owner,
        color: player.color,
        spores: sporeCount,
        trajectory: traj,
        posIndex: 0,
        x: source.x,
        y: source.y,
        speed: speed,
        alive: true,
        trail: [],
        sparkles: sparkles,
        age: 0,
        selected: false,
        source: source
    });
}

function updateJets(dt) {
    const bh = gameState.blackHole;
    const jets = gameState.jets;

    for (let i = jets.length - 1; i >= 0; i--) {
        const jet = jets[i];
        if (!jet.alive) { jets.splice(i, 1); continue; }

        jet.age += dt;

        // Jets renvoyÃ©s : guidage vers la cible
        if (jet._targetBody) {
            const tb = jet._targetBody;
            const tdx = tb.x - jet.x;
            const tdy = tb.y - jet.y;
            const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
            jet.trail.push({ x: jet.x, y: jet.y, t: jet.age });
            if (jet.trail.length > 30) jet.trail.shift();
            if (tDist < tb.radius + 8) {
                // ArrivÃ© sur la cible
                jet.x = tb.x;
                jet.y = tb.y;
            } else {
                const moveSpeed = jet.speed * 0.70 * dt;
                jet.x += (tdx / tDist) * moveSpeed;
                jet.y += (tdy / tDist) * moveSpeed;
            }
        } else {
        // Avancer le long de la trajectoire
        jet.posIndex += jet.speed * dt * 0.70;
        const idx = Math.floor(jet.posIndex);

        if (idx >= jet.trajectory.length - 1) {
            jet.alive = false;
            continue;
        }

        const pt = jet.trajectory[idx];

        // TraÃ®ne : stocker les positions passÃ©es
        jet.trail.push({ x: jet.x, y: jet.y, t: jet.age });
        if (jet.trail.length > 30) jet.trail.shift();

        jet.x = pt.x;
        jet.y = pt.y;
        }

        // Animer les particules scintillantes
        for (const sp of jet.sparkles) {
            sp.angle += sp.speed * dt * 3;
            sp.offX = Math.cos(sp.angle) * (5 + Math.sin(jet.age * 4 + sp.phase) * 3);
            sp.offY = Math.sin(sp.angle) * (5 + Math.cos(jet.age * 4 + sp.phase) * 3);
        }

        // TraversÃ©e amas de mÃ©tÃ©orites
        if (!jet._hitBelt) jet._hitBelt = {};
        for (let bi = 0; bi < gameState.asteroidBelts.length; bi++) {
            if (jet._hitBelt[bi]) continue;
            const belt = gameState.asteroidBelts[bi];
            const sun = belt.sun;
            // VÃ©rifier proximitÃ© rÃ©elle avec un amas (pas juste l'anneau)
            let closestType = null;
            let closestDist = Infinity;
            for (const rock of belt.rocks) {
                const ra = rock.angle;
                const rr = belt.radius + rock.radiusOff;
                const rcx = sun.x + Math.cos(ra) * rr;
                const rcy = sun.y + Math.sin(ra) * rr;
                const rd = (jet.x - rcx) * (jet.x - rcx) + (jet.y - rcy) * (jet.y - rcy);
                if (rd < closestDist) { closestDist = rd; closestType = rock.type; }
            }
            // Seulement si le jet est Ã  moins de 25px d'un amas rÃ©el
            if (closestDist > 625) continue; // 25 * 25
            jet._hitBelt[bi] = true;
            if (closestType === 'dark') {
                // Noir : divise les spores par 2
                jet.spores = Math.max(1, Math.floor(jet.spores / 2));
                spawnImpact(jet.x, jet.y, '#555555');
            } else if (closestType === 'red') {
                // Rouge : dÃ©vie le jet de 5Â° Ã  15Â°
                const devAngle = (5 + Math.random() * 10) * Math.PI / 180;
                const sign = Math.random() < 0.5 ? 1 : -1;
                const cosA = Math.cos(devAngle * sign);
                const sinA = Math.sin(devAngle * sign);
                for (let ti = Math.floor(jet.posIndex); ti < jet.trajectory.length; ti++) {
                    const p = jet.trajectory[ti];
                    const relX = p.x - jet.x;
                    const relY = p.y - jet.y;
                    p.x = jet.x + relX * cosA - relY * sinA;
                    p.y = jet.y + relX * sinA + relY * cosA;
                }
                spawnImpact(jet.x, jet.y, '#FF4444');
            } else if (closestType === 'green') {
                // Vert : Ã©clate en 5 mini-jets
                const sporesEach = Math.max(1, Math.floor(jet.spores / 5));
                for (let si = 0; si < 5; si++) {
                    const sAngle = Math.random() * Math.PI * 2;
                    const sDirX = Math.cos(sAngle);
                    const sDirY = Math.sin(sAngle);
                    const speed = jet.speed * (0.6 + Math.random() * 0.4);
                    const traj = computeTrajectory(jet.x, jet.y, sDirX, sDirY, speed, 200);
                    gameState.jets.push({
                        owner: jet.owner,
                        color: jet.color,
                        spores: sporesEach,
                        trajectory: traj,
                        posIndex: 0,
                        x: jet.x,
                        y: jet.y,
                        speed: speed,
                        alive: true,
                        trail: [],
                        sparkles: [],
                        age: 0,
                        selected: false,
                        source: jet.source,
                        _hitBelt: Object.assign({}, jet._hitBelt)
                    });
                }
                spawnImpact(jet.x, jet.y, '#44FF44');
                jet.alive = false;
                break;
            }
        }

        // Destruction par trou noir
        const bhDx = bh.x - jet.x;
        const bhDy = bh.y - jet.y;
        if (Math.sqrt(bhDx*bhDx + bhDy*bhDy) < bh.dangerZone * 0.4) {
            spawnImpact(jet.x, jet.y, '#9933FF');
            jet.alive = false;
            continue;
        }

        // Collision avec astres
        checkJetCollision(jet);
    }

    checkJetNeutralization();
}

function checkJetCollision(jet) {
    // Destruction par les soleils
    for (const sun of gameState.suns) {
        const dx = sun.x - jet.x;
        const dy = sun.y - jet.y;
        if (Math.sqrt(dx*dx + dy*dy) < sun.radius + 5) {
            spawnImpact(jet.x, jet.y, sun.color || '#FFE44D');
            jet.alive = false;
            return;
        }
    }

    const bodies = gameState.allBodies;
    for (const body of bodies) {
        if (body === jet.source && jet.age < 2) continue;
        const dx = body.x - jet.x;
        const dy = body.y - jet.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < body.radius + 8) {
            spawnImpact(jet.x, jet.y, jet.color);
            // Jets renvoyÃ©s par vaisseau noir : ciblent une planÃ¨te spÃ©cifique
            if (jet.owner === -1) {
                if (body === jet._targetBody || !jet._targetBody) {
                    const oldOwner = body.owner;
                    body.spores -= jet.spores;
                    if (body.spores < 0) {
                        body.spores = Math.abs(body.spores);
                        body.owner = null;
                        body.symOwnerTime = 0;
                        body.symbiosis = 0;
                        if (oldOwner !== null) {
                            const p = gameState.players[oldOwner];
                            if (p) p.bodies = p.bodies.filter(b => b !== body);
                        }
                        gameState.conquestEffects.push({
                            x: body.x, y: body.y - 15, baseX: body.x,
                            text: 'CHASSÃ‰ !', color: '#888888', age: 0, maxAge: 2
                        });
                        const bT = body.type === 'planet' ? 'PlanÃ¨te' : 'Lune';
                        const chColor = oldOwner !== null ? (gameState.players[oldOwner]?.color || '#888') : '#888';
                        if (oldOwner === 0) addEvent('mine', 'â†©', `${bT} ${body.name} chassÃ© par vaisseau !`, body, chColor);
                        else addEvent('war', 'â†©', `${bT} ${body.name} chassÃ© (Joueur ${oldOwner})`, body, chColor);
                    }
                    jet.alive = false;
                    return;
                }
                continue;
            }
            if (body.owner === jet.owner) {
                // Density bonus : +5% spores livrÃ©es par point
                const densityBonus = 1 + (gameState.players[jet.owner]?.stats.density || 0) * 0.05;
                body.spores += jet.spores * densityBonus;
                playFusionSound();
            } else {
                const oldOwner = body.owner;
                applyConquest(body, jet);
                if (body.owner !== oldOwner) playConquestSound();
            }
            jet.alive = false;
            return;
        }
    }
}

function applyConquest(body, jet) {
    // Density bonus : +5% puissance d'impact par point
    const densityBonus = 1 + (gameState.players[jet.owner]?.stats.density || 0) * 0.05;
    let attacking = jet.spores * densityBonus;
    const attackerColor = gameState.players[jet.owner]?.color || '#FFF';

    // Ã‰puiser la faune
    if (body.faune > 0) {
        const fauneDmg = Math.min(body.faune, attacking);
        body.faune -= fauneDmg;
        attacking -= fauneDmg;
        // Effet visuel : faune restante
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: '-' + Math.floor(fauneDmg) + ' Faune',
            color: '#FF6B6B', age: 0, maxAge: 4
        });
    }

    // Bonus dÃ©fense biomes : +0.2% par biome = il faut plus de spores pour conquÃ©rir
    const biomeDefense = 1 + (body.biomes || 0) * 0.002;
    attacking = attacking / biomeDefense;

    // Combattre les spores dÃ©fensives
    if (attacking > 0 && body.owner !== null && body.spores > 0) {
        const defenseDmg = Math.min(body.spores, attacking);
        body.spores -= defenseDmg;
        attacking -= defenseDmg;
    }

    // ConquÃªte rÃ©ussie ?
    if (attacking > 0 && body.spores <= 0) {
        const oldOwner = body.owner;
        if (oldOwner !== null && gameState.players[oldOwner]) {
            const arr = gameState.players[oldOwner].bodies;
            const idx = arr.indexOf(body);
            if (idx >= 0) arr.splice(idx, 1);
        }

        body.owner = jet.owner;
        body.spores = attacking;
        body.faune = 0; // Faune dÃ©truite aprÃ¨s conquÃªte
        body.symbiosis = 0; // Reset symbiose
        body.symOwnerTime = 0;
        body.buildMode = 'off';
        body.buildProgress = 0;
        body.nids = 0;
        body.biomes = 0;

        if (gameState.players[jet.owner]) {
            gameState.players[jet.owner].bodies.push(body);
        }

        gameState.gameStats.bodiesConquered++;

        // Log Ã©vÃ©nement
        const attackerName = gameState.players[jet.owner]?.name || 'Joueur ' + jet.owner;
        const bType = body.type === 'planet' ? 'PlanÃ¨te' : 'Lune';
        const aColor = gameState.players[jet.owner]?.color || '#AAA';
        const oColor = oldOwner !== null ? (gameState.players[oldOwner]?.color || '#AAA') : '#AAA';
        if (oldOwner === null) {
            addEvent('neutral', 'ğŸ³ï¸', `${bType} ${body.name} colonisÃ©e par ${attackerName}`, body, aColor);
        } else if (jet.owner === 0) {
            addEvent('mine', 'âš”ï¸', `${bType} ${body.name} conquise !`, body, aColor);
        } else if (oldOwner === 0) {
            addEvent('mine', 'ğŸ’€', `${bType} ${body.name} perdue ! (${attackerName})`, body, aColor);
        } else {
            addEvent('war', 'âš”ï¸', `${bType} ${body.name} : ${attackerName} prend Ã  Joueur ${oldOwner}`, body, aColor);
        }

        // Effet d'Ã©closion
        gameState.bloomEffects.push({
            body: body, age: 0, maxAge: 1.5, color: attackerColor
        });

        // Effet texte
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: 'CONQUIS !',
            color: attackerColor, age: 0, maxAge: 5
        });
    } else if (attacking <= 0 && body.faune <= 0 && body.spores > 0) {
        // Attaque repoussÃ©e
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: 'RepoussÃ©',
            color: '#888', age: 0, maxAge: 3.5
        });
    }
}

function checkJetNeutralization() {
    const jets = gameState.jets;
    for (let i = 0; i < jets.length; i++) {
        if (!jets[i].alive) continue;
        for (let j = i + 1; j < jets.length; j++) {
            if (!jets[j].alive) continue;
            if (jets[i].owner === jets[j].owner) continue;

            const dx = jets[i].x - jets[j].x;
            const dy = jets[i].y - jets[j].y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 15) {
                playNeutralizationSound();
                gameState.gameStats.jetsNeutralized++;
                const min = Math.min(jets[i].spores, jets[j].spores);
                jets[i].spores -= min;
                jets[j].spores -= min;
                if (jets[i].spores <= 0) jets[i].alive = false;
                if (jets[j].spores <= 0) jets[j].alive = false;
            }
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// JETS DE SPORES â€” Rendu (style gerbe magique)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawJets(ctx) {
    const t = gameState.time;
    const jLod = gameState.lod;

    for (const jet of gameState.jets) {
        if (!jet.alive) continue;

        // â”€â”€ TraÃ®ne diffuse (brume colorÃ©e) â”€â”€
        const trail = jet.trail;
        if (trail.length > 1) {
            // LOD low : skip radial gradients, juste la ligne
            if (jLod >= 1) {
              const step = jLod >= 2 ? 1 : 2; // LOD mid: 1 sur 2
              for (let i = 1; i < trail.length; i += step) {
                const progress = i / trail.length;
                const alpha = progress * 0.35;
                const zs = Math.max(1, 1.2 / gameState.camera.zoom);
                const spread = (8 + (1 - progress) * 6) * zs;

                const g = ctx.createRadialGradient(
                    trail[i].x, trail[i].y, 0,
                    trail[i].x, trail[i].y, spread
                );
                g.addColorStop(0, jet.color + hexAlpha(alpha));
                g.addColorStop(0.6, jet.color + hexAlpha(alpha * 0.4));
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(trail[i].x, trail[i].y, spread, 0, Math.PI * 2);
                ctx.fill();
              }
            }

            // Ligne de traÃ®ne lumineuse
            ctx.beginPath();
            ctx.moveTo(trail[0].x, trail[0].y);
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            ctx.lineTo(jet.x, jet.y);
            const zl = Math.max(1, 1.2 / gameState.camera.zoom);
            ctx.strokeStyle = jet.color + '40';
            ctx.lineWidth = 4 * zl;
            ctx.stroke();
            ctx.strokeStyle = '#FFFFFF20';
            ctx.lineWidth = 2 * zl;
            ctx.stroke();
        }

        // Taille adaptÃ©e au zoom (toujours bien visible)
        const z = gameState.camera.zoom;
        const scale = Math.max(1, 1.2 / z);
        const haloR = 30 * scale;
        const coreR = 8 * scale;
        const sparkScale = scale;

        // â”€â”€ Halo externe large (lueur magique) â”€â”€
        const gOuter = ctx.createRadialGradient(jet.x, jet.y, 0, jet.x, jet.y, haloR);
        gOuter.addColorStop(0, jet.color + '50');
        gOuter.addColorStop(0.3, jet.color + '25');
        gOuter.addColorStop(0.7, jet.color + '10');
        gOuter.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gOuter;
        ctx.beginPath();
        ctx.arc(jet.x, jet.y, haloR, 0, Math.PI * 2);
        ctx.fill();

        // â”€â”€ Noyau lumineux â”€â”€
        const gCore = ctx.createRadialGradient(jet.x, jet.y, 0, jet.x, jet.y, coreR);
        gCore.addColorStop(0, '#FFFFFFEE');
        gCore.addColorStop(0.3, jet.color + 'DD');
        gCore.addColorStop(0.6, jet.color + '88');
        gCore.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gCore;
        ctx.beginPath();
        ctx.arc(jet.x, jet.y, coreR, 0, Math.PI * 2);
        ctx.fill();

        // â”€â”€ Particules scintillantes (LOD high uniquement) â”€â”€
        if (jLod < 2) { /* skip sparkles */ }
        else for (const sp of jet.sparkles) {
            const sx = jet.x + sp.offX * sparkScale;
            const sy = jet.y + sp.offY * sparkScale;
            const flicker = 0.4 + Math.sin(t * 8 + sp.phase) * 0.4;
            const sr = (sp.radius + 1) * flicker * sparkScale;

            ctx.fillStyle = '#FFFFFF' + hexAlpha(flicker * 0.8);
            ctx.beginPath();
            ctx.arc(sx, sy, sr, 0, Math.PI * 2);
            ctx.fill();

            // Petite lueur colorÃ©e autour
            ctx.fillStyle = jet.color + hexAlpha(flicker * 0.4);
            ctx.beginPath();
            ctx.arc(sx, sy, sr + 3 * sparkScale, 0, Math.PI * 2);
            ctx.fill();
        }

        // â”€â”€ Afficher le nombre de spores si sÃ©lectionnÃ© (clic) â”€â”€
        if (jet.selected) {
            ctx.font = '10px Orbitron';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(jet.spores), jet.x, jet.y - 18);
        }
    }
}

// Helper : alpha (0-1) â†’ hex string 2 chars
function hexAlpha(a) {
    return Math.floor(Math.min(1, Math.max(0, a)) * 255).toString(16).padStart(2, '0');
}

function drawLaunchPreview(ctx) {
    if (!gameState.launching || !gameState.launchSource) return;
    const src = gameState.launchSource;
    const preview = gameState.launchPreview;

    if (preview.length < 2) return;

    // Nombre de points Ã  afficher (70%)
    const count = Math.floor(preview.length * 0.7);

    ctx.save();
    ctx.setLineDash([4, 6]);
    const player = gameState.players[src.owner];
    const col = player ? player.color : '#C8A0FF';

    for (let i = 0; i < count - 1; i++) {
        const alpha = 0.5 * (1 - i / count);
        ctx.strokeStyle = col + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(preview[i].x, preview[i].y);
        ctx.lineTo(preview[i+1].x, preview[i+1].y);
        ctx.stroke();
    }
    ctx.restore();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INPUT â€” Zoom & Panoramique
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function setupInput() {
    const canvas = gameState.canvas;
    const cam = gameState.camera;
    const inp = gameState.input;

    // â”€â”€ Molette : Zoom â”€â”€
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const direction = e.deltaY > 0 ? -1 : 1;
        const factor = 1 + cam.zoomSpeed;
        const oldZoom = cam.zoom;
        const newZoom = direction > 0
            ? Math.min(cam.zoom * factor, cam.maxZoom)
            : Math.max(cam.zoom / factor, cam.minZoom);

        // Zoom vers le curseur
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Position monde sous le curseur avant zoom
        const worldX = (mx - gameState.width / 2) / oldZoom + cam.x;
        const worldY = (my - gameState.height / 2) / oldZoom + cam.y;

        cam.zoom = newZoom;

        // Ajuster la camÃ©ra pour que le point monde reste sous le curseur
        cam.x = worldX - (mx - gameState.width / 2) / newZoom;
        cam.y = worldY - (my - gameState.height / 2) / newZoom;
    }, { passive: false });

    // â”€â”€ Clic gauche maintenu : Lancement de jet â”€â”€
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0 && gameState.phase === 'game') {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const wx = (mx - gameState.width / 2) / cam.zoom + cam.x;
            const wy = (my - gameState.height / 2) / cam.zoom + cam.y;

            // Chercher un astre possÃ©dÃ© par le joueur humain
            const bodies = gameState.allBodies;
            for (const body of bodies) {
                if (body.owner !== 0) continue;
                const dx = body.x - wx;
                const dy = body.y - wy;
                if (Math.sqrt(dx*dx + dy*dy) < body.radius + 8) {
                    gameState.launching = true;
                    gameState.launchSource = body;
                    gameState.launchPreview = [];
                    gameState.launchStartTime = performance.now();
                    gameState.launchCameraLock = false;
                    break;
                }
            }
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (e.button === 0 && gameState.launching && gameState.launchSource) {
            const elapsed = performance.now() - (gameState.launchStartTime || 0);
            const src = gameState.launchSource;

            // Clic court = ouvrir le codex au lieu de lancer
            if (elapsed < 150) {
                gameState.launching = false;
                gameState.launchSource = null;
                gameState.launchPreview = [];
                gameState.launchCameraLock = false;
                openCodex(src);
                justLaunched = true;
                return;
            }

            const dx = gameState.mouseWorldX - src.x;
            const dy = gameState.mouseWorldY - src.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 10) {
                launchJet(src, dx/len, dy/len);
                justLaunched = true;
                
            }
            gameState.launching = false;
            gameState.launchSource = null;
            gameState.launchPreview = [];
            gameState.launchCameraLock = false;
        }
    });

    // â”€â”€ Clic droit : Panoramique â”€â”€
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 2 || e.button === 1) { // clic droit ou molette
            e.preventDefault();
            inp.isDragging = true;
            inp.dragStartX = e.clientX;
            inp.dragStartY = e.clientY;
            inp.cameraStartX = cam.x;
            // ArrÃªter le suivi de planÃ¨te
            if (typeof followingBody !== 'undefined') { followingBody = null; document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active')); }
            inp.cameraStartY = cam.y;
            canvas.classList.add('grabbing');
        }
    });

    window.addEventListener('mousemove', (e) => {
        inp.mouseX = e.clientX;
        inp.mouseY = e.clientY;

        // Position monde sous la souris
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        gameState.mouseWorldX = (mx - gameState.width / 2) / cam.zoom + cam.x;
        gameState.mouseWorldY = (my - gameState.height / 2) / cam.zoom + cam.y;

        // PrÃ©visualisation de lancement
        if (gameState.launching && gameState.launchSource && performance.now() - (gameState.launchStartTime||0) > 150) {
            if (!gameState.launchCameraLock) gameState.launchCameraLock = true;
            const src = gameState.launchSource;
            const dx = gameState.mouseWorldX - src.x;
            const dy = gameState.mouseWorldY - src.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 1) {
                const player = gameState.players[src.owner];
                const speed = 20 + (player ? player.stats.velocity * 6 : 0);
                gameState.launchPreview = computeTrajectory(src.x, src.y, dx/len, dy/len, speed, 400);
            }
        }

        if (inp.isDragging && !gameState.launchCameraLock) {
            const dx = e.clientX - inp.dragStartX;
            const dy = e.clientY - inp.dragStartY;
            cam.x = inp.cameraStartX - dx / cam.zoom;
            cam.y = inp.cameraStartY - dy / cam.zoom;
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (e.button === 2 || e.button === 1) {
            inp.isDragging = false;
            canvas.classList.remove('grabbing');
        }
    }, true);

    // â”€â”€ Clic gauche : spawn / codex â”€â”€
    let justLaunched = false;
    canvas.addEventListener('click', (e) => {
        if (e.button !== 0) return;
        if (justLaunched) { justLaunched = false; return; }
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const worldX = (mx - gameState.width / 2) / cam.zoom + cam.x;
        const worldY = (my - gameState.height / 2) / cam.zoom + cam.y;

        if (gameState.phase === 'spawn') {
            handleSpawnClick(worldX, worldY);
        } else if (gameState.phase === 'game') {
            // Chercher un jet sous le clic
            let clickedJet = false;
            for (const jet of gameState.jets) {
                jet.selected = false;
                const dx = jet.x - worldX, dy = jet.y - worldY;
                if (Math.sqrt(dx*dx+dy*dy) < 20) {
                    jet.selected = true;
                    clickedJet = true;
                }
            }
            if (!clickedJet) {
                // Chercher un astre sous le clic
                const body = findBodyAt(worldX, worldY);
                if (body) openCodex(body);
                else closeCodex();
            }
        }
    });

    // EmpÃªcher le menu contextuel
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());
}

function findBodyAt(wx, wy) {
    // Chercher lunes, puis planÃ¨tes, puis soleils (plus petit d'abord)
    for (const m of gameState.moons) {
        const dx = m.x - wx, dy = m.y - wy;
        if (dx*dx + dy*dy < (m.radius + 12) * (m.radius + 12)) return m;
    }
    for (const p of gameState.planets) {
        const dx = p.x - wx, dy = p.y - wy;
        if (dx*dx + dy*dy < (p.radius + 10) * (p.radius + 10)) return p;
    }
    for (const s of gameState.suns) {
        const dx = s.x - wx, dy = s.y - wy;
        if (dx*dx + dy*dy < (s.radius + 10) * (s.radius + 10)) return s;
    }
    return null;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// BOUCLE DE JEU
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function gameLoop(timestamp) {
    if (!gameState.running) return;

    // Delta time (en secondes)
    gameState.deltaTime = (timestamp - gameState.lastTime) / 1000;
    gameState.lastTime = timestamp;

    // Cap delta pour Ã©viter les sauts aprÃ¨s un onglet en arriÃ¨re-plan
    if (gameState.deltaTime > 0.1) gameState.deltaTime = 0.016;

    // FPS
    gameState.fpsFrames++;
    if (timestamp - gameState.fpsLastCheck >= 500) {
        gameState.fps = Math.round(gameState.fpsFrames / ((timestamp - gameState.fpsLastCheck) / 1000));
        gameState.fpsFrames = 0;
        gameState.fpsLastCheck = timestamp;
        if (DOM.fps) DOM.fps.textContent = gameState.fps + ' FPS';
    }

    // Update
    update(gameState.deltaTime);

    // Render
    render();

    requestAnimationFrame(gameLoop);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// UPDATE (logique de jeu)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function update(dt) {
    gameState.time += dt;
    if (gameState.phase === 'paused') return;
    updateLOD(dt);
    updateOrbits(dt);
    updateCosmicEffects(dt);
    updateSporeGeneration(dt);
    updateComets(dt);
    updateAI(dt);
    updateCleaners(dt);
    updateJets(dt);
    updateImpacts(dt);
    updateConquestEffects(dt);
    updateCameraFollow();
    // Mise Ã  jour HUD toutes les 5 frames (perf)
    gameState._hudCounter = (gameState._hudCounter || 0) + 1;
    if (gameState._hudCounter % 5 === 0) {
        updateMyPlanets();
        updateHUD();
        updateMultiPanel();
        checkVictoryAndElimination();
    }
    gameState.gameStats.timeElapsed += dt;
    updateAudioTension();
    updateOrbitHum();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// RENDER (dessin)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function render() {
    const ctx = gameState.ctx;
    const cam = gameState.camera;
    const w = gameState.width;
    const h = gameState.height;

    // â”€â”€ Effacer â”€â”€
    ctx.fillStyle = SKY_CFG._hex || '#16264E';
    ctx.fillRect(0, 0, w, h);

    // â”€â”€ Appliquer la transformation camÃ©ra â”€â”€
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.scale(cam.zoom, cam.zoom);
    ctx.translate(-cam.x, -cam.y);

    // â”€â”€ Fond spatial â”€â”€
    drawBackground(ctx);

    // â”€â”€ Particules & Ã©toiles filantes (LOD mid+) â”€â”€
    if (gameState.lod >= 1) drawCosmicEffects(ctx);

    // â”€â”€ ComÃ¨tes â”€â”€
    drawComets(ctx);

    // â”€â”€ Trou noir â”€â”€
    drawBlackHole(ctx);

    // â”€â”€ Soleils â”€â”€
    drawSuns(ctx);

    // â”€â”€ Amas de mÃ©tÃ©orites â”€â”€
    drawAsteroidBelts(ctx);

    // â”€â”€ PlanÃ¨tes & Lunes â”€â”€
    drawPlanets(ctx);

    // â”€â”€ Ã‰toiles premier plan (couche 3, devant soleils/planÃ¨tes) â”€â”€
    drawFrontStars(ctx);

    // â”€â”€ Vaisseaux nettoyeurs â”€â”€
    drawCleaners(ctx);

    // â”€â”€ Jets de spores â”€â”€
    drawJets(ctx);

    // â”€â”€ PrÃ©visualisation de lancement â”€â”€
    drawLaunchPreview(ctx);

    // â”€â”€ Impacts (LOD mid+) â”€â”€
    if (gameState.lod >= 1) drawImpacts(ctx);

    // â”€â”€ Effets de conquÃªte â”€â”€
    drawConquestEffects(ctx);

    // â”€â”€ Compteurs de spores sur les astres â”€â”€
    drawSporeCountOnBodies(ctx);

    ctx.restore();

    // â”€â”€ DÃ©bris premier plan (LOD mid+) â”€â”€
    if (gameState.lod >= 1) drawForegroundDebris(ctx);

    // â”€â”€ Indicateurs hors-Ã©cran (hors transformation camÃ©ra) â”€â”€
    drawOffscreenIndicators();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DESSIN â€” Fond spatial (tuilÃ©)
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBgLayer(ctx, layer) {
    if (!layer.img) return;
    if (layer.img.complete === false) return;
    const cam = gameState.camera;
    const S = layer.scale;
    const half = S / 2;
    const px = -half + cam.x * (1 - layer.parallax);
    const py = -half + cam.y * (1 - layer.parallax);
    ctx.drawImage(layer.img, px, py, S, S);
}

function drawFrontStars(ctx) {
}

function drawBackground(ctx) {
    for (let i = 0; i < BG_LAYERS.length; i++) drawBgLayer(ctx, BG_LAYERS[i]);
}
/* ancien drawBackground dÃ©sactivÃ© â€” couches PNG Ã  la place
    const t = gameState.time;

    // Helper parallaxe
    function prlx(obj) {
        return {
            x: obj.x + (cam.x - obj.x) * (1 - obj.parallax),
            y: obj.y + (cam.y - obj.y) * (1 - obj.parallax)
        };
    }

    // â”€â”€ Couche 0 : Ã‰toiles de base â”€â”€
    const _cfg = window._bgCfg || {};
    const lod = gameState.lod;
    if (_cfg.starsOn !== false && gameState.bgStarsCache) {
        const sc = gameState.bgStarsCache;
        const px = sc.offX + (cam.x - sc.offX) * (1 - sc.parallax);
        const py = sc.offY + (cam.y - sc.offY) * (1 - sc.parallax);
        ctx.drawImage(sc.canvas, px, py, sc.w, sc.h);
    }

    // â”€â”€ Couche 1 : Voiles galactiques (LOD mid+) â”€â”€
    if (_cfg.veilsOn !== false && lod >= 1)
    for (const v of gameState.bgVeils) {
        const p = prlx(v);
        const maxDim = Math.max(v.w, v.h);
        if (p.x < cam.x - halfW - maxDim || p.x > cam.x + halfW + maxDim ||
            p.y < cam.y - halfH - maxDim || p.y > cam.y + halfH + maxDim) continue;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(v.rotation);
        ctx.drawImage(v.texture, -v.w/2, -v.h/2, v.w, v.h);
        ctx.restore();
    }

    // â”€â”€ Couche 2 : NÃ©buleuses denses (LOD mid+) â”€â”€
    if (_cfg.nebOn !== false && lod >= 1)
    for (const neb of gameState.bgNebulae) {
        const p = prlx(neb);
        const dw = neb.texture.width / neb.texture.height * neb.radius * 1.4;
        const dh = neb.radius * 1.4;
        const maxD = Math.max(dw, dh);
        if (p.x < cam.x - halfW - maxD || p.x > cam.x + halfW + maxD ||
            p.y < cam.y - halfH - maxD || p.y > cam.y + halfH + maxD) continue;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(neb.rotation);
        ctx.drawImage(neb.texture, -dw, -dh, dw * 2, dh * 2);
        ctx.restore();
    }

    // â”€â”€ Couche 3 : Filaments (LOD mid+) â”€â”€
    if (_cfg.filOn !== false && lod >= 1)
    for (const f of gameState.bgFilaments) {
        const p = prlx(f);
        const maxDim = Math.max(f.w, f.h);
        if (p.x < cam.x - halfW - maxDim || p.x > cam.x + halfW + maxDim ||
            p.y < cam.y - halfH - maxDim || p.y > cam.y + halfH + maxDim) continue;
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate(f.rotation);
        ctx.drawImage(f.texture, -f.w/2, -f.h/2, f.w, f.h);
        ctx.restore();
    }

    // â”€â”€ Couche 4 : Amas stellaires (offscreen cache) â”€â”€
    if (_cfg.clusOn !== false)
    for (let ci = 0; ci < gameState.bgStarClusters.length; ci++) {
        const cl = gameState.bgStarClusters[ci];
        const p = prlx(cl);
        if (p.x < cam.x - halfW - 300 || p.x > cam.x + halfW + 300 ||
            p.y < cam.y - halfH - 300 || p.y > cam.y + halfH + 300) continue;
        const cc = gameState.bgClustersCache[ci];
        if (cc) {
            ctx.drawImage(cc.canvas, p.x + cc.offX, p.y + cc.offY, cc.w, cc.h);
        }
    }

    // â”€â”€ Couche 5 : Ã‰toiles brillantes premier plan â”€â”€
    if (_cfg.brightOn !== false && lod > 0)
    for (const s of gameState.bgBrightStars) {
        const p = prlx(s);
        if (p.x < cam.x - halfW - 20 || p.x > cam.x + halfW + 20 ||
            p.y < cam.y - halfH - 20 || p.y > cam.y + halfH + 20) continue;

        const flicker = 0.7 + Math.sin(t * 3 + s.phase) * 0.3;
        const a = s.alpha * flicker;

        // Halo depuis cache
        if (s._haloCache) {
            ctx.globalAlpha = a;
            const r = s.size * 5;
            ctx.drawImage(s._haloCache, p.x - r, p.y - r, r * 2, r * 2);
            ctx.globalAlpha = 1;
        }

        // Croix de diffraction (LOD high uniquement)
        if (s.hasDiffraction && lod >= 2) {
            ctx.strokeStyle = `rgba(${s.color}, ${a * 0.2})`;
            ctx.lineWidth = 0.6;
            const len = s.size * 8;
            ctx.beginPath();
            ctx.moveTo(p.x - len, p.y); ctx.lineTo(p.x + len, p.y);
            ctx.moveTo(p.x, p.y - len); ctx.lineTo(p.x, p.y + len);
            ctx.stroke();
            if (lod >= 2) {
                ctx.strokeStyle = `rgba(${s.color}, ${a * 0.1})`;
                ctx.beginPath();
                const d = len * 0.5;
                ctx.moveTo(p.x-d, p.y-d); ctx.lineTo(p.x+d, p.y+d);
                ctx.moveTo(p.x+d, p.y-d); ctx.lineTo(p.x-d, p.y+d);
                ctx.stroke();
            }
        }

        // Point central
        ctx.fillStyle = `rgba(${s.color}, ${a + 0.1})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, s.size, 0, Math.PI * 2);
        ctx.fill();
    }
} fin ancien drawBackground */


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DESSIN â€” Trou noir
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBlackHole(ctx) {
    const bh = gameState.blackHole;
    if (!bh) return;
    const t = gameState.time;
    const bhLod = gameState.lod;

    // Zone de danger (halo externe)
    const gDanger = ctx.createRadialGradient(0, 0, bh.radius, 0, 0, bh.dangerZone);
    gDanger.addColorStop(0, 'rgba(100, 40, 180, 0.25)');
    gDanger.addColorStop(0.5, 'rgba(60, 20, 120, 0.1)');
    gDanger.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gDanger;
    ctx.beginPath();
    ctx.arc(0, 0, bh.dangerZone, 0, Math.PI * 2);
    ctx.fill();

    // Disque d'accrÃ©tion rotatif (LOD mid+)
    if (bhLod >= 1) { ctx.save();
    ctx.rotate(t * 0.3);
    for (let i = 0; i < 3; i++) {
        const discR = bh.radius * (2 + i * 0.6);
        const alpha = 0.12 - i * 0.03;
        ctx.strokeStyle = `rgba(160, 80, 255, ${alpha})`;
        ctx.lineWidth = 3 - i * 0.8;
        ctx.beginPath();
        ctx.ellipse(0, 0, discR, discR * 0.35, i * 0.4, 0, Math.PI * 2);
        ctx.stroke();
    }
    ctx.restore();
    }

    // Lueur pulsante (LOD mid+)
    if (bhLod >= 1) { const pulse = 1 + Math.sin(t * 2) * 0.08;
    const gGlow = ctx.createRadialGradient(0, 0, bh.radius * 0.5, 0, 0, bh.radius * 2 * pulse);
    gGlow.addColorStop(0, 'rgba(120, 50, 200, 0.08)');
    gGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gGlow;
    ctx.beginPath();
    ctx.arc(0, 0, bh.radius * 2 * pulse, 0, Math.PI * 2);
    ctx.fill();

    }

    // Anneau de danger pulsant (LOD high)
    if (bhLod >= 2) { const dangerPulse = 0.5 + Math.sin(t * 1.5) * 0.3;
    ctx.strokeStyle = `rgba(255, 50, 50, ${0.08 * dangerPulse})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 10]);
    ctx.beginPath();
    ctx.arc(0, 0, bh.dangerZone * 0.4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    }

    // Trou noir (noyau)
    const gCore = ctx.createRadialGradient(0, 0, 0, 0, 0, bh.radius);
    gCore.addColorStop(0, '#000000');
    gCore.addColorStop(0.7, '#000000');
    gCore.addColorStop(1, 'rgba(80, 30, 140, 0.5)');
    ctx.fillStyle = gCore;
    ctx.beginPath();
    ctx.arc(0, 0, bh.radius, 0, Math.PI * 2);
    ctx.fill();
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DESSIN â€” Soleils
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawAsteroidBelts(ctx) {
    const t = gameState.time;
    for (const belt of gameState.asteroidBelts) {
        const sun = belt.sun;

        // TraÃ®nÃ©e orbitale (LOD mid+)
        if (gameState.lod >= 1) {
            ctx.strokeStyle = 'rgba(80,70,60,0.06)';
            ctx.lineWidth = 14;
            ctx.beginPath();
            ctx.arc(sun.x, sun.y, belt.radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        for (const rock of belt.rocks) {
            const a = rock.angle;
            const r = belt.radius + rock.radiusOff;
            const cx = sun.x + Math.cos(a) * r;
            const cy = sun.y + Math.sin(a) * r;

            for (let si = 0; si < rock.subRocks.length; si++) {
                const sr = rock.subRocks[si];
                const rx = cx + sr.offX;
                const ry = cy + sr.offY;
                const rot = t * 0.3 + si * 1.7 + rock.angle * 5;
                const sz = sr.size;

                // Polygone irrÃ©gulier (5-7 cÃ´tÃ©s)
                const sides = sr._sides || (sr._sides = 5 + Math.floor(Math.random() * 3));
                const verts = sr._verts || (sr._verts = Array.from({length: sides}, (_, i) => 0.7 + Math.random() * 0.6));

                ctx.save();
                ctx.translate(rx, ry);
                ctx.rotate(rot);

                // Ombre (cÃ´tÃ© sombre)
                ctx.fillStyle = sr.color;
                ctx.beginPath();
                for (let v = 0; v < sides; v++) {
                    const va = (v / sides) * Math.PI * 2;
                    const vr = sz * verts[v];
                    if (v === 0) ctx.moveTo(Math.cos(va) * vr, Math.sin(va) * vr);
                    else ctx.lineTo(Math.cos(va) * vr, Math.sin(va) * vr);
                }
                ctx.closePath();
                ctx.fill();

                // Reflet (demi-lune Ã©clairÃ©e)
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(sz * -0.2, sz * -0.2, sz * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();
            }

            // Lueur de groupe (LOD high)
            if (gameState.lod >= 2) {
                let haloColor;
                if (rock.type === 'dark') haloColor = 'rgba(60,55,50,0.06)';
                else if (rock.type === 'red') haloColor = 'rgba(120,50,40,0.06)';
                else haloColor = 'rgba(50,100,50,0.06)';
                ctx.fillStyle = haloColor;
                ctx.beginPath();
                ctx.arc(cx, cy, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawSuns(ctx) {
    const t = gameState.time;
    const cam = gameState.camera;
    const halfW = gameState.width / 2 / cam.zoom;
    const halfH = gameState.height / 2 / cam.zoom;

    for (let i = 0; i < gameState.suns.length; i++) {
        const sun = gameState.suns[i];

        // Culling
        const margin = sun.radius * 4;
        if (sun.x < cam.x - halfW - margin || sun.x > cam.x + halfW + margin ||
            sun.y < cam.y - halfH - margin || sun.y > cam.y + halfH + margin) continue;

        const pulse = 1 + Math.sin(t * 1.5 + i * 2) * 0.04;

        // Halo pulsant (depuis cache)
        if (sun._haloCache) {
            const drawR = sun._haloR * pulse;
            ctx.drawImage(sun._haloCache, sun.x - drawR, sun.y - drawR, drawR * 2, drawR * 2);
        }

        // Texture cachÃ©e
        if (sun._texture) {
            const texSize = sun._texture.width;
            const drawR = sun.radius * pulse;
            ctx.drawImage(sun._texture, sun.x - drawR, sun.y - drawR, drawR * 2, drawR * 2);
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// DESSIN â€” PlanÃ¨tes & Lunes
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawPlanets(ctx) {
    const cam = gameState.camera;
    const halfW = gameState.width / 2 / cam.zoom;
    const halfH = gameState.height / 2 / cam.zoom;

    for (let i = 0; i < gameState.planets.length; i++) {
        const p = gameState.planets[i];

        // Culling planÃ¨te + orbite
        const margin = p.orbitRadius + p.radius + 50;
        if (p.parent.x < cam.x - halfW - margin && p.parent.x > cam.x + halfW + margin &&
            p.parent.y < cam.y - halfH - margin && p.parent.y > cam.y + halfH + margin) continue;

        // Orbite (trait fin) â€” LOD mid+
        if (gameState.lod >= 1) {
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(p.parent.x, p.parent.y, p.orbitRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // PlanÃ¨te (texture cachÃ©e)
        if (p._texture) {
            ctx.drawImage(p._texture, p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2);
        }

        // Anneaux (gazeuses) â€” LOD mid+
        if (p._hasRings && gameState.lod >= 1) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.scale(1, p._ringTilt);
            ctx.strokeStyle = p._ringColor1;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 1.6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = p._ringColor2;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 1.9, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = p._ringColor1;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 2.15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // AtmosphÃ¨re (LOD mid+ uniquement)
        if (p._hasAtmosphere && gameState.lod >= 1) {
            const gAtmo = ctx.createRadialGradient(p.x, p.y, p.radius * 0.85, p.x, p.y, p.radius * 1.3);
            gAtmo.addColorStop(0, 'rgba(0,0,0,0)');
            gAtmo.addColorStop(0.5, p._atmoColor);
            gAtmo.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gAtmo;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * 1.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ã‰clairage directionnel (LOD high uniquement)
        if (p.parent && gameState.lod >= 2) {
            const ldx = p.parent.x - p.x;
            const ldy = p.parent.y - p.y;
            const ldist = Math.sqrt(ldx*ldx + ldy*ldy);
            if (ldist > 0) {
                const lnx = ldx / ldist;
                const lny = ldy / ldist;
                const lightX = p.x + lnx * p.radius * 0.4;
                const lightY = p.y + lny * p.radius * 0.4;
                const gLight = ctx.createRadialGradient(lightX, lightY, 0, p.x, p.y, p.radius);
                gLight.addColorStop(0, 'rgba(255,255,200,0.35)');
                gLight.addColorStop(0.5, 'rgba(0,0,0,0)');
                gLight.addColorStop(1, 'rgba(0,0,20,0.30)');
                ctx.fillStyle = gLight;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Halo de propriÃ©taire
        if (p.owner !== null && p.owner !== undefined) {
            const ownerColor = gameState.players[p.owner]?.color || '#FFF';
            ctx.strokeStyle = ownerColor;
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.5 + Math.sin(gameState.time * 2) * 0.15;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        // Lunes
        for (let j = 0; j < p.moons.length; j++) {
            const m = p.moons[j];

            // Culling lune
            if (m.x < cam.x - halfW - 20 || m.x > cam.x + halfW + 20 ||
                m.y < cam.y - halfH - 20 || m.y > cam.y + halfH + 20) continue;

            // Orbite de lune â€” LOD high
            if (gameState.lod >= 2) {
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.lineWidth = 0.3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, m.orbitRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Lune (texture cachÃ©e)
            if (m._texture) {
                ctx.drawImage(m._texture, m.x - m.radius, m.y - m.radius, m.radius * 2, m.radius * 2);
            } else {
                ctx.fillStyle = 'rgba(180, 180, 200, 0.7)';
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Halo propriÃ©taire lune
            if (m.owner !== null && m.owner !== undefined) {
                const ownerColor = gameState.players[m.owner]?.color || '#FFF';
                ctx.strokeStyle = ownerColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5 + Math.sin(gameState.time * 2) * 0.15;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius + 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// LANCEMENT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VAISSEAUX NETTOYEURS
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateCleaners(dt) {
    const bh = gameState.blackHole;

    for (const cl of gameState.cleaners) {
        // Mouvement : naviguer vers une planÃ¨te cible
        cl.turnTimer -= dt;
        if (cl.turnTimer <= 0) {
            cl.turnTimer = CLN_CFG.turnInterval + Math.random() * 5;
            const speed = CLN_CFG.speedMin + Math.random() * (CLN_CFG.speedMax - CLN_CFG.speedMin);
            // 70% chance de viser une planÃ¨te, 30% errance locale
            if (Math.random() < 0.7 && gameState.planets.length > 0) {
                const target = gameState.planets[Math.floor(Math.random() * gameState.planets.length)];
                cl._target = target;
                const tdx = target.x - cl.x;
                const tdy = target.y - cl.y;
                const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
                if (tDist > 0) {
                    cl.vx = (tdx / tDist) * speed;
                    cl.vy = (tdy / tDist) * speed;
                }
            } else {
                cl._target = null;
                const wanderAngle = Math.atan2(cl.y, cl.x) + (Math.random() - 0.5) * 1.5;
                cl.vx = Math.cos(wanderAngle) * speed * 0.5;
                cl.vy = Math.sin(wanderAngle) * speed * 0.5;
            }
        }

        // Si on a une cible, ajuster la direction en temps rÃ©el (la planÃ¨te bouge)
        if (cl._target) {
            const tdx = cl._target.x - cl.x;
            const tdy = cl._target.y - cl.y;
            const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
            if (tDist < 80) {
                cl.turnTimer = 0;
            } else if (tDist > 0) {
                const currentSpeed = Math.sqrt(cl.vx * cl.vx + cl.vy * cl.vy);
                cl.vx += (tdx / tDist) * 15 * dt;
                cl.vy += (tdy / tDist) * 15 * dt;
                const newSpeed = Math.sqrt(cl.vx * cl.vx + cl.vy * cl.vy);
                if (newSpeed > currentSpeed * 1.2) {
                    cl.vx = (cl.vx / newSpeed) * currentSpeed;
                    cl.vy = (cl.vy / newSpeed) * currentSpeed;
                }
            }
        }

        cl.x += cl.vx * dt;
        cl.y += cl.vy * dt;

        // Repousser du trou noir
        const bhDx = cl.x - bh.x;
        const bhDy = cl.y - bh.y;
        const bhDist = Math.sqrt(bhDx * bhDx + bhDy * bhDy);
        if (bhDist < bh.dangerZone * 2) {
            cl.vx += (bhDx / bhDist) * 30 * dt;
            cl.vy += (bhDy / bhDist) * 30 * dt;
        }

        // Garder dans la zone de jeu (orbite du soleil le plus Ã©loignÃ© + marge)
        let maxRange = 500;
        for (const sun of gameState.suns) {
            const lastP = sun.planets[sun.planets.length - 1];
            const total = sun.orbitRadius + (lastP ? lastP.orbitRadius : 0) + 100;
            if (total > maxRange) maxRange = total;
        }
        const distFromCenter = Math.sqrt(cl.x * cl.x + cl.y * cl.y);
        if (distFromCenter > maxRange) {
            cl.vx -= cl.x * 0.02;
            cl.vy -= cl.y * 0.02;
        }

        // Tirer sur les jets Ã  portÃ©e
        cl.fireTimer -= dt;
        if (cl.fireTimer <= 0) {
            cl.fireTimer = CLN_CFG.fireRate;
            for (const jet of gameState.jets) {
                if (!jet.alive) continue;
                const dx = jet.x - cl.x;
                const dy = jet.y - cl.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < CLN_CFG.detectRange) {
                    playCleanerSound(cl.x, cl.y);

                    if (cl.type === 'red') {
                        // Rouge : attaque classique, rÃ©duit les spores
                        const damage = CLN_CFG.dmgMin + Math.random() * (CLN_CFG.dmgMax - CLN_CFG.dmgMin);
                        jet.spores -= damage;
                        if (jet.spores <= 0) jet.alive = false;
                        gameState.conquestEffects.push({
                            x: jet.x, y: jet.y - 10, baseX: jet.x,
                            text: '-' + Math.floor(damage),
                            color: '#FF4444', age: 0, maxAge: 1.5
                        });
                    } else if (cl.type === 'green') {
                        // Vert : multiplie les spores par 2 (une seule fois)
                        if (!jet._boosted) {
                            jet.spores = Math.floor(jet.spores * 2);
                            jet._boosted = true;
                            gameState.conquestEffects.push({
                                x: jet.x, y: jet.y - 10, baseX: jet.x,
                                text: 'x2',
                                color: '#44FF44', age: 0, maxAge: 1.5
                            });
                        }
                    } else if (cl.type === 'dark') {
                        // Noir : renvoie les spores vers la planÃ¨te d'origine
                        if (jet.source && jet.source.owner !== null) {
                            const src = jet.source;
                            const returnSpores = jet.spores;
                            // CrÃ©er un jet retour hostile (owner = -1, neutre hostile)
                            const rdx = src.x - jet.x;
                            const rdy = src.y - jet.y;
                            const rDist = Math.sqrt(rdx * rdx + rdy * rdy);
                            if (rDist > 0) {
                                const traj = computeTrajectory(jet.x, jet.y, rdx / rDist, rdy / rDist, jet.speed * 1.2, 400);
                                gameState.jets.push({
                                    owner: -1,
                                    color: '#333333',
                                    spores: returnSpores,
                                    trajectory: traj,
                                    posIndex: 0,
                                    x: jet.x, y: jet.y,
                                    speed: jet.speed * 1.2,
                                    alive: true,
                                    trail: [],
                                    sparkles: [],
                                    age: 0,
                                    selected: false,
                                    source: null,
                                    _targetBody: src
                                });
                            }
                            jet.alive = false;
                            gameState.conquestEffects.push({
                                x: jet.x, y: jet.y - 10, baseX: jet.x,
                                text: 'â†© RENVOI',
                                color: '#888888', age: 0, maxAge: 1.5
                            });
                        }
                    }
                    break; // un tir par cycle
                }
            }
        }
    }
}

function drawCleaners(ctx) {
    const t = gameState.time;
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    for (const cl of gameState.cleaners) {
        // Direction de mouvement
        const moveAngle = Math.atan2(cl.vy, cl.vx);

        ctx.save();
        ctx.translate(cl.x, cl.y);
        ctx.rotate(moveAngle);

        // Couleurs selon type
        const s = cl.size * scale;
        let fillColor, strokeColor, reactorC1, reactorC2, detectColor, accentColor;
        if (cl.type === 'green') {
            fillColor = 'rgba(70, 75, 65, 0.8)';
            strokeColor = 'rgba(100, 110, 90, 0.5)';
            accentColor = 'rgba(80, 220, 80, 0.7)';
            reactorC1 = 'rgba(60, 180, 80, 0.4)';
            reactorC2 = 'rgba(40, 120, 50, 0.15)';
            detectColor = 'rgba(60, 180, 60, 0.06)';
        } else if (cl.type === 'dark') {
            fillColor = 'rgba(55, 55, 65, 0.8)';
            strokeColor = 'rgba(80, 80, 100, 0.5)';
            accentColor = 'rgba(140, 140, 170, 0.7)';
            reactorC1 = 'rgba(90, 90, 130, 0.4)';
            reactorC2 = 'rgba(50, 50, 80, 0.15)';
            detectColor = 'rgba(100, 100, 130, 0.06)';
        } else {
            fillColor = 'rgba(85, 60, 55, 0.8)';
            strokeColor = 'rgba(120, 80, 70, 0.5)';
            accentColor = 'rgba(220, 70, 60, 0.7)';
            reactorC1 = 'rgba(200, 80, 50, 0.4)';
            reactorC2 = 'rgba(150, 40, 30, 0.15)';
            detectColor = 'rgba(200, 60, 50, 0.06)';
        }

        // Corps du vaisseau (dÃ©taillÃ©)
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.moveTo(s * 1.8, 0);           // Nez
        ctx.lineTo(s * 0.6, -s * 0.3);    // Avant haut
        ctx.lineTo(-s * 0.2, -s * 0.9);   // Aile haute
        ctx.lineTo(-s * 0.8, -s * 0.7);   // ArriÃ¨re aile haute
        ctx.lineTo(-s * 0.6, -s * 0.2);   // Jonction haute
        ctx.lineTo(-s, 0);                 // ArriÃ¨re centre
        ctx.lineTo(-s * 0.6, s * 0.2);    // Jonction basse
        ctx.lineTo(-s * 0.8, s * 0.7);    // ArriÃ¨re aile basse
        ctx.lineTo(-s * 0.2, s * 0.9);    // Aile basse
        ctx.lineTo(s * 0.6, s * 0.3);     // Avant bas
        ctx.closePath();
        ctx.fill();

        // Contour lumineux
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 1 * scale;
        ctx.stroke();

        // Cockpit (bulle centrale avec touche de couleur)
        ctx.fillStyle = 'rgba(200,220,255,0.2)';
        ctx.beginPath();
        ctx.ellipse(s * 0.5, 0, s * 0.4, s * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = accentColor;
        ctx.beginPath();
        ctx.ellipse(s * 0.5, 0, s * 0.25, s * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bandes de couleur sur les ailes
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 1.5 * scale;
        ctx.beginPath();
        ctx.moveTo(-s * 0.1, -s * 0.6);
        ctx.lineTo(-s * 0.5, -s * 0.65);
        ctx.moveTo(-s * 0.1, s * 0.6);
        ctx.lineTo(-s * 0.5, s * 0.65);
        ctx.stroke();

        // LumiÃ¨res d'aile clignotantes
        const blink = Math.sin(t * 5 + cl.angle * 10) > 0.3 ? 1 : 0.2;
        ctx.fillStyle = accentColor.replace(/[\d.]+\)$/, (blink * 0.8) + ')');
        ctx.beginPath();
        ctx.arc(-s * 0.2, -s * 0.7, s * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-s * 0.2, s * 0.7, s * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // RÃ©acteur (lueur arriÃ¨re avec traÃ®nÃ©e)
        const gReactor = ctx.createRadialGradient(-s, 0, 0, -s, 0, s * 2);
        gReactor.addColorStop(0, reactorC1);
        gReactor.addColorStop(0.4, reactorC2);
        gReactor.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gReactor;
        ctx.beginPath();
        ctx.arc(-s, 0, s * 2, 0, Math.PI * 2);
        ctx.fill();

        // TraÃ®nÃ©e de propulsion
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = reactorC1;
        for (let ti = 1; ti <= 3; ti++) {
            const trailS = s * (0.3 / ti);
            ctx.beginPath();
            ctx.arc(-s * (1 + ti * 0.8), 0, trailS, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.restore();

        // Cercle de dÃ©tection â€” LOD mid+ (pulsant)
        if (gameState.lod >= 1) {
            const dPulse = 0.5 + Math.sin(t * 2 + cl.angle) * 0.5;
            ctx.strokeStyle = detectColor;
            ctx.lineWidth = 0.5 + dPulse * 0.5;
            ctx.setLineDash([4 + dPulse * 2, 8 - dPulse * 2]);
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Remplissage subtil
            ctx.fillStyle = detectColor.replace('0.06', '0.02');
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pulsation d'alerte â€” LOD high
        if (gameState.lod >= 2) {
            const pulse = Math.sin(t * 3) * 0.5 + 0.5;
            const pulseColor = cl.type === 'green' ? `rgba(50,255,50,${0.03*pulse})` :
                               cl.type === 'dark' ? `rgba(120,120,150,${0.03*pulse})` :
                               `rgba(255,50,50,${0.03*pulse})`;
            ctx.fillStyle = pulseColor;
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INTELLIGENCE ARTIFICIELLE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAI(dt) {
    const difficulty = gameState.config.difficulty;

    for (const player of gameState.players) {
        if (player.isHuman || !player.alive) continue;
        if (player.bodies.length === 0) continue;

        // IA sacrifice pour multiplicitÃ©
        if (player.multiSacrifice === 0 && player.multiTier < 10) {
            player.multiSacrifice = 15 + Math.floor(Math.random() * 20);
        }

        // IA : gestion nids/biomes (vÃ©rifier Ã  chaque frame, pas seulement au timer)
        for (const body of player.bodies) {
            if (body.buildMode === 'off' && body.spores > body.maxSpores * 0.7) {
                // Activer un mode selon la stratÃ©gie : plus de nids si peu de planÃ¨tes, biomes sinon
                body.buildMode = player.bodies.length < 4 ? 'nid' : (Math.random() > 0.5 ? 'nid' : 'biome');
            }
        }

        player.aiTimer -= dt;
        if (player.aiTimer > 0) continue;

        // Reset timer
        player.aiTimer = player.aiCooldown + Math.random() * player.aiCooldown * 0.5;

        // DÃ©cider d'une action
        if (difficulty === 'easy') aiActionEasy(player);
        else if (difficulty === 'normal') aiActionNormal(player);
        else aiActionBrutal(player);
    }
}

// â”€â”€ IA Facile : cible alÃ©atoire, pas d'anticipation â”€â”€
function aiActionEasy(player) {
    // Choisir un astre source avec des spores
    const sources = player.bodies.filter(b => b.spores > 20);
    if (sources.length === 0) return;
    const source = sources[Math.floor(Math.random() * sources.length)];

    // Choisir une cible alÃ©atoire (neutre ou ennemie)
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;
    const target = targets[Math.floor(Math.random() * targets.length)];

    aiLaunchAt(source, target, player);
}

// â”€â”€ IA Normale : Ã©value les cibles, interception basique â”€â”€
function aiActionNormal(player) {
    const sources = player.bodies.filter(b => b.spores > 30);
    if (sources.length === 0) return;

    // Ã‰valuer les cibles
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;

    let bestTarget = null;
    let bestScore = -Infinity;

    for (const target of targets) {
        // Trouver la source la plus proche
        let minDist = Infinity;
        let closestSource = null;
        for (const src of sources) {
            const dx = target.x - src.x;
            const dy = target.y - src.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) { minDist = dist; closestSource = src; }
        }

        // Score : Flore haute + Faune faible + proximitÃ©
        const score = (target.flore || 0) * 2
            - (target.faune || 0) * 1
            - minDist * 0.05
            + (target.owner === null ? 50 : 0); // prÃ©fÃ©rer les neutres

        if (score > bestScore) {
            bestScore = score;
            bestTarget = target;
        }
    }

    if (!bestTarget) return;

    // Trouver la meilleure source pour cette cible
    let bestSource = sources[0];
    let bestDist = Infinity;
    for (const src of sources) {
        const dx = bestTarget.x - src.x;
        const dy = bestTarget.y - src.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < bestDist) { bestDist = dist; bestSource = src; }
    }

    aiLaunchAt(bestSource, bestTarget, player);
}

// â”€â”€ IA Brutale : interception parfaite, coordination, micro-gestion â”€â”€
function aiActionBrutal(player) {
    const sources = player.bodies.filter(b => b.spores > 25);
    if (sources.length === 0) return;

    // Ã‰valuer les cibles avec anticipation orbitale
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;

    let bestTarget = null;
    let bestScore = -Infinity;

    for (const target of targets) {
        let minDist = Infinity;
        for (const src of sources) {
            const dx = target.x - src.x;
            const dy = target.y - src.y;
            minDist = Math.min(minDist, Math.sqrt(dx * dx + dy * dy));
        }

        // Score avancÃ©
        const floreFactor = (target.flore || 0) * 3;
        const faunePenalty = (target.faune || 0) * 0.5;
        const distPenalty = minDist * 0.03;
        const ownerBonus = target.owner === null ? 40 : 20;
        const sporePenalty = (target.spores || 0) * 0.3;

        // Bonus si c'est un astre du joueur humain (agressif)
        const humanBonus = target.owner === 0 ? 60 : 0;

        const score = floreFactor - faunePenalty - distPenalty + ownerBonus - sporePenalty + humanBonus;

        if (score > bestScore) {
            bestScore = score;
            bestTarget = target;
        }
    }

    if (!bestTarget) return;

    // Coordination : lancer depuis plusieurs sources si possible
    const attackSources = [];
    for (const src of sources) {
        const dx = bestTarget.x - src.x;
        const dy = bestTarget.y - src.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1500) attackSources.push({ src, dist });
    }

    // Trier par distance
    attackSources.sort((a, b) => a.dist - b.dist);

    // Lancer depuis les 1 Ã  3 sources les plus proches
    const count = Math.min(attackSources.length, 1 + Math.floor(Math.random() * 3));
    for (let i = 0; i < count; i++) {
        const src = attackSources[i].src;
        // Garder une rÃ©serve dÃ©fensive (30% des spores)
        if (src.spores < 40) continue;
        aiLaunchAt(src, bestTarget, player);
    }
}

// â”€â”€ Lancement IA avec anticipation d'orbite â”€â”€
function aiLaunchAt(source, target, player) {
    // PrÃ©dire la position future de la cible
    const dx = target.x - source.x;
    const dy = target.y - source.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 20 + player.stats.velocity * 6;
    const travelTime = dist / speed * 0.4; // estimation grossiÃ¨re

    // Anticiper l'orbite (seulement IA normale et brutale)
    let futureX = target.x;
    let futureY = target.y;

    if (gameState.config.difficulty !== 'easy' && target.parent) {
        const futureAngle = target.angle + target.orbitSpeed * travelTime;
        futureX = target.parent.x + Math.cos(futureAngle) * target.orbitRadius;
        futureY = target.parent.y + Math.sin(futureAngle) * target.orbitRadius;

        // IA Brutale : anticiper aussi l'orbite du parent (soleil)
        if (gameState.config.difficulty === 'brutal' && target.parent.parent) {
            // Le parent est une planÃ¨te, son parent est un soleil
            const parentFutureAngle = target.parent.angle + target.parent.orbitSpeed * travelTime;
            const parentFutureX = target.parent.parent.x + Math.cos(parentFutureAngle) * target.parent.orbitRadius;
            const parentFutureY = target.parent.parent.y + Math.sin(parentFutureAngle) * target.parent.orbitRadius;
            futureX = parentFutureX + Math.cos(futureAngle) * target.orbitRadius;
            futureY = parentFutureY + Math.sin(futureAngle) * target.orbitRadius;
        } else if (gameState.config.difficulty === 'brutal' && target.parent.orbitRadius) {
            // Le parent est un soleil qui orbite le trou noir
            const sunFutureAngle = target.parent.angle + target.parent.orbitSpeed * travelTime;
            const sunFutureX = Math.cos(sunFutureAngle) * target.parent.orbitRadius;
            const sunFutureY = Math.sin(sunFutureAngle) * target.parent.orbitRadius;
            futureX = sunFutureX + Math.cos(futureAngle) * target.orbitRadius;
            futureY = sunFutureY + Math.sin(futureAngle) * target.orbitRadius;
        }
    }

    const aimDx = futureX - source.x;
    const aimDy = futureY - source.y;
    const aimLen = Math.sqrt(aimDx * aimDx + aimDy * aimDy);
    if (aimLen < 5) return;

    launchJet(source, aimDx / aimLen, aimDy / aimLen);
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFETS VISUELS â€” Impacts
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function spawnImpact(x, y, color) {
    const particles = [];
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
        const speed = 30 + Math.random() * 50;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.5 + Math.random() * 0.5,
            age: 0,
            size: 1 + Math.random() * 2
        });
    }
    gameState.impactEffects.push({
        x: x, y: y, color: color,
        shockwave: 0,
        particles: particles,
        age: 0, maxAge: 1.2
    });
}

function updateImpacts(dt) {
    for (let i = gameState.impactEffects.length - 1; i >= 0; i--) {
        const imp = gameState.impactEffects[i];
        imp.age += dt;
        imp.shockwave += dt * 80;

        for (const p of imp.particles) {
            p.age += dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.95;
            p.vy *= 0.95;
        }

        if (imp.age >= imp.maxAge) gameState.impactEffects.splice(i, 1);
    }
}

function drawImpacts(ctx) {
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    for (const imp of gameState.impactEffects) {
        const progress = imp.age / imp.maxAge;
        const alpha = 1 - progress;

        // Onde de choc
        ctx.strokeStyle = imp.color + hexAlpha(alpha * 0.5);
        ctx.lineWidth = 2 * scale * (1 - progress);
        ctx.beginPath();
        ctx.arc(imp.x, imp.y, imp.shockwave, 0, Math.PI * 2);
        ctx.stroke();

        // Flash central
        if (progress < 0.2) {
            const flashA = (1 - progress / 0.2) * 0.5;
            const gFlash = ctx.createRadialGradient(imp.x, imp.y, 0, imp.x, imp.y, 15 * scale);
            gFlash.addColorStop(0, '#FFFFFF' + hexAlpha(flashA));
            gFlash.addColorStop(0.5, imp.color + hexAlpha(flashA * 0.5));
            gFlash.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gFlash;
            ctx.beginPath();
            ctx.arc(imp.x, imp.y, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Particules Ã©clats
        for (const p of imp.particles) {
            if (p.age >= p.life) continue;
            const pAlpha = (1 - p.age / p.life) * 0.8;
            const pSize = p.size * scale * (1 - p.age / p.life);

            ctx.fillStyle = '#FFFFFF' + hexAlpha(pAlpha);
            ctx.beginPath();
            ctx.arc(p.x, p.y, pSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = imp.color + hexAlpha(pAlpha * 0.5);
            ctx.beginPath();
            ctx.arc(p.x, p.y, pSize + 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// EFFETS VISUELS â€” ConquÃªte & Ã‰closion
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateConquestEffects(dt) {
    // Textes flottants (style MMO : empilement sans superposition)
    for (let i = gameState.conquestEffects.length - 1; i >= 0; i--) {
        const e = gameState.conquestEffects[i];
        e.age += dt;

        // Vitesse de montÃ©e : rapide au dÃ©but, puis ralentit
        if (e.age < 0.3) {
            e.y -= 80 * dt; // burst initial rapide
        } else {
            e.y -= 12 * dt; // lent ensuite
        }

        if (e.age >= e.maxAge) gameState.conquestEffects.splice(i, 1);
    }

    // Pousser les anciens vers le haut quand un nouveau apparaÃ®t au mÃªme endroit
    const effects = gameState.conquestEffects;
    const spacing = 18;
    for (let i = effects.length - 1; i >= 0; i--) {
        for (let j = i - 1; j >= 0; j--) {
            // MÃªme zone horizontale ?
            if (Math.abs(effects[i].baseX - effects[j].baseX) < 30) {
                const gap = effects[i].y - effects[j].y;
                if (gap > -spacing) {
                    effects[j].y = effects[i].y - spacing;
                }
            }
        }
    }
    // Ã‰closions
    for (let i = gameState.bloomEffects.length - 1; i >= 0; i--) {
        const e = gameState.bloomEffects[i];
        e.age += dt;
        if (e.age >= e.maxAge) gameState.bloomEffects.splice(i, 1);
    }
}

function drawConquestEffects(ctx) {
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    // Ã‰closions (cercle expansif)
    for (const e of gameState.bloomEffects) {
        const progress = e.age / e.maxAge;
        const r = e.body.radius * (1 + progress * 3);
        const alpha = (1 - progress) * 0.4;
        ctx.strokeStyle = e.color + hexAlpha(alpha);
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.arc(e.body.x, e.body.y, r, 0, Math.PI * 2);
        ctx.stroke();

        // Flash interne
        if (progress < 0.3) {
            const flashAlpha = (1 - progress / 0.3) * 0.3;
            const gFlash = ctx.createRadialGradient(e.body.x, e.body.y, 0, e.body.x, e.body.y, e.body.radius);
            gFlash.addColorStop(0, e.color + hexAlpha(flashAlpha));
            gFlash.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gFlash;
            ctx.beginPath();
            ctx.arc(e.body.x, e.body.y, e.body.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Textes flottants
    for (const e of gameState.conquestEffects) {
        const alpha = 1 - (e.age / e.maxAge);
        ctx.font = (11 * scale) + 'px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillStyle = e.color + hexAlpha(alpha);
        ctx.fillText(e.text, e.x, e.y);
    }
}

function drawSporeCountOnBodies(ctx) {
    const z = gameState.camera.zoom;
    if (z < 0.4) return; // trop dÃ©zoomÃ©, pas lisible
    const scale = Math.max(1, 0.8 / z);

    const bodies = gameState.allBodies;
    for (const body of bodies) {
        if (body.owner === null) continue;
        if (body.spores < 1) continue;
        const col = gameState.players[body.owner]?.color || '#FFF';
        ctx.font = (8 * scale) + 'px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillStyle = col + 'BB';
        ctx.fillText(Math.floor(body.spores), body.x, body.y + body.radius + 10 * scale);
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// VICTOIRE / Ã‰LIMINATION
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function checkVictoryAndElimination() {
    if (gameState.phase !== 'game') return;

    const totalBodies = gameState.planets.length + gameState.moons.length;

    for (const player of gameState.players) {
        if (!player.alive) continue;

        // Compter les astres
        const ownedCount = player.bodies.length;

        // VÃ©rifier Ã©limination
        if (ownedCount === 0) {
            const hasJets = gameState.jets.some(j => j.alive && j.owner === player.id);
            if (!hasJets) {
                player.alive = false;
                if (player.isHuman) {
                    showEndScreen(false);
                    return;
                }
            }
        }

        // VÃ©rifier victoire (80% de la masse)
        const pct = ownedCount / totalBodies;
        if (pct >= 0.8) {
            if (player.isHuman) {
                showEndScreen(true);
            } else {
                showEndScreen(false);
            }
            return;
        }
    }
}

function showEndScreen(isVictory) {
    gameState.phase = 'end';

    const title = document.getElementById('endTitle');
    title.textContent = isVictory ? 'VICTOIRE' : 'DÃ‰FAITE';
    title.className = isVictory ? 'victory' : 'defeat';

    const sub = document.getElementById('endSubtitle');
    const human = gameState.players[0];
    const totalBodies = gameState.planets.length + gameState.moons.length;
    const ownedPct = Math.round((human.bodies.length / totalBodies) * 100);
    sub.textContent = isVictory
        ? 'Vous contrÃ´lez ' + ownedPct + '% de l\'univers !'
        : 'Votre empire s\'est effondrÃ©...';

    const stats = gameState.gameStats;
    stats.timeElapsed = gameState.time;
    const minutes = Math.floor(stats.timeElapsed / 60);
    const seconds = Math.floor(stats.timeElapsed % 60);

    document.getElementById('endStats').innerHTML = `
        <div class="end-stat-row"><span>Astres conquis</span><span class="end-stat-val">${stats.bodiesConquered}</span></div>
        <div class="end-stat-row"><span>Jets lancÃ©s</span><span class="end-stat-val">${stats.jetsLaunched}</span></div>
        <div class="end-stat-row"><span>Jets neutralisÃ©s</span><span class="end-stat-val">${stats.jetsNeutralized}</span></div>
        <div class="end-stat-row"><span>Spores produites</span><span class="end-stat-val">${Math.floor(stats.sporesProduced)}</span></div>
        <div class="end-stat-row"><span>Astres possÃ©dÃ©s</span><span class="end-stat-val">${human.bodies.length} / ${totalBodies}</span></div>
        <div class="end-stat-row"><span>DurÃ©e</span><span class="end-stat-val">${minutes}m ${seconds}s</span></div>
    `;

    document.getElementById('endScreen').classList.add('active');
    stopAmbiance();
    if (isVictory) playVictorySound();
    else playDefeatSound();

    // Sauvegarder la partie dans Supabase
    saveGame(isVictory, stats, human, totalBodies);
}

async function saveGame(isVictory, stats, human, totalBodies) {
    if (!currentUser) return;
    try {
        await _supa.from('games').insert({
            player_id: currentUser.id,
            won: isVictory,
            score: human.bodies.length,
            planets_captured: stats.bodiesConquered,
            duration_seconds: Math.floor(stats.timeElapsed),
            players_count: gameState.players.length,
            suns_count: gameState.suns.length
        });
    } catch (e) {
        console.warn('Erreur sauvegarde partie:', e);
    }
}

function hideEndScreen() {
    document.getElementById('endScreen').classList.remove('active');
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MES PLANÃˆTES â€” Liste latÃ©rale + suivi camÃ©ra
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let followingBody = null;

function isSystemComplete(sun, ownerID) {
    for (const planet of sun.planets) {
        if (planet.owner !== ownerID) return false;
        for (const moon of planet.moons) {
            if (moon.owner !== ownerID) return false;
        }
    }
    return sun.planets.length > 0;
}

function updateMyPlanets() {
    if (gameState.phase !== 'game') return;
    const human = gameState.players[0];
    if (!human) return;

    const container = document.getElementById('myPlanetsList');
    const panel = document.getElementById('myPlanets');
    panel.style.display = 'block';

    // RÃ©cupÃ©rer les astres possÃ©dÃ©s
    const myBodies = gameState.allBodies.filter(b => b.owner === 0);

    // Grouper par systÃ¨me solaire
    const groups = {};
    const groupSuns = {};
    for (const body of myBodies) {
        let sunRef, sunName;
        if (body.type === 'planet') {
            sunRef = body.parent;
            sunName = body.parent.name;
        } else {
            sunRef = body.parent.parent || null;
            sunName = sunRef ? sunRef.name : 'Inconnu';
        }
        if (!groups[sunName]) { groups[sunName] = []; groupSuns[sunName] = sunRef; }
        groups[sunName].push(body);
    }

    // Ne reconstruire que si le nombre a changÃ©
    if (container.dataset.count !== String(myBodies.length)) {
        container.dataset.count = String(myBodies.length);
        container.innerHTML = '';

        for (const sunName of Object.keys(groups)) {
            const bodies = groups[sunName];

            const groupEl = document.createElement('div');
            groupEl.className = 'mp-sun-group';

            const sunLabel = document.createElement('div');
            sunLabel.className = 'mp-sun-label';
            const sunRef = groupSuns[sunName];
            const complete = sunRef && isSystemComplete(sunRef, 0);
            sunLabel.title = complete ? 'SystÃ¨me complet ! Bonus +3% de production actif' : 'Colonisez toutes les planÃ¨tes et lunes de ce systÃ¨me pour un bonus +3% de production';
            sunLabel.innerHTML = '\u2600 ' + sunName + (complete ? '<span class="sys-complete" title="SystÃ¨me complet : +3% de vitesse de production de spores sur toutes les planÃ¨tes et lunes"> â˜… +3%</span>' : '');
            groupEl.appendChild(sunLabel);

            // SÃ©lecteur Nid/Biome/Off pour tout le systÃ¨me
            const buildRow = document.createElement('div');
            buildRow.style.cssText = 'display:flex; gap:4px; padding:2px 4px 4px; align-items:center;';
            ['off','nid','biome'].forEach(mode => {
                const btn = document.createElement('span');
                btn.textContent = mode === 'off' ? 'Off' : mode === 'nid' ? 'Nid' : 'Biome';
                btn.style.cssText = 'font-size:8px; padding:1px 5px; border-radius:3px; cursor:pointer; border:1px solid rgba(100,70,180,0.3); color:rgba(200,200,220,0.6); background:rgba(100,70,180,0.1); font-family:Exo 2,sans-serif;';
                btn.addEventListener('click', () => {
                    for (const b of bodies) {
                        b.buildMode = mode;
                        if (mode === 'off') b.buildProgress = 0;
                    }
                });
                buildRow.appendChild(btn);
            });
            groupEl.appendChild(buildRow);

            const rowEl = document.createElement('div');
            rowEl.className = 'mp-row';

            for (const body of bodies) {
                const item = document.createElement('div');
                item.className = 'mp-item';
                item.dataset.bodyName = body.name;

                // Nom au-dessus
                const nameEl = document.createElement('div');
                nameEl.className = 'mp-name';
                nameEl.textContent = body.name;
                item.appendChild(nameEl);

                // Badge type
                const badge = document.createElement('div');
                badge.className = 'mp-type-badge ' + (body.type === 'planet' ? 'planet-badge' : 'moon-badge');
                badge.textContent = body.type === 'planet' ? 'PLAN\u00c8TE' : 'LUNE';
                item.appendChild(badge);

                // Mini-aperÃ§u
                if (body._texture) {
                    const preview = document.createElement('canvas');
                    const size = 38;
                    preview.width = size;
                    preview.height = size;
                    const pctx = preview.getContext('2d');
                    pctx.drawImage(body._texture, 0, 0, size, size);
                    item.appendChild(preview);
                } else {
                    const dot = document.createElement('div');
                    dot.style.cssText = 'width:30px;height:30px;border-radius:50%;background:' + human.color;
                    item.appendChild(dot);
                }

                // Compteur spores
                const sporesEl = document.createElement('div');
                sporesEl.className = 'mp-spores';
                sporesEl.textContent = Math.floor(body.spores);
                item.appendChild(sporesEl);

                // Clic â†’ centrer la camÃ©ra
                item.addEventListener('click', () => {
                    document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    followingBody = body;
                    gameState.camera.x = body.x;
                    gameState.camera.y = body.y;
                    gameState.camera.zoom = Math.max(gameState.camera.zoom, 0.8);
                    openCodex(body);
                });

                rowEl.appendChild(item);
            }

            groupEl.appendChild(rowEl);
            container.appendChild(groupEl);
        }
    } else {
        // Mettre Ã  jour badges systÃ¨me complet
        const sunLabels = container.querySelectorAll('.mp-sun-label');
        let gIdx = 0;
        for (const sunName of Object.keys(groups)) {
            if (gIdx < sunLabels.length) {
                const sunRef = groupSuns[sunName];
                const complete = sunRef && isSystemComplete(sunRef, 0);
                const hasSpan = sunLabels[gIdx].querySelector('.sys-complete');
                if (complete && !hasSpan) {
                    sunLabels[gIdx].innerHTML = '\u2600 ' + sunName + '<span class="sys-complete" title="SystÃ¨me complet : +3% de vitesse de production de spores sur toutes les planÃ¨tes et lunes"> \u2605 +3%</span>';
                } else if (!complete && hasSpan) {
                    sunLabels[gIdx].innerHTML = '\u2600 ' + sunName;
                }
            }
            gIdx++;
        }
        // Mettre Ã  jour juste les spores et l'Ã©tat actif
        const items = container.querySelectorAll('.mp-item');
        let idx = 0;
        for (const sunName of Object.keys(groups)) {
            for (const body of groups[sunName]) {
                if (idx < items.length) {
                    const spEl = items[idx].querySelector('.mp-spores');
                    if (spEl) spEl.textContent = Math.floor(body.spores);
                    if (followingBody === body) items[idx].classList.add('active');
                    else items[idx].classList.remove('active');
                }
                idx++;
            }
        }
    }
}

function updateCameraFollow() {
    // Verrouillage camÃ©ra pendant le tir
    if (gameState.launchCameraLock && gameState.launchSource) {
        const cam = gameState.camera;
        cam.x += (gameState.launchSource.x - cam.x) * 0.12;
        cam.y += (gameState.launchSource.y - cam.y) * 0.12;
        return;
    }
    if (!followingBody) return;
    // Si le body n'est plus au joueur, arrÃªter le suivi
    if (followingBody.owner !== 0) {
        followingBody = null;
        return;
    }
    // Suivre en douceur
    const cam = gameState.camera;
    const lerp = 0.08;
    cam.x += (followingBody.x - cam.x) * lerp;
    cam.y += (followingBody.y - cam.y) * lerp;
}

// ArrÃªter le suivi si le joueur fait un panoramique
const _origSetupInput = setupInput;
const stopFollow = () => { followingBody = null; document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active')); };

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUDIO GÃ‰NÃ‰RATIF â€” Web Audio API
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function initAudio() {
    if (gameState.audio.initialized) return;
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    gameState.audio.ctx = ac;

    // Master gain
    const master = ac.createGain();
    master.gain.value = gameState.audio.volume;
    master.connect(ac.destination);
    gameState.audio.masterGain = master;

    gameState.audio.initialized = true;
}

function ensureAudio() {
    if (!gameState.audio.initialized) initAudio();
    if (gameState.audio.ctx.state === 'suspended') {
        gameState.audio.ctx.resume();
    }
}

// â”€â”€ Ambiance spatiale (drone) â”€â”€
function startAmbiance() {
    ensureAudio();
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;

    if (gameState.audio.ambDrone) return;

    // Drone basse (calme)
    const osc1 = ac.createOscillator();
    osc1.type = 'sine';
    osc1.frequency.value = 40;
    const gain1 = ac.createGain();
    gain1.gain.value = 0.06;

    // Sub harmonique
    const osc2 = ac.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = 60;
    const gain2 = ac.createGain();
    gain2.gain.value = 0.03;

    // Drone tension (dÃ©sactivÃ© au dÃ©part)
    const oscTension = ac.createOscillator();
    oscTension.type = 'sawtooth';
    oscTension.frequency.value = 55;
    const gainTension = ac.createGain();
    gainTension.gain.value = 0;
    const filterTension = ac.createBiquadFilter();
    filterTension.type = 'lowpass';
    filterTension.frequency.value = 200;
    filterTension.Q.value = 3;

    // LFO pour modulation
    const lfo = ac.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.15;
    const lfoGain = ac.createGain();
    lfoGain.gain.value = 5;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);

    // LFO tension (plus rapide)
    const lfoT = ac.createOscillator();
    lfoT.type = 'sine';
    lfoT.frequency.value = 0.4;
    const lfoTGain = ac.createGain();
    lfoTGain.gain.value = 8;
    lfoT.connect(lfoTGain);
    lfoTGain.connect(oscTension.frequency);

    // Filtre passe-bas
    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 120;
    filter.Q.value = 1;

    osc1.connect(gain1);
    osc2.connect(gain2);
    gain1.connect(filter);
    gain2.connect(filter);
    filter.connect(master);

    oscTension.connect(filterTension);
    filterTension.connect(gainTension);
    gainTension.connect(master);

    osc1.start();
    osc2.start();
    lfo.start();
    oscTension.start();
    lfoT.start();

    gameState.audio.ambDrone = { osc1, osc2, lfo, gain1, gain2, filter, oscTension, gainTension, filterTension, lfoT };
}

function stopAmbiance() {
    const drone = gameState.audio.ambDrone;
    if (!drone) return;
    try {
        drone.osc1.stop();
        drone.osc2.stop();
        drone.lfo.stop();
    } catch(e) {}
    gameState.audio.ambDrone = null;
}

// â”€â”€ Son de lancement de jet â”€â”€
function playLaunchSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;
    const pitchVar = 0.85 + Math.random() * 0.3;

    const osc = ac.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200 * pitchVar, t);
    osc.frequency.exponentialRampToValueAtTime(80 * pitchVar, t + 0.3);

    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(800, t);
    filter.frequency.exponentialRampToValueAtTime(200, t + 0.3);

    // Bruit granulaire
    const noise = ac.createBufferSource();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.3, ac.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
    noise.buffer = buf;
    const noiseGain = ac.createGain();
    noiseGain.gain.setValueAtTime(0.04, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    const noiseFilter = ac.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 400;
    noiseFilter.Q.value = 2;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(master);

    osc.start(t);
    osc.stop(t + 0.4);
    noise.start(t);
    noise.stop(t + 0.3);
}

// â”€â”€ Son de fusion (jet arrive sur astre ami) â”€â”€
function playFusionSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    [260, 330, 390].forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.05, t + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.02);
        osc.stop(t + 0.6);
    });
}

// â”€â”€ Son de conquÃªte (Ã©closion) â”€â”€
function playConquestSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    // Accord ascendant
    [220, 277, 330, 440].forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.08);
        gain.gain.linearRampToValueAtTime(0.07, t + i * 0.08 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.08);
        osc.stop(t + 0.9);
    });

    // Burst harmonique
    const noise = ac.createBufferSource();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.2, ac.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    noise.buffer = buf;
    const nGain = ac.createGain();
    nGain.gain.setValueAtTime(0.06, t);
    nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    const nFilter = ac.createBiquadFilter();
    nFilter.type = 'highpass';
    nFilter.frequency.value = 2000;
    noise.connect(nFilter);
    nFilter.connect(nGain);
    nGain.connect(master);
    noise.start(t);
    noise.stop(t + 0.2);
}

// â”€â”€ Son de neutralisation (collision de jets) â”€â”€
function playNeutralizationSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;
    const pitchVar = 0.8 + Math.random() * 0.4;

    const osc = ac.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(100 * pitchVar, t);
    osc.frequency.exponentialRampToValueAtTime(40 * pitchVar, t + 0.15);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 300;
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    osc.start(t);
    osc.stop(t + 0.2);
}

// â”€â”€ Son de vaisseau nettoyeur (ping) â”€â”€
function playCleanerSound(cleanerX, cleanerY) {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    // Spatialisation simple (panoramique gauche/droite)
    const pan = ac.createStereoPanner ? ac.createStereoPanner() : null;
    if (pan) {
        const screenX = (cleanerX - gameState.camera.x) / (gameState.width / 2 / gameState.camera.zoom);
        pan.pan.value = Math.max(-1, Math.min(1, screenX * 0.8));
    }

    const osc = ac.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(1200, t);
    osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.04, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

    osc.connect(gain);
    if (pan) { gain.connect(pan); pan.connect(master); }
    else { gain.connect(master); }
    osc.start(t);
    osc.stop(t + 0.15);
}

// â”€â”€ SÃ©quence victoire â”€â”€
function playVictorySound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const notes = [262, 330, 392, 523, 659, 784];
    notes.forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.15);
        gain.gain.linearRampToValueAtTime(0.08, t + i * 0.15 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.15 + 0.5);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.15);
        osc.stop(t + i * 0.15 + 0.5);
    });
}

// â”€â”€ SÃ©quence dÃ©faite â”€â”€
function playDefeatSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const notes = [392, 349, 330, 262, 220, 196];
    notes.forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.2);
        gain.gain.linearRampToValueAtTime(0.06, t + i * 0.2 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.6);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.2);
        osc.stop(t + i * 0.2 + 0.6);
    });
}

// â”€â”€ ContrÃ´le volume â”€â”€
function setupVolumeControl() {
    const slider = document.getElementById('volSlider');
    const icon = document.getElementById('volToggle');

    slider.value = gameState.audio.volume * 100;

    slider.addEventListener('input', () => {
        gameState.audio.volume = parseInt(slider.value) / 100;
        if (gameState.audio.masterGain) {
            gameState.audio.masterGain.gain.value = gameState.audio.volume;
        }
        gameState.audio.muted = gameState.audio.volume === 0;
        icon.textContent = gameState.audio.muted ? 'ğŸ”‡' : 'ğŸ”Š';
    });

    icon.addEventListener('click', () => {
        gameState.audio.muted = !gameState.audio.muted;
        if (gameState.audio.masterGain) {
            gameState.audio.masterGain.gain.value = gameState.audio.muted ? 0 : gameState.audio.volume;
        }
        icon.textContent = gameState.audio.muted ? 'ğŸ”‡' : 'ğŸ”Š';
    });
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// MINIMAP
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawMinimap() {
    if (gameState.phase !== 'game' && gameState.phase !== 'paused') return;
    const mc = document.getElementById('minimapCanvas');
    const mctx = mc.getContext('2d');
    const size = 160;

    mctx.fillStyle = 'rgba(6, 8, 26, 0.9)';
    mctx.fillRect(0, 0, size, size);

    // Calcul de l'Ã©chelle : trouver l'Ã©tendue max
    let maxDist = 500;
    for (const s of gameState.suns) {
        const d = Math.sqrt(s.x * s.x + s.y * s.y) + s.orbitRadius + 500;
        if (d > maxDist) maxDist = d;
    }
    const scale = (size / 2 - 8) / maxDist;
    const cx = size / 2;
    const cy = size / 2;

    // Trou noir
    mctx.fillStyle = '#000';
    mctx.beginPath();
    mctx.arc(cx, cy, 3, 0, Math.PI * 2);
    mctx.fill();
    mctx.strokeStyle = 'rgba(100,40,180,0.3)';
    mctx.lineWidth = 0.5;
    mctx.stroke();

    // Soleils
    for (const s of gameState.suns) {
        mctx.fillStyle = s.color + '80';
        mctx.beginPath();
        mctx.arc(cx + s.x * scale, cy + s.y * scale, 2, 0, Math.PI * 2);
        mctx.fill();
    }

    // PlanÃ¨tes et lunes
    const bodies = gameState.allBodies;
    for (const b of bodies) {
        if (b.owner !== null && b.owner !== undefined) {
            mctx.fillStyle = gameState.players[b.owner]?.color || '#666';
        } else {
            mctx.fillStyle = 'rgba(150,150,170,0.4)';
        }
        const r = b.type === 'planet' ? 1.5 : 0.8;
        mctx.beginPath();
        mctx.arc(cx + b.x * scale, cy + b.y * scale, r, 0, Math.PI * 2);
        mctx.fill();
    }

    // Jets
    for (const j of gameState.jets) {
        if (!j.alive) continue;
        mctx.fillStyle = j.color;
        mctx.beginPath();
        mctx.arc(cx + j.x * scale, cy + j.y * scale, 1, 0, Math.PI * 2);
        mctx.fill();
    }

    // Nettoyeurs
    for (const cl of gameState.cleaners) {
        mctx.fillStyle = 'rgba(255, 60, 60, 0.6)';
        mctx.fillRect(cx + cl.x * scale - 1, cy + cl.y * scale - 1, 2, 2);
    }

    // Rectangle de vue
    const cam = gameState.camera;
    const vw = gameState.width / cam.zoom * scale;
    const vh = gameState.height / cam.zoom * scale;
    const vx = cx + cam.x * scale - vw / 2;
    const vy = cy + cam.y * scale - vh / 2;
    mctx.strokeStyle = 'rgba(200, 160, 255, 0.5)';
    mctx.lineWidth = 1;
    mctx.strokeRect(vx, vy, vw, vh);
}

function setupMinimap() {
    const mc = document.getElementById('minimapCanvas');
    mc.addEventListener('click', (e) => {
        const rect = mc.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        let maxDist = 500;
        for (const s of gameState.suns) {
            const d = Math.sqrt(s.x * s.x + s.y * s.y) + s.orbitRadius + 500;
            if (d > maxDist) maxDist = d;
        }
        const scale = (80 - 8) / maxDist;
        const worldX = (mx - 80) / scale;
        const worldY = (my - 80) / scale;
        gameState.camera.x = worldX;
        gameState.camera.y = worldY;
        if (typeof followingBody !== 'undefined') followingBody = null;
    });
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// INDICATEURS HORS-Ã‰CRAN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawOffscreenIndicators() {
    if (gameState.phase !== 'game') return;
    const cam = gameState.camera;
    const w = gameState.width;
    const h = gameState.height;
    const ctx = gameState.ctx;
    const margin = 20;

    for (const jet of gameState.jets) {
        if (!jet.alive) continue;
        if (jet.owner === 0) continue; // pas nos propres jets

        // Convertir en coordonnÃ©es Ã©cran
        const sx = (jet.x - cam.x) * cam.zoom + w / 2;
        const sy = (jet.y - cam.y) * cam.zoom + h / 2;

        // Si visible, pas besoin d'indicateur
        if (sx >= 0 && sx <= w && sy >= 0 && sy <= h) continue;

        // Calculer le point sur le bord de l'Ã©cran
        const dx = sx - w / 2;
        const dy = sy - h / 2;
        const angle = Math.atan2(dy, dx);

        // Clamp sur le bord
        let ix = w / 2 + Math.cos(angle) * (w / 2 - margin);
        let iy = h / 2 + Math.sin(angle) * (h / 2 - margin);
        ix = Math.max(margin, Math.min(w - margin, ix));
        iy = Math.max(margin, Math.min(h - margin, iy));

        // Dessiner la flÃ¨che (hors transformation camÃ©ra)
        ctx.save();
        ctx.translate(ix, iy);
        ctx.rotate(angle);

        ctx.fillStyle = jet.color + '90';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-4, -5);
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();

        // Lueur
        ctx.fillStyle = jet.color + '20';
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TIMER DE PARTIE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateGameTimer() {
    if (gameState.phase !== 'game') return;
    const elapsed = gameState.gameStats.timeElapsed;
    const min = Math.floor(elapsed / 60);
    const sec = Math.floor(elapsed % 60);
    const str = String(min).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
    if (DOM.gameTimer) DOM.gameTimer.textContent = str;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// TRANSITIONS & LOADING
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function fadeTransition(callback) {
    const fade = document.getElementById('screenFade');
    fade.classList.add('active');
    setTimeout(() => {
        callback();
        setTimeout(() => fade.classList.remove('active'), 50);
    }, 500);
}

function updateLoadingBar(pct, text) {
    document.getElementById('loadingBarFill').style.width = pct + '%';
    if (text) document.getElementById('loadingText').textContent = text;
}

function hideLoading() {
    document.getElementById('loadingScreen').classList.add('hidden');
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// AUDIO â€” Tension adaptative & sons UI
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function updateAudioTension() {
    if (!gameState.audio.initialized || !gameState.audio.ambDrone) return;

    // Calculer la tension : jets ennemis proches de nos astres
    let tensionTarget = 0;
    const human = gameState.players[0];
    if (human) {
        for (const jet of gameState.jets) {
            if (!jet.alive || jet.owner === 0) continue;
            for (const body of human.bodies) {
                const dx = jet.x - body.x;
                const dy = jet.y - body.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 300) {
                    tensionTarget += (300 - dist) / 300;
                }
            }
        }
    }
    tensionTarget = Math.min(1, tensionTarget);

    // Lerp vers la cible
    gameState.audio.tension += (tensionTarget - gameState.audio.tension) * 0.02;
    const t = gameState.audio.tension;

    // Appliquer la tension au drone
    const drone = gameState.audio.ambDrone;
    if (drone.gainTension) {
        drone.gainTension.gain.value = t * 0.04;
    }
    if (drone.filterTension) {
        drone.filterTension.frequency.value = 150 + t * 300;
    }
    // AccÃ©lÃ©rer le LFO en tension
    if (drone.lfo) {
        drone.lfo.frequency.value = 0.15 + t * 0.3;
    }
}

function playClickSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const osc = ac.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, t);
    osc.frequency.exponentialRampToValueAtTime(400, t + 0.06);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.05, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    osc.connect(gain);
    gain.connect(master);
    osc.start(t);
    osc.stop(t + 0.08);
}

function updateOrbitHum() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const cam = gameState.camera;

    // Son d'orbite seulement quand trÃ¨s zoomÃ©
    if (cam.zoom < 2) {
        if (gameState.audio.orbitHum) {
            gameState.audio.orbitHumGain.gain.value = 0;
        }
        return;
    }

    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;

    // CrÃ©er le hum si pas encore fait
    if (!gameState.audio.orbitHum) {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 80;
        const gain = ac.createGain();
        gain.gain.value = 0;
        const filter = ac.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(master);
        osc.start();
        gameState.audio.orbitHum = osc;
        gameState.audio.orbitHumGain = gain;
    }

    // Volume basÃ© sur le zoom et la proximitÃ© d'une planÃ¨te
    let closestDist = Infinity;
    for (const p of gameState.planets) {
        const dx = p.x - cam.x;
        const dy = p.y - cam.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < closestDist) closestDist = dist;
    }

    const proxFactor = Math.max(0, 1 - closestDist / 200);
    const zoomFactor = Math.min(1, (cam.zoom - 2) / 3);
    const vol = proxFactor * zoomFactor * 0.015;
    gameState.audio.orbitHumGain.gain.value = vol;

    // Moduler la frÃ©quence selon la planÃ¨te
    gameState.audio.orbitHum.frequency.value = 60 + proxFactor * 40;
}


// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Ã‰CRAN TITRE â€” Animation
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function animateTitleScreen() {
    const title = document.getElementById('titleText');
    const text = 'NEBULA CONQUEST';
    title.innerHTML = '';

    // Lettres animÃ©es une par une
    for (let i = 0; i < text.length; i++) {
        const span = document.createElement('span');
        span.className = 'title-letter';
        span.textContent = text[i] === ' ' ? '\u00A0' : text[i];
        span.style.animationDelay = (i * 0.08) + 's';
        title.appendChild(span);
    }

    // Canvas Ã©toiles filantes en fond
    const canvas = document.getElementById('titleBgCanvas');
    if (!canvas) return;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext('2d');

    const stars = [];
    for (let i = 0; i < 80; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 1.5 + 0.3,
            alpha: Math.random() * 0.5 + 0.1,
            speed: Math.random() * 0.3 + 0.05
        });
    }

    const shooters = [];
    let lastShooter = 0;

    function titleLoop(t) {
        if (gameState.phase !== 'title') return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Ã‰toiles scintillantes
        for (const s of stars) {
            const flicker = s.alpha * (0.6 + Math.sin(t * 0.002 * s.speed + s.x) * 0.4);
            ctx.fillStyle = `rgba(200, 215, 255, ${flicker})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        }

        // Ã‰toiles filantes
        if (t - lastShooter > 2000 + Math.random() * 3000) {
            lastShooter = t;
            const angle = -0.3 + Math.random() * 0.2;
            shooters.push({
                x: Math.random() * canvas.width,
                y: -20,
                vx: Math.cos(angle) * (200 + Math.random() * 300),
                vy: Math.sin(angle + Math.PI/2) * (200 + Math.random() * 300),
                life: 0.8 + Math.random() * 0.6,
                age: 0,
                length: 40 + Math.random() * 60
            });
        }

        for (let i = shooters.length - 1; i >= 0; i--) {
            const s = shooters[i];
            s.age += 0.016;
            s.x += s.vx * 0.016;
            s.y += s.vy * 0.016;

            const progress = s.age / s.life;
            const alpha = progress < 0.2 ? progress / 0.2 : 1 - (progress - 0.2) / 0.8;
            const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
            const dx = s.vx / speed;
            const dy = s.vy / speed;

            const g = ctx.createLinearGradient(
                s.x - dx * s.length, s.y - dy * s.length,
                s.x, s.y
            );
            g.addColorStop(0, 'rgba(0,0,0,0)');
            g.addColorStop(1, `rgba(200, 220, 255, ${alpha * 0.6})`);
            ctx.strokeStyle = g;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(s.x - dx * s.length, s.y - dy * s.length);
            ctx.lineTo(s.x, s.y);
            ctx.stroke();

            if (s.age >= s.life) shooters.splice(i, 1);
        }

        requestAnimationFrame(titleLoop);
    }

    requestAnimationFrame(titleLoop);
}


// â”€â”€ Panneaux draggables & rÃ©tractables â”€â”€
const PANEL_IDS = ['sporeCounter', 'evoPanel', 'scoreBoard', 'minimap', 'uiZoomControl', 'myPlanets', 'eventLog', 'codex'];
const PANEL_LABELS = { sporeCounter: 'SPORES', evoPanel: 'Ã‰VOLUTION', scoreBoard: 'SCORES', minimap: 'MINIMAP', uiZoomControl: 'TAILLE UI', myPlanets: 'MES ASTRES', eventLog: 'Ã‰VÃ‰NEMENTS', codex: 'CODEX' };
let panelConfig = {};
let _panelsInitialized = false;

const SNAP_DISTANCE = 14;

function _snapPanel(el, id) {
    const r = el.getBoundingClientRect();
    const curLeft = parseInt(el.style.left);
    const curTop = parseInt(el.style.top);
    if (isNaN(curLeft) || isNaN(curTop)) return;
    let dxBest = SNAP_DISTANCE + 1, dyBest = SNAP_DISTANCE + 1;
    let adjX = 0, adjY = 0;
    for (const otherId of PANEL_IDS) {
        if (otherId === id) continue;
        const other = document.getElementById(otherId);
        if (!other || other.style.display === 'none' || other.classList.contains('panel-collapsed')) continue;
        if (!other.offsetWidth) continue;
        const o = other.getBoundingClientRect();
        // ProximitÃ© verticale suffisante pour snap horizontal ?
        const nearY = (r.bottom > o.top - SNAP_DISTANCE) && (r.top < o.bottom + SNAP_DISTANCE);
        // ProximitÃ© horizontale suffisante pour snap vertical ?
        const nearX = (r.right > o.left - SNAP_DISTANCE) && (r.left < o.right + SNAP_DISTANCE);
        if (nearY) {
            const tests = [
                r.right - o.left,   // bord droit â†’ bord gauche
                r.left - o.right,   // bord gauche â†’ bord droit
                r.left - o.left,    // aligner gauches
                r.right - o.right   // aligner droits
            ];
            for (let i = 0; i < tests.length; i++) {
                if (Math.abs(tests[i]) < Math.abs(dxBest)) { dxBest = tests[i]; adjX = -tests[i]; }
            }
        }
        if (nearX) {
            const tests = [
                r.bottom - o.top,   // bord bas â†’ bord haut
                r.top - o.bottom,   // bord haut â†’ bord bas
                r.top - o.top,      // aligner hauts
                r.bottom - o.bottom // aligner bas
            ];
            for (let i = 0; i < tests.length; i++) {
                if (Math.abs(tests[i]) < Math.abs(dyBest)) { dyBest = tests[i]; adjY = -tests[i]; }
            }
        }
    }
    // Snap aux bords de l'Ã©cran
    if (Math.abs(r.left) < Math.abs(dxBest)) { dxBest = r.left; adjX = -r.left; }
    if (Math.abs(r.top) < Math.abs(dyBest)) { dyBest = r.top; adjY = -r.top; }
    if (Math.abs(r.right - window.innerWidth) < Math.abs(dxBest)) { adjX = window.innerWidth - r.right; dxBest = -(window.innerWidth - r.right); }
    if (Math.abs(r.bottom - window.innerHeight) < Math.abs(dyBest)) { adjY = window.innerHeight - r.bottom; dyBest = -(window.innerHeight - r.bottom); }
    if (Math.abs(dxBest) <= SNAP_DISTANCE) el.style.left = Math.round(curLeft + adjX) + 'px';
    if (Math.abs(dyBest) <= SNAP_DISTANCE) el.style.top = Math.round(curTop + adjY) + 'px';
}

function _getUIScaleTransform() {
    const slider = document.getElementById('uiZoomSlider');
    if (!slider) return '';
    const val = parseInt(slider.value);
    return val !== 100 ? `scale(${val / 100})` : '';
}

function initPanels() {
    if (_panelsInitialized) return;
    _panelsInitialized = true;
    for (const id of PANEL_IDS) {
        const el = document.getElementById(id);
        if (!el) continue;
        if (!panelConfig[id]) panelConfig[id] = {};
        const handle = document.createElement('div');
        handle.className = 'panel-drag-handle';
        handle.innerHTML = `<span class="panel-label">${PANEL_LABELS[id]}</span><span class="panel-collapse" title="RÃ©duire/Agrandir">â–¾</span>`;
        el.insertBefore(handle, el.firstChild);
        const colBtn = handle.querySelector('.panel-collapse');
        colBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            el.classList.toggle('panel-collapsed');
            colBtn.textContent = el.classList.contains('panel-collapsed') ? 'â–¸' : 'â–¾';
            panelConfig[id].collapsed = el.classList.contains('panel-collapsed');
            debounceSavePanels();
        });
        let dragging = false, startX, startY, origX, origY;
        handle.addEventListener('mousedown', (e) => {
            if (e.target === colBtn) return;
            dragging = true;
            startX = e.clientX; startY = e.clientY;
            const rect = el.getBoundingClientRect();
            origX = rect.left; origY = rect.top;
            el.style.transition = 'none';
            e.preventDefault();
        });
        handle.addEventListener('touchstart', (e) => {
            if (e.target === colBtn) return;
            const touch = e.touches[0];
            dragging = true;
            startX = touch.clientX; startY = touch.clientY;
            const rect = el.getBoundingClientRect();
            origX = rect.left; origY = rect.top;
            el.style.transition = 'none';
        }, { passive: true });
        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            el.style.position = 'fixed';
            el.style.left = (origX + e.clientX - startX) + 'px';
            el.style.top = (origY + e.clientY - startY) + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        });
        window.addEventListener('touchmove', (e) => {
            if (!dragging) return;
            const touch = e.touches[0];
            el.style.position = 'fixed';
            el.style.left = (origX + touch.clientX - startX) + 'px';
            el.style.top = (origY + touch.clientY - startY) + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        }, { passive: true });
        const endDrag = () => {
            if (!dragging) return;
            dragging = false;
            el.style.transition = '';
            _snapPanel(el, id);
            const left = parseInt(el.style.left);
            const top = parseInt(el.style.top);
            if (!isNaN(left) && !isNaN(top)) {
                panelConfig[id].x = left;
                panelConfig[id].y = top;
                debounceSavePanels();
            }
        };
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
        if (panelConfig[id].x !== undefined && panelConfig[id].y !== undefined) {
            el.style.position = 'fixed';
            el.style.left = panelConfig[id].x + 'px';
            el.style.top = panelConfig[id].y + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        }
        if (panelConfig[id].collapsed) {
            el.classList.add('panel-collapsed');
            colBtn.textContent = 'â–¸';
        }
    }
}

let _savePanelTimer = null;
function debounceSavePanels() {
    clearTimeout(_savePanelTimer);
    _savePanelTimer = setTimeout(savePanelConfig, 1000);
}

async function loadPanelConfig() {
    if (typeof currentUser === 'undefined' || !currentUser) return;
    try {
        const { data } = await _supa.from('profiles').select('panel_config').eq('id', currentUser.id).single();
        if (data && data.panel_config) panelConfig = data.panel_config;
    } catch (e) { console.warn('Panel config load:', e); }
}

async function savePanelConfig() {
    if (typeof currentUser === 'undefined' || !currentUser) return;
    try {
        await _supa.from('profiles').update({ panel_config: panelConfig }).eq('id', currentUser.id);
    } catch (e) { console.warn('Panel config save:', e); }
}

// â”€â”€ Log d'Ã©vÃ©nements â”€â”€
function addEvent(cat, icon, text, body, color) {
    const t = gameState.time;
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    const time = (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
    gameState.eventLog.unshift({ cat, icon, text, time, body, color: color || '#AAA' });
    if (gameState.eventLog.length > 100) gameState.eventLog.pop();
    refreshEventLog();
}

function refreshEventLog() {
    const logBody = document.getElementById('eventLogBody');
    if (!logBody) return;
    const activeFilter = document.querySelector('#eventLog .log-filter.active');
    const cat = activeFilter ? activeFilter.dataset.cat : 'all';
    const filtered = cat === 'all' ? gameState.eventLog : gameState.eventLog.filter(e => e.cat === cat);
    logBody.innerHTML = filtered.slice(0, 50).map((e, i) =>
        `<div class="log-entry" data-idx="${i}"><span class="log-time">${e.time}</span><span class="log-icon" style="color:${e.color}">${e.icon}</span><span class="log-text">${e.text}</span></div>`
    ).join('');
    logBody.querySelectorAll('.log-entry').forEach(el => {
        el.addEventListener('click', () => {
            const idx = parseInt(el.dataset.idx);
            const evt = filtered[idx];
            if (evt && evt.body) {
                gameState.camera.x = evt.body.x;
                gameState.camera.y = evt.body.y;
                gameState.camera.zoom = Math.max(gameState.camera.zoom, 0.8);
                openCodex(evt.body);
            }
        });
    });
}

window.addEventListener('load', init);

</script>

<!-- â•â•â• VOLUME â•â•â• -->
<div id="volumeControl">
    <span class="vol-icon" id="volToggle">ğŸ”Š</span>
    <input type="range" id="volSlider" min="0" max="100" value="40">
</div>

<!-- â•â•â• Ã‰CRAN DE FIN â•â•â• -->
<div id="endScreen">
    <h1 id="endTitle">â€”</h1>
    <div class="end-subtitle" id="endSubtitle"></div>
    <div class="end-stats" id="endStats"></div>
    <div class="end-buttons">
        <button class="btn" id="btnReplay">REJOUER</button>
        <button class="btn" id="btnEndQuit">MENU</button>
    </div>
</div>


<script>
const CLN_CFG = {
    speedMin: 67, speedMax: 120, turnInterval: 15,
    detectRange: 200, fireRate: 1.5, dmgMin: 34, dmgMax: 106
};

const SKY_CFG = { r: 22, g: 38, b: 78, brightness: 100 };

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// FOND SPATIAL â€” Couches PNG en parallaxe
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const BG_L0_B64 = '/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAA0JCgsKCA0LCgsODg0PEyAVExISEyccHhcgLikxMC4pLSwzOko+MzZGNywtQFdBRkxOUlNSMj5aYVpQYEpRUk//2wBDAQ4ODhMREyYVFSZPNS01T09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0//wAARCAIAAgADASIAAhEBAxEB/8QAGAABAQEBAQAAAAAAAAAAAAAAAAECAwf/xAAWEAEBAQAAAAAAAAAAAAAAAAAAARH/xAAYAQEBAQEBAAAAAAAAAAAAAAAAAQIDBP/EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAwDAQACEQMRAD8A89VFZdQAARRAAFAARUAVFERFQAAAAFQAUTQFEAURQAQRUEBUBQBAVBBAEVAEUVAUAFRVRWgVGlBUAUBQAARUQAARQRpFAVRBwaUABUAUABUAAABFERUUEFQAAAAAQAVBRRBBQQQBAVAUATQAQRUEVFSiKACgqKqKIqiqiqKagooiiioAqKggCIqgoqAIoA5KACqAgCKIKgKoiggAgAAaIAAACAoigAgKIAqAICAAJqioVAXUCiAgoqAqAACorSCoqigqiKCqKigAAAAAIKCo0mGKorADkAAAAAAAAKIIKAAIAqAACAqKgAAAIIqBoAgoqGggioACAqAoCCoAAogCgNIqoqiqgooAqgKKiiCCgIooAKKAqK5gOQqCggAAAogAKgCiCKqAAAAqAgoAgoggCiIqCCAoCAioAAgoaCCKIKKAAqCigKKqKAqLFFAUUAAUABQRowwBSApgoDmA4qAAItQAEABBVEAUQRVEAURQUAABAAEEVFBFQRKy1WQEBUAQFQFQBAUBRQAAVQDFUBTFFABQIooAKCgLIRVAUABUUwxQHIBxVBUARUAQAQAUEAURUUAAUAWKyqAAAIAAKgioCVKtSiM0KioAKAIoCggCrgAAKKoKACiqIosUAUEUVRFMUCKKAoAKKiooCuIo4KgAiAgolVAQAEAVQABUAVUVBRFABEABQAEEXWQKzVqVURFRUAAAFQFFCAqiCgCgoqkAWKiqCwAFBQVFBcQWAKAqqgCqioCooriA86oAoiKCoACIqAAKCKCIFFFARVioAoggAAgAgggFZqoqIAqACgAqCoqg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';
const BG_L1_B64 = 'iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAB3AUlEQVR42u29XY8s23keVquququ7Z/OQkmjK+qRkWYwB0bANyY7gIAlzZSAXuZP/Qn7Gon5G5+YAMXKzCEvRiGppoADrxBSbh8I65kAo8shlku0MsLEh0YguBDukKJ0nF1W9d09PVdfX+q73BQhwn5nprlrr/f543iQhIjJMABgHUjqJBfOA2q9c8yCAbKnnBCAFwHR81l5hda+wQ5IwPD7cOT2vk9wgSRhJ2ICzEiJDdShsCNuajpuIiOidTuDkADaOiBvHQq2g1QkHGV39zMFMy6AVR3ysp304oBDCf+9cz9mIrE0QAZkDakVSQIZA+3dRhOTNnb/Bm7sRv5+6chhuPZMiPWXmXBV2wXjzeBJbXZ+nFDR7p0QDlUtOJ+Hi8BNWorSWJYMQ2aUhAcCghilxDp5KSOITB86bpw4AM6GrATBwyhIFJAR0WaErsTk10ebvqdSjgcoSaxOKvr6jl3JaAuvT6bQZYYS8jfiqCgXndoMHXb0EANKhjlj0+kiIDJKTo+mKpHQbDUKIbGiqUimsytKO8QHAuPQ/UkYpjJ7HdcTaOACkvKbx1CrBO14fasQgRIbD8CYeIIk+qhKGnCdrOu9goSmLyBoFXx4BhtcL9wqrW93dUiIf6p3jcChiUFaNYWRnD9+ao+K4y5poFI/k13JEpxLN3WahOiREGgJpB+UycJ5Cavreul44zAnoM/BLFAQJmZ+9wEtngMikwyVupmRLz6NE4pHRJ0bnRUR0lgYpcxz19eQReWkkhjeN3arNx9ZsOcT7vfXOVYXCVpYmcEfLG76RJ2xMzvQjSRiOR1KogZJph19btH0RAFyX4JtMUpw9EQBYbGN/pjt2h352k3XobPAiQJ6r8+D+dVoPvGOrteOlNavR6OTAcyrL9dIyWHgS2zGlciDpzQSf9fLDI+4ApBIyj7bHSghkhwrWm1/mKrHGyKdd70SpXCp7hBSdQ+1XNM1j2eG8oUOIYpVPkQ3NGhBvWI6YJxg3uqBbZyRlvtTRJlezzDVPjud3lGINITKzz5YwvL73GuCkyQJZvLewHeS+cmQNaia8zvDa4H2fA/Bgg7ShXbYAtgR0M5whEorab9J38d3PfYyPP3WT5zi3akggZR6CEhuTLnVBUiJXNIkx/D578PcBkS3VuE7WwUBmC89iVrnatecwFC8AnKfX0RiAouv5dSLjAVgNPScfGtCkRD7mXmtD516pw1I6FQD7Dr7zhe/iu5/zLuNAjhsRUfhO1aUcI2HCxwzKWCzrwC4gv9U8NwZoJ/YyASTPCbaTyIAzQzxFRLIAsApVEevLbXwW9LYJBSQJw0luXD0PNWr5T64aWwOS+5uwtwD8jHouiHOkUsZVViRH3muZia+x3Hcv3zdFDilznYuX5ig/3+/OpXKOcbTVxBkF/gJsTJ3WJTrnIx7vhsjrULyDM+6CTqhbAGzOWHKIJbD2TbCdZWlGQjvn2estaKSUNTGu7waO6uEUQRI/jg+0hjynCYhbKZEfj3jrgIiREW/Ta1UExA/pwwNelNC9BiILOQ0BINON2kRERNTIV5IwVLTMpsu4BaIj86UESZfNziWeAxjZ3ig5hHx8JiKi6crmeNxSlE60BJqbLYMQi4enNrkuuUJVcNSTYmVZruUJG+946IitTswIQHQE85qVMtVC33rWNFt8eSaUjRnk9ZuMHmNsZBuqk8SNVCtB/3ZEzd/CZ775HfzUTF2YTUnVQ4gMZWnUEQKQusAscJFZBw5FK0DTvcKu72HG1JTUa+ziTV8MxuTPCIhohBDSCNj5LLxtJrzlwCGp8c5D5HmUYu1qysd3On4LP/eNj/FLffJLQErj5Tygh02Y79COGg0Re/fv5wpPlPAyVUREZEU+bpRwcJIbQGQlynXgOiDrc3aCiuAtZHuEQEYbNXscqSO2vmXeOicwlpoOu26Iofn78V4tpfmJQg8CYnofcQT13RigelR8+LlyIPVtlPpeoX1HRzM+R8aPaLwC1TwWFnpEGTOFtkrZxKKqssS6WjoA1AIdjCllOg6kgjIl8XuGOpUi3jwMA/SIVAjPCHEUxfhH8oQNl8vuc8FIcCBLz5TaG+0DExez/EtzgKkkrJudBi77mSqspgWjRLlONC7KuWX4LnsUXKKO2VBo1ozat/CZr/8Z/pEPjXhQarX0ksrUBlEotfIpi2nTgT2fWdOITM15485uDSBt+l16+SfUZvezHfTv4f/pqzzh3IiwMMaQJAlMPv4X2Rf/JmH6vqN55g764JO3v/cb/+uPYxVKxtgntr6r+KnkR+ld8lff/rZZPhlEf/3XSL70JQwQ5tRHRQ+AzW18Yox9wqbI01//NZIvf9lOBNzjLAJIP/ooyW3KSyMznyRJ8re2vleUWEeQqat57Uc/+vGlrUBHKfK3f3u8bkLTD6BRzvLJ70lERBRF5OKl4o0dzQwAc1nXvbXi3Dbt1fA16MHds8bekevembkZb6OZLhtQn7bGDOtIiTr7iYiIonFAbhpdUWItF4BHglKsQyyDQso8SgyKpt6+Gv67ND4Wxb2/vt/RBMk0IjCV8Eh4uCsFQDq1cRYAu4xIAbAQHAio/WoJWDWhOQFpIM/J5oybATylLvV3Zznr7zlPIXke2DuvddTgD4GOkwFhjjbVRgPMBL8PQXSUkEYW8QiITELmUxpIAZFdQuPaaJzW4YT5astCG5UNmhqBGs30HDw94bSZowQAwhLXI2gJC23FbNNt7e0zG5smaBQbgI1rJXe56W2O8T5UKOZMgLTxQYWqtU7PKXAITcbfZUaEyIZkHOq/oTsebkgFpXG8u5eyXA/pBaGxten0MT7+1Bwn1IWs+rSzQI1oQGuUedapsGcYZZQvt/j11emJHBjzmU19AE/JVvVGxRNqUBM7Iqnu7P4uIWW+NKEAwCpUxdzPOOH0zypUP2/qGZOEtnReOQCpS56hW3h7FoWD79zi6WlLp29eyKxd7lm5WQbc8HrlLx4e7mycxxhlKgSyy9lwPB23NJmRJE942vZlAMD5TVCctjnsuomrzsrE6CRLiTwkxwZA+vCIO7IQL4nq5USzhQsYBs0IIJMzJw98hAF1EWk84Wk71big7tsgoR9goPuw7Jd4jnuFlfQUjjjU5kiX/O9Cnw7NcN7fY2eqns85UhkTrHbMoBBnUgqrZazBJAMd7c1KmeMotknyrvyGw6EgpywcB5zIlh43d5/1zpOASnR9MJ+RwEKSEvOk2UsIZC4E5HAYt/YzxPu9LsGY3MdBRDSVT/cR4mSUKNcIEagJACPgEiJbHrpS2LlIkU1xfgCehjbKSETkfSACamK1e+ilWFN3PdEYIZ0DqNTyeVmIMKb1jPA4B8C2nAnhN3bBXPJ/BwHYaaGrZBu7QhmmEXrV2nn1dRq7InnCBuQBavao/R7Zk0CuDE1ZcCD1qXvc9rNwuOm4bmbicwvfE4Bzo+f8Q3PkQigx+eRAQoj14vFV0IO5rXNb01SDSm5FWBEi91BxNjVBo7wkSqyldBN9NqOz5Mhr1DsxlWJ9gFXXscba68BPRNi47pJpmhRNcOnUaya3MY9/qFAon7ETAsiMEBHF7NCYhlV/fMQdBWxESxGpQVgFAE9trKX0vfYcqjNH9ILHglDwDb91RptTSrJWa8ZhOhkk3z4I6TkF+4xZAXY8IhqYRtc9FV0AE7Q6k+gFT5RiHQOUMxAWotzN0mYP+FPX+/vQMW+zidcnoy6B3P8mVMfEL1CfrpHkeEQeWtuc9YxIQZtQD1nu0/s8NOoWlwMgREaRI1G7I8LzNiMLdb9DB6IqAKZbl3cFLgDShDayRs6EnKeA/m7IUFJCHjTH7M5nNTWz0dfMSRSN47uWoM2Qveek9iuDd6ANWreW95eZCNP1+gpVcdmTc5LSq9FJ5TEUdU8wSTr4LCRD9wfEqHwux0tqj707qm9jmrFKZtKGyKXU5SMRSgDsu/juFz/Gxz9LGsadU++LcdLbVR+H3ZrapzIkgKpQFQo3d4aEiT4YonDPEXDblzTtee1sGxQL2LlgBgvADeDMG7y5W/IynKqyv+bWRyfk/PmXo4oUgc46y7wvGBIQUYN8JSa8WhOfeatuTwJAZIsOjTGKZQbft+hFd3+ObVJQK5sGI7QmzX6nnXS5VYqhwxJKdW5LFCWtESXyXPFerMJueNmqAfFKH4GnFSptEb+qN6mm5/9PnOt3MDpXphq5pHsmSpIkAXOF0nYd1dDyDaJbkc/7DZ/2KUDaLDjgPDtk7QVY14SxQCIzjtqQ+3Kku195lWEBwFDeXhJzxHHr/KFpjOSZQnpfoyNSp0kJeyC0yHfudyJJGI5iO45PNGHkl+Ua+/Fd9s2Ei1VdUMsapZJN2yGdy8raSCnsfIAy9vLwdSuaJnWiRSmWKNcnnDYkJqbu38wIp9fvLGWuzZgB7FZnr0GFtrKsJ7QtC5rqTABgPmQtxiyAoZ4ioiV6dOtQaye2BRZAQUtYLN+x2q9CUMwunlEIaF96FAOK4XUGY+jvmk5tExHFl5ZwdxqMGv3ckIDIbgHU1Gh45aLuBm8e7myXF0ygffrQHIgRa6YBZKgOhc5MJhGRn4qXDN5ABRLmDGcoM999aWEkCc0oTzLow2Gh6zOen2LXBbOtk5TC6jAQA+AdnHY/v7WVRkzpiZjG9IiIfDE8KZAwzusIoc0QNSWNdLnnQ1FQqHTCaTO0iRZCZCjFej7P8FQ3lC5OcoPX958No3RjpickVlkE5+mYvoqRQYWW8pPJfRwSMr9ZMh/r+emYgXzxDEqtTFySaypLsQZ4+vtH/NwfKPxjlOUa1fO6XePl64iMyJAOP6zB522bL4VA9nvfxK999c/wEyYdr9FKNOLoENXhPVS/8yt+ZBb0nvPxCdslR/bGAJuQMHE14dTmRFWoij4nWWPTcHq9rK2BEdanwxrAChY502jFTX54xN3vfBM/1ead6br4JzxtPTg376MIAGxIvVaUWHMgxZPY2nkukZ0nCP5Q4WfuFXamnOMGHXCUEzSl2c7VFEPIdDxiqxP0LLSlNRHakszW/fU56t7tAvDVYNhycHzbkieBfHbfxg1vVwhkosSaxi9HHGeH8X14xF0IWR+qKxO18UOJck1Zy/6zkietuCx6MyFzu3obA0hMsCCGHhJ9N2m7je7vnuJ96+bPstQzCqfTsM55xyUveQGQxTaGaJrEEdskaXiGQNjm2V/X8Pj7BZQDrCoUDU1SRoVX01SHlMjfYsp3lEF0Yj0ASH3BV5cSG9/2WqjX2E2926Yk6MwIKqhV6WiEsynZkANA9EImSgsTcFTeic0B0NzdrJvqdafzHT4F3FwkI0r9gDGBR5rMpEKhVa1azzLKoGho9o6IppuIiGalqM8jk66fw6PT7FS+oa+l9Ulpa3GSURU2eM5J9EdOIhERUZ/BVUqtfMlmjIFWDTUapuhdwxneqOX7tP8dAKuqQ3F8wpZ4j4jIHyWceTdmQTRacdWgHObnwUuNZQ6d/Q2+Tab4QGOwT2zsgrie9VZQqykZjHuF3ZyoHgCjJkiibuaQkgwikZ9ZCqidy2fwEU8DQPanf45//u8r/D3ikolnWAqv+1eEQHYuH3CqU8fJg8KDZvK22qQQyIZiZvtCzbwqG/CuFDUR+a0YqkNxK2IDwP5dhb93Gjh7PKbhDQA7gxsRDdc9dApEo2Q8Sdg12qxPIQbzbQSqN1Kr02usT1BDRzwTJdZVj3MGNf0dtTX1cZ72peinpkTHCJmuzzpUKEKTiYs7HYcoSBGnL/fmVfbJ1+BJm84qy/Uc3RkKU20oCo5ecbBpf5doqxUCPO37LNObzXA8bnU6AT4R92zTHlH8OgV4nhmqG4nd43bMKWGH6tQnAu2biZqLIuXggCT0L2BaAqnXy0g5N7KZ65J/nZEmcaEjfnh8vNP8md40+5ncntcWTEzS2TIAnQ11v7tOp3Z2Ry+4zq1rac8c4SMHwF7GIsD3TAE/xsKS5F0jXIWqWDr/jSyR5Do3w8UoSwBy/OfqPcx0VHF/vxtyRlFPdoHSfdfCl5mOishQTjRwvJ1XDxUKX2B+iV7cXLDocVr2NSi1wuFg3Am6jjZRHQrivZ67uSjhVagK2lpJDkC2VEQ17P2GIL615pImMEbxd2r5O1mo6HGm+0i6aAo+xOmEDY30hUNiqRldIZAF2xzhmKRETljcizXeWrYHkqMUho7sQh1snBLSAVc8zYFUJ3y4HXkmWSSyxGyhbY1auqFqovW3s/iHAwoy3nHK5uEAStcPO6sV8PysgBq1swadQ942aqcUVnTGPlygUivdyIDNOk5vMLp9PfvQsi5L7x6nBT/Lums6heHRvgRylOV66I4Pk5kvymYTvWM0IbKS1tgOoiHoirPuItIZ/YCUdboEOfBl1AtJwsYgMoa+1c+XclaoY/EOHhpMDoQX1aB47kx+x0ffxuc/+hg/e/3f2b/+13/3wx8mWLzyH5Dp+UHyg/TLyZfNCfBJFl1TAyEqu0CnHDw1MvoMx6c+pe8dZxk0gCXf/vZQHmH8y7bvRu80CGMMjDHnupYx9klQuuRGM7Vxuk6XVKgKE+N1pl/w338bv/rRt/F5k9+hgFVVUd0qNLpX2JnoxiYArtt6ZXhwASaO/uAlPHsyz5cIEQ9HcAdS5l5tbzxHaXUjB20OvHRiqJQQoDHyWMl1lUVCaxAdElwQRQ5gM00A2AmnzYjzI/1743C0RKeQcnOuXwG0V5rIb5JALgJtzuuCT/XtfUwtTYkdLOp62ifEJtIm8CnMfHbCAKxHPAttYiTviEgTv6TEM/HqAp3TPab4JET+G5XZAJgPzhzvkPWhJYDQDW/T4JxfOTUacDxERgiPRKEaidXSaoBdWPgNBnmwzpCUyK+jaZfv0ziXs3iLa/gME/TwqL+hGQCDUsaWZEkgbyuFudwyiSRhkHJjS+6fwTKXYg01H2kVSFgsjc3RUolyPabO5I1SP2EzpY6qO/qLMjoGVoyNj4Q8fydm+jtsvtNeYSVKvyJPAMUlGJRup8mD97OK3HdpPF2+f41cSIY8WoXv2+UCSPs7P18K4pBNbk00sZr0TAtpUgLGLytaOkKcbuNQllgTjLZ/utLVd9+CW7alk4kDiOwwm1KroahZc2mooWsUfBE64p+UyIdkTmLrf2h7H86RSvkyYq3hWp2v085J6RL5IDe2ehwug9Hme/Xyv6uZQpSCujMTvRulTHbfxkycI00cRzJDMgUSWpv00rbaNABWtqTRa956nhWDlK98dIq6JiWIiDTKjxWbycHTs9xLID8+aca/aIQldXCAJKDzIiHW4QBYi8ZxkhsYKpX4yh86GoHajHGI423e3lELVkJd5trTrnhynIiI7JFSWMUA0tJuAEQGmIEjVZocGW3ZFVG/K0BGJGDHmYzb0MgzclAmCZlTE5+Rg0U+Jj0CKXNToCFmlUnCcBTb/t8jNMCxDpOujBSAFG8e7vTeO7LQwFm8gg31RU9dOeUh7aG34SjFGrSc6YTTZmhJrW52vi1DXaWz5SlwYCWX0hmuYXRur7Di1NjUfr4DHUNA5rZma5vV1V4YVCGQDVHUhM7ZH+EeKhS2JgwI3jdOfrKxKE9XBLP4RjFvlLhHo00hZmJ8JyGQHQwthGoD87EkOynh9g87p7b7AWiUkWg6/b9Qn57ce+V7StpWJCdpadHLsz8QRKUBK8AcI+xp/37OCRJ6sPM3EAfivEuFTs1jUfaklDapRGobscn0ywFgU+biAWyvz8GnFDz1DBDppEOFQgGU2bFMFaqiTZd1zXLPW6TWrS+a7zNquHywLQ1MuVlkS0s4LERDPeYJHllb/a3L6bBZW758lhgcAJ3vABU27v68c3S3PKSefKD+AZ2OfDPCu9P5PbdKiGPQOpXCakq5yoXOunZsukajic4HxHmKBY49NN29VK+0bNih1AoAExoMiEsEuiFQyteks4O6Vq5uejN8QP+z6Wjadaw8BFAC0jZnwkf9OQeG/PEN7rqyMCJ0hxdAyrtSTAvcQkQpdc1necVDfTgAFaoiaTZg0cIhIu08+ebhzrR8V6gKHw0DynJtoy4NIdYx6dCudzFdLjEC5WvbIw6dEYZcAM109t3/xZpMDItm5tU4oztDykiFG0ykbUiDTp5H7d9iZiio1ZRsVexy5hMGhhUHgCXmOultLkEwxRBDd3NPcXSWsP1NRwc4KveKCkDqauwRwGQM/bpb3KRSu/1cOs8MwDqkkTilsDrJ0ya4IAjLnDBYZPYXACPkL9cRMpEtIxLUe2voIgbnqcmmwHuF3XUJEbJuhsXptBkbwdyasGk6tykbYsPZdeRouexh8fhGmHbsFwBMKX3dpc6P6HAoyJgOj0zoFHwPwhKGk7SGFNaMoc3mCwAMx+N26titpO5so8HD0FXWjqPwVMPnpDHdsxGo5agaNYTIfKm1uSBT6HETeCoj6NIwlQwZ3rdZhlzHeRp35KFmz7LXjlp8q9ZDz2o3jZQtzfmcQLWI2pSBH1F9M19LGYY5Z1jvD+gQcpaYXLyiOzoMTVk16e907juH4gT7svaYa4r6Y4Gt78JKAGQe1Hj+0mFAQ3r3xninU95RUMe+FSpRrk2mcKXUl4JvDOGWbi1OvQboWWbDgfR4nMcngMhwkhsKPnxzACYuAlGvsTNZx7FRLlhSgyWlpeY7X+eenFv4B7STgqidf2Rue2yWZJ7IJHOlLR6nNgbHSW4gOSlTIu+cKFOKFcDdNS5Dm9zRVFDgfGR48iPGQERKbPpGWmcHgxH2Wjh1CoiIiMbJj5TIj09u0vIlyjVFjfacgCUa9DNscg04NjzLK0wvQOI8xen9DXGmJY8upGdCOR06E1Julrp1qpk4SF3xABmzcVShKvgC94sQzXAaSzzTjUPXINclEZJP773UWx2N9c89xNTWnCJtIDonI70tyeB78yxS5rTuMyLekjJfLOAUkKsr8B0A6WXKWhcQDZ+5CdDGumIiSxG47oVDvi6P0WWkdUa7e4WVqbSXwRo2pZCJDAYjfpUYpzZQa9PNF+ehS+6OR2xNjrES6WeEbSi1d5N1rznrJKHUbq5zAoCV0BdxCiDTDi/5TnHsSHI8kQlFsKomHWm9Bp+nEu/QH4VAxqnvKXJe9H+FNlFiaTMTEZFuvrXYDT4nSuS8blC0JMd+ZgoHOvmh9p8AYNLi2YcAK13f5bDAlbKfRERE3iqyoetlRd3YlV99ADM5hhVDJF03tqnV4YBC6dnbkNp0hgCkMe2fMZcRaJeD64ZIIiKiOI1pOmaEKRYykQE4T4rUc95JAslzl9C3QxX4LUOgk8/GlBVvQ1TbjV6nopZO5aFbPDulT6Phy+Llf0/YkLNsa0BueGY5WWqAp2Pr/jUTLxfohGqKQTgAecLs2v9rQ2B7ugQAU6/1RodnIyFqZVuDLPVMHpl37IZhMBhvvp7w+XgS26lnV5ZYa36H2auhJZD3NUL3QR4rNe05TEwzuECDdKso1X51C82v2UPQgig4Trn56FVdM9DQJsN7hV1CaSTfHQDtC1r6lP7lGFhsENYAUp2ObxeWgc9rdq/Pw0QDMBGRHgYtxVqHApISuVL9tbJbtUtbdSvOkVYVCjEw9QcgO+G08eO+yjWqqiDO1aWgE+1NXrIGRlmU0odSK93OO4C0S+4OFYpQnIAWXbmh+Xo9NMTmLD7CCfbZuZl9zACY0Jwms5yNoKzComXaP4Q/SJnHAok7+yx6EPRwUSbxzDHJQzOohHPQbzC2YYxntO1jRupaqTT1L6+YTOeii+bsi8B5nHVFkHFG23pKFuRMGg1cguM9IZCZMqglyvU1AiIRUZIkdU1UJ/DOcAWoVn3AEE0zUWr+WcBcQA3HAPfZOLn5S0OpBsM+C0+jMsPnRtsI9QYK0fKPDnA1m+fjTdAWQ6fgkJQVSrF2OfIz7b30d3JOrYXicChIGRO5itCsy97hUIxFThwjV7Vz3/37KMu1z/I2xnm18zyh6XZPSryhpiFxOm3OXh8GoDxN8fCGGj1byGXaoipKqy43EpTIXcwI+wZc0tf93qySHXVGY5r++uTQVcZt8PNXhyJGPdLYki1pCss0djbUhnCc90n3/Z6UyOUJi9jvTBDIgd+fEOuyLNe2S1qxOp0kDyHeWXcPBMG8dx/YWwE20YlJ4xLdjo5nkVNG8tA9/QH5/uYSJW16qnR8xko4upslN+uFOuq3bPmtYZTpJIYe2JPYXjZZ0GiD1Ygto13zA4yfQHadRToczEwP3AKQOqd2z6WjOXCpYw16VaEYiqFfp7/1GO1Qu8onvavar2z3TQEwkm4/nbAhXU5ERBSBV4/0OovkIioF3Ne6cTgULKmzal0K3jUMtBBhTjVMRA/1Ek1xKnb9IgKKEuvzzogX95kk1ENFFAaRgC/QGWq616Xsxzd3+JSkRIec0oKyKyHwKPUIRBApLqmOfSvFR9MA+qOG/axeFrqPtzI6MGIew8MwuBN+yjKyC32U3s44+G1wykBRS1vOmsacSbks6iwKXcqlXrJCUKuzHAgRLtiP1AhsYqqpUEHtTBnTvmVkPQ6A7W2LGkfdwGKZgDrhtFl8UKQTxtWm5wYpN1SbsXLW7AlPL5SHWNr+aaJnPKF7fe9QuT/h9PdtjTQOQebUdZ51Q6fZ73j270jn+oc43bQR9QZjuIjQR//N17/+OXz44W9SCscOfwB4RSdxdSZSUje1ZXrC0/Z7+N5//y186zN27jneHevnUsMS4aZJknxiwvv70ZEElFrhww/fo5p2PQtuarSn6YzNDd199hqvd0HyLecpTqcNSbB9alYbu5j2iG43Q1MayG4FhqJGdDTq7ELKnMq0y+VDIs3EwVOhIXKRNxTEMGZN+laQFnRbFw6XQMavHC4pkYck8CKSBrEug+ijEdf+mUnCcDxO6hmAlPnonQqG1qxrPRO1X/lQLgfAkt6x1EiBup7wtJVNTY7q/81VXy0RAZCOFUBzzCrIWx0p3NdjnKGdnw8pVii1MlGiAcBwOBQT//bTAP4b3WXLW5/nArHxcozR5ve72N56yylzKQdTQMWCUS4TxoCihoCcuu1v9vcexRaBTwG8xusdOSgBOUcD+dxHqGIAnwLwyzZltcmytTpCOkCB+s65WUlcWHpXXdNNznknqOmq+sD8fOC+mVuieZ5+DEZFJ6/d2jZHNPuEGTlr+ugaFnhKrw+gVqgOhUV5zUz3IzSjgU51W4WqSBBIhpuQkoh08VGbEgrHiQOj8aKJJ1eKNUqxDsHAx+qECAHaP5IkiaKlQXZJSuQUOYVFnCMVR707tDmQHls+synjkHJKkuTxEXcxygoANn2L4pUCv7EPQQcdKmpcDSgwJYc8CI8aYPVolaTRqhDvUBAokAnHuMMZmuwAHCoUuh232ZHnEVudi4oApLQPg6he0b2fFM2Lq+ZlciRsXVpAnf2mVnaOY1QzM6FVhWIM3jeQxDYfvQ6tefSE06avE/rwIX7+q1/DP3B4pi8MM+dIISVBsmokam6dFoieO+dLlOvLMeqHR9xNXvOtoVdq7GcASL2ZAogV4MEHAdPyDC2fwbnfCGHUd/KSOPpnqaVEPm95UVyy1PBRUKOqQyahSDYmnezkkgEeH+66zhwnuZnjBCBJGKpqVNlJCHPgcONfgCBTvaZ7hV1ICgMAU0qtqG8keAc684Wf6nRxGE6A6xlzcubJ4YrS+6MzCEngaAthoIrybSrVe+S3JGE4vb+onqQ5mCKTo+dAR7XJ6Fs+bJNLOWwwYVMDpaiVKFYZ7V01rUPGALAan15keBLbhZztynuHCcgXxu/kANiM+OYe+BQBuoQe1iTEi2MaBbWqUBULUQqjRhZjGlVqHNy1VaS7hcCBk7EhIpopJGpC89MS12W2RHVs5mcsch53SEREC5HCp3OHOAdP+4IFqH2QIDOh9QmRA7bESxIii20czQbjxtJR33TiMo/OnhDFLpzvCBvXnvUyAEj7UOR82CY3hULbSBm7LD9f/sbTUB1LrdFUEO9hOWU5BNbSpgNgUon47PzVDWXLBbnSsXjGM32UkYNH5EtgF7Vz1hio7ZRDsi2kECK7NfaI02mDslwsrO1+v1ylGcPypKjv53AoCDzHLtXNnO7OnO47bi8pM4UhLyXy4w1IVVe9AyFgLuBwKJbSvEVENDFwCSbjiVK8mrqiXUpsXGWGziBQnge+8xrfq0MRatnJ+6zELfxyZw5AAGOGsSJDWrxkZgIEqS2tSBGSMwdgFdDzsrG/P+Rv8HTcEt7Hub9kfH/b4YDCyw2PNhtKOEfKqYPTT9aWMoeav3qzXiZFGYW5Z/j4iLur/7aiCYVl3H1f4OBijJcaui/PYjxSpRDInNg+ecLGJLKehMyf8LQdyNyZvEinkVLzTvHoAIYJdhOhQjvyWnM2a48vjwEE8W3kaJVa2SzlhVZyIHKvuD8L4Ge6fj5mi9ysqK/rZ8fjdk6NmS9snagr40mztd183DgAK5t3IUbI7b3C7nSSG+rlCM3htp9SXzqWii+UTrw9dq+wu/qvefO/VvriF9nfmH4Zxhg6f/ijH/2YJQmmfvbPfpRkyZeS1IwweDgB8NFHGxfG+IPkg8Urhi4+ZoyBMfZjW8/xlSRhr9bDjfn/8hvsv/7yL/9PP+yTM2Fp016zvTJ6h5ID6fT+jy+z5KOfnd07UpfuRsydf/srefKVrzi7GwnkfatxAWSQyx3T7XUCfImM+j1cs8+Kspw1tqLz+XzvYjVFQiAbwpPHJ2ynrMT00knzUi2IrK8M4NooAxgEkgK1X4XQcLZXWIkSi+PPOY4PpwzEM4HIfe0wBZCKZuHPa7zejb20EuXadC2LGCkspTGo2xg8hbrfvTMGarUAPbDRAPGc9hlNHI9bD5yAfh4oxfp6OmWus09E5KPgezvawy8W/ozpOsXj4x3dLNE8uQi7lj12W5yuBsOhi7IkkIc2jQMpNzrBmxrdS8129u0dTYG5juz3IxfxlAPSsABY46XP7yRPEpp5jpX/LHdVO5Ix+yh2SNgAOWVJUiO+mcAuCFEXkkSSA+CMdDXljD3Yvu8EwMZ23oPzVFfjRhuEL4TIlgzbO4s3np62joCQ1gA2gZ9fRpGiJX0okB0O3WPBAsim9JG4JA6kLY3bpo0s8auFc/bjQ5K3ox3aPCsfAXsAsCXUg8dQmzK8dgZ1RXqQMp+Sgg0xk3PZv9LIFqElupH5Z3V/KZFPWSPuwZswy+eWTtUnIWSG5AQgHp3BeJ3triF9bzmkAKGs6mbs1VulLAn4pI1h25xBHfVTcG68e1dBraQHgDZNcy4JrwfyTqVAomuDaoInhJiWjee8G7ODeNegh0vlgFHnlYXAjI1nr9Xw4nAobm6EbHpXlsILghwbolD1mKdBHxl6ommMU5brMct4qIlmwhlXVXHLqdDZuzL5GTlPcXrfyjMQ/xAREREZU7DDvVQIkY0cF0uX3gcRek0ewO7lpr+EUb2w79zUCtXBm70h3BBQETloRCEpM6rRXZ/J03FLZ2LcAfCtQXVUFoduMXySkHnbtNJceoM3d8QjREREROE4JYXPSltAZCVBKptxRoX/mRtyKMbd6fXZUUOwLWFSahfBe5CwEXnHk8LTEkOYY312725cueG5/mlG1l69/XdddhyVQePg6SUarHr9sowVCz3i8VkGhhwAMp7Dn1/KHE9iSzdJRBSnzNt+3hLlWkJukmQYbLw43l66BVmXLtp+JoG8C7To0gmpjb/ec2gFf6sbdPMZd0UYHkRDmYWneDqS8SYKmYnZtD+bsqUxsF0CANOxSwAHN42I1sDZHDlkdSPsVfZCyhzH6QHVeddO4wjkgcs2CB/fAhPSKbxUPMR3A/nH5ZwywKZCzk65XyH8XIPbRLjrjgiTdszrsUUpTStYttNQ+9FjMI3yTjW+WOdnKYUVMUWcwj52LwQpRaJ5Z8lTqP1qxLmzlqivWHr619TeBApGu8kXNNO3UYHGfQM3F7tIiZwMRb+yitHj9YfhzdPxiG1bKhZSbkLoCA+Cp0bUfgXasTTISCXJ3mKDZdc9EBFFYuhEhpmGDq/vd7aEpES5ttH5DSB9wtPbOh3UvjMTFIMDRE7u4px2dmtDIdG7c6JTiPVyk4ThOK5BrvHAV6Ewb4ny1c3fESIjtLZ5isDXuvEYqioUciHrVq+3w+looiPj5u07prdGMgG8CuEcADAdmTgALITNiFadgClMFYoAxirkfYJNNEHBLCTaaVakprrlmcjPuz5U3ZmOkHhex7MKgawsQeBZPpCti9A5KnJuwJkCvEFE5FB5bmJunpu6DVFnj1OznTMnbiNqJQ6kU0d6Fqq0aFTtrKgaxaIjFUbnumiZMo6ABozbhpkkSYJSrOfw5NTOeKFxpTYB1ARkVy7KXpb7f0jxDqUnPG2X1Ik+QoGnswVgwQ7A0jM3pu8eAGsrLYLzTr6jbBqRNf5XanU5jTLGedwrrKhhmIjIK4M2vIkNQPrwgDtTzyKO2CaUXWk/+xtwtUREIQQLosRaSuReZXqaWc3nD4SEnXAihCyK5qZ8Zu7LpAcGpGhxkhtf0B5NgbQQWeC1OkORtjmYWGQmEuz+ftkl6zZDz5hvGasWvOUkeb7ogShaBl2ZYHpfmpmmCFpT4ljchIQAMpejjOdJilCdIEiZQ6mVjjPQ+VxKYVVVejALAKRiVPN1PNksHA7Fu9o/mDxhY0EgwjDCSBJmy6u5V9jFlCYldLIbZyNEhlKsLd9H65IQ6icxR/KEzb3Cbq+wCg1gR6feg6amQgDMxJSUBPK+z41NlwFgqKr38LWv/RoeH9+W/3TU8m9iyEAvZC8zHZXZAgThkTX8QO1XUGqloFaBCUZmviFsOP67aQdtiVkBi6fMQjUeYzOlKMu1jWBJSv0RalPeu/nsD4+4i6kpEwCDUis8PNzp7kExdk4AsssURRPVOKvHCIGMoDPHe9s+P1+z6MkLhS2EOWfkGvmOyIrS9dqIjF3A9uxvpdyYH6Wcb/yHRricIz0MLDGgOhSEnGrZq/ZEoAl5jsiol27xu3IaO3su27rP37dMAID04fE8/QGGlmydBHJfYK0bHmVz7m1ML8bQ+wLU6O2wuEKetHN+gWRjodTO6b5xw0ycJEkiZBh400SLMXhWVlyHkjWzdR4aDOL2nbGW+eWyqhCdEpP3ZqO85/O5O393VFUxpKM0ZsN4Zk4rmP91XY4NeR4i40qJsLYT/xePoKqKkM7yan8BI3melx04HrGN8b3p9onamUOpHTGIn6Sr47lRfGmnEelxyilTRWTakfFhTBIA4xHqQgBpcgMTpJl2IxkP94aTRV/e3DllX5Sguyiy7BuBWod9tiLDwmXEd4oNStb1dA0A1jZWDiCrUBWq7luop1SOYntZckdVFV6hU16PDkogV7RA6C01qIduDIjleXbfIlRdADu+d4jbIhORIE7vb2yM81YVCkGLb/RFrRfOgQxso6DriLpryudi/Pdtefj6WZutrm//WzON5EY3SSAH1Op6RMX4rLYQGaVFiAY6AKEpJ2/XNoc8VcO5mYVSkDIH5ykkz5eik2zhrxANUhjMyfQdAOYq0kc5fn2nI0VeLJMnyTmbd3Z0fiGREMig1Mq3Usbbpma1t4KfMaRnhShyOh6xpfWDdvaY+0KHCsXlPHKTMs+snDFtayOaQc2mNHZtOMdAoosSa665PCJP2MyBH782xuSUR2BTynIdgIO1NEazj6t/qFAogomNn7Oa9DKdhNHo/cU4Lkqxdr1NT7cDLTyasydywE/VoQAoO2MkCuXWUaPmOx0QIpsD6NQXfZtAa5OQ+RFHp7PATVNnauueScKIAtOHZGR8vBchMmpkJnpuoGemz28tzQGw1d2A5wJMRUI+SxEDSGNbW20iy0Aw3P45dZb6ALxuuuXgaQUfAaXI2ScKSZFJmccKCX1JT3jaxuw5AzCyKCbkM2uyV6OX20iJvK//qcQgBND1kAbisftOmmZA6s/yILN2PQpYL9K7CDROcoPEQ3wMAOkbvLkb8zf3CrvQZkVfRJ7UbPb8TGaWEMZGqN7ghCu1QllGAx08FEhI56rwWI2E7To750h9QOkjGk998/teGv/JwuEy7SX5bAGBEFlMSj84ZXySG1ugRo2hI6Xa5vgsIOOzRFIKK13Q1kum4xHbJDYnGYdD0YVKNIbaxm2sGY9IoUaXFpURLTti8i3aJdkz6GwGWKqY2gxuw/lqerLY1MtgANjY1P+VAK+XLDAmGBpA6vP2NqLF8Tgb2mB11itjPts2vkiXw4GyXAsgo6jZEB9ZGH+tx+L8KOtiJt7DELmgrKb7S37rgdmsn8ducCDlq6Cemeb63yl5jwMCAKxr/ayJfiAAha7zaHQN8dlSdCDddWjKj+e3RuiI7HjPru6ebm3unfs50wzwdKqDp3MSY2xmxdAUSAHgF3RFnkteiwuA6cj0YknLsEwCUjRjQrtn/76C3SSvzG4ETSkuO7RXcF6frbMH/k3lQO2DbJQ0siSpzkL8yrUeBsDOy+PG6EkA6bIbsWcCv9VnHcduGh9qHpeMe83IzSIgMkiGz50oDmNBtFxest3D1GAsZEmSJCecNomDBnHalTOTqgoFIScRERGFafgStqz3tbgY7UbvxttMQuPElrCfUeAc6aGKdEssACYs1hlCjgbLctlTEUREC41606WBijVG11pGdO5ulqGr3AEwHA5OjDmEyLwGC7LEWNmEv/Hi0OrUFzkARA6jJcPvEasxu/z/lylsnQEJgHQpEyMQIsPj450vdf7GYfG6SfsSn8c74R0CUFOiXCvD6wmVwup6lrdvS52PtXtflSkAliAhJ0a/A7D27JlGd92bBHOBlLmrveiX+qGBc80u3nlHWb0ZfM952tZE6equF0uHw7yZ1NrIhum9tnStpo43eKW+CgCAtQDtSBhC+z1WgoBjrjlIq1xBynxMeh0d2P1CIOOEsU9E9Jye8LSVaB9zAfDTAP6RN0tb9IFq5NR5TqQpsqfo8ML4S/lu495ew/rgsWN4zaw6ObBE7nVDEOWeG+leAJ8C8NNTPtbEnoBmXpkULhFRAMQ9cbIB3F3rDdIjGs+3I83v8L5NQLSzEuVghFJImeN4PE8usCSpy9eL4TvbL1tHYyNShSOhe32G+iWMAqKl0BOeRi9Aafv9prZPWUBNBhdCeFMKMzWR4TnMdbpopxZJwkbVCg00HZ3HTE44bWzOozaXT2nPuQ5kYDsIWp3UyI1aV7mSiGiEsLMuPWq6iZ0cgAUQBw/+MpYYHZEAERHFT11IhQIicwEkZF6xLRpv2aTBEFmMCGAAGErxavH3ezptaNMfERHRLD0iROZ0YRitqTVlICQZCP+cl0zXzL3v622JNPOORRS2JmUbBHwsSkEB5Ky75otDiiQaoQgU1E53BL/U5RQhIH55dl7Gtlw2d3G9UIs5fuHWZTVIEgYp344wgvM01DIYgKxCVejkEZfvwzlSeXo3XkpENCUqTD1+Pq0CVpZYV7EupyDSy3tCZKYiPN9XaDfIhsFkeIRAJhcKZkTb9swbocHjNSXKoJbeSMhcJ7rd9btXqAqKOomInsmI9w4oysD0mESuFOkZQ87VmnOkRxy3wTdAT8L5HjFHvuS6KID0CU/PVlMKxD9+FbhwU/2NyBf9QT0lnup1AJlEBH0/OiFKpUR+tR2L4E8d3uvhQKn90Q4AYSSMV4bU3NqqCzWcLTXUeWgjCUytgzh/DjAAYB3iQdUje2FPQwBgIacAEQGIy3lbIqTMm0ax6CYFmvca9E6oqqKzwzmyc7Ele81GQm8csBo0be+F3hEl1pf7JnwIkkNWZquphxfcu0qZowflySaakoTMr0sJ0Xvcr+93ob/HuZ/kzCeAechrl8agUZTZzZ+3jM9JIFcKuxh5+fv4/uc/xsc/a/DUvdKvtUNIGaEAlW5yU+lOSUc1RjKP87yQ24LU9aFDGkDaF9VQc6MHfOlwDrtJjRY6ebXe8HcbGKWRD98cCJYkSfJdfPdXv4/vf544kygIJ6DXuzvJzW2Dr8/7o/3pbg3+s7sQyMqe+wgFrGSmI/ZqIfefTZ2ndlG79iUNrntnSKhkYsOrk/s8Hrc2QZ/8V4A3IgyUYm26dns8YutqzhPoLw1EZOicZm6WKnR+IXFSA+8Imcn9uz93JASyGPo6FqWHwvDY3D3j2OZA/Omf/gL+9E//AamDCWd9Om3evMGdT6AeXTXuBiQmnfG5xflzqaPeK32YXmKCcI60q7sfIPS5xQTBsTYEXsNxLonKEmsd7y6O2J6VBL72tZ+AUp914n3HEEXUd8I8k48iTMeZaK6yB8BiHBNVymxzakxL0ASEVuhkIk9I1k19sx2A61FIswoqYW0Ro88GqWkUywx/ByM40PiM8ajfV2plKx0P0AbVm+fzdNyanAyoeYOc8AVxVMJ0wvW2OgQnbK4NFQA2JUXbNf40n/FFdt2U6VvU3OEAjEGSHH3epab5X5sGq/krmjfuPs9RRtamA6j7zi57cKREPne5DYB06nQIPMl47BVWDfJe9i4aR1ZVKGwGXVPPf0jmiPAGxgnI+uL/p70CoKG2OvWCIGUOIbKyfubZF1yDbSyjGfE1Xu8CffZsiqLQoXCnlPKmjpr2NQa7InEcvq/EpWE4PmHbp98om/Uu8AvRQD6+wd3jmzd3V/LJ2nTGnvY3THcGOn/HYjrQyjsHvH6UyI5MNAhxI5XlBOcWYL4gv4V4Tzo39gFIbTkLHEiPR2wjvpu0E7XyxpkMOX8vVl17dtg5nQHVEYn0KmhflEwd8YgpGZFBEZ8JbPYS5fqy2etyUsPbO7ecCue+YC9AZLoDvClZtL3CikuyZVMOe/ERBAGIkAMZ7/1MU9BDG0apdjqcHt/gLrTsYZ98D4FuH/2dQmR9CJREuj0uYa6xDye5IYzqbhIBp6WoHPLcGNr42wYKe73UMw5YVsIH5ynLtYWdGozsxbUBDRikBJLnuudRb0UnHPPr9OdarhUHQCDrqgELgUxSaisIUgq7Lr4DeIonsb0Z9Vwp1maZEZWnnsvlaslnApRrE1NNosT6/QHTO5TtcRA4uYBEnOJpnzvurTxfVRUo22v3EjJXM9NSQiA7HNzj6587kdvquIgQGMUlmXa0YotqdDfStX4H5ykOBwJ/uXAUTeqZ2PjT1+fyvnTa5WkD3bPuOjr+Hx6H1cnG7EKP1WOk+rteoXSxFndK97iN1ca+KFkkCbMVVBDFZewBbKPWkXOFD0BaNh3wAsMWSADYmKz72lRsTbep03SieAF4xFMfFB6EyFBdw252303XXHUfXXZPLzG9OAVJzfU5oaKInMiv4MjDldQGX/h43ALIhNBnvGJZIRnYTTLXqHljnvV0AxVtajpYSmzOThDUfkXNPyNvpaQRVn8Nk1q5cJbqznzKmgRDo1OAUpKxDjba009SIo9lCZFtUgqrQzW910MCuauZbCQJg5S0Cc/nyPRGNk8ZQp67VYo9Z2+bkheNP4cQBU5DFnP4Rv/pD38G//H3fi0sJ8X8s97qnyAK1HnvAf2ZXabTiFHh+zRJHyaJiWgaADvh5MSJKkv75UcF/zFPYkKO1cWkYTkA3xOfxnf+8GdCUj73Cjsat1tupGboc2d3yetUhr5nic4NW0Z7jDhPr8/Ut2kapbCTF81rUGplutTTVUcH7Ddh9jm9zQrlNAS7QnRxaUs/Ax3bxcYJdXtDIYA01EU/BpUfNbbpcDJmRrXNiFTMOPesN6uDbkyQkec4drqkdb25bxE5NEFtX76vTqfTJoZMkHQ4oLi8QJ0eeJMtSX0VfsurUjPgdi3QG6VIo15BZDV8/d6RxmN14+edmwx1yC4ANgXXYGw2KYS5fh0lkD5H59YY4GVm/f4GiNckB6DHpllt0vR9FlJqfD6bYES+CtU52+L7rm4igzJPDpV2J5XSzXpJR1YYALuFkustGNBpQvOurp3lREREREQv6XjszgBE7N30RqyBOm1eO2yj0w2MsU8YY3/X89re1h9GCdYFFHHUAkkRunleIvL5Hr1KU//oR8mPGWMQQDZnPDQoYkmSfMWPR+HgqYS2noO/85LnOU+N7fZpaiLPHABfakElhm+SatLX55nVKBvWEKnnbYOaxTuUktXBhw52jdT8nzCTtVANC8FS2w4KgJQveMOmhMxdjWX23o0QWsa4rQI1cSC12Xk+WdA4IcD5QPcKO04rfmcLeFDPezpt5jgBvvaaANjNXNFsfe2yKLHeezgxdcJps/TNlKiqoo+fLnvQBi394UA6tgmORgysen3ZmK7dRmmMylj4NfpEqfXZJ1hDdS/mHOUJm1sd3QTv3C5jj49v7lAGYlSR+OfgacRH0LVg6xKFcdCOAgDp2NlZqn9ajSJGj6j1pQ4BMH7VUdy5Rz7gbm4FtWqr5wFgMWLYz3XMh6zgDlH28XTcwkMD4pqqQ1W8XLg10vmyOJkwlPemYBBMedcpK+tvPLOfKK3N2lufZrZTykDMo8OHeO+r38B/G84ioOm8wluiv3hXvM7ezlncmlHnHKkPo2iQMsfxuCVJHnlmjngepdDibJflcCM5xpgqqNWgFfCGDbQWnAe1X/WdN4B0cJkQUuY68cB1RDmXSkiUWL8fuSHTkkW4qJ8JgfW//To+R44UkX/R27BFY64aB3ufy1PH8taCHl/u3nfeNE3XDkAdfCcjV3X7FbA7i/IuBXLpJQsAzNclHL4q8pnOFqWbr86kLJfRwBVbaanpKcoMffbGJq6MhMx5QP0gkDKn5nRSuKZOjnnC5JtLJtfVDOOKBERWob+uSnwbpq7hC2sobOQxN/TZVoOzI45bjTP+y2D4a6AYXqcYehuF/uTjH3xK9+Waau4gIppCQ2ShMxqRyMkBCPK+tesfSD440hs02kXkdWaxaez2P1N0qFBc1okBMAmZiwEgAkqplSEHgJTmPI+blIcH/EjbKYne8tFJbiA5yaUGOTwbfpxOmylLj6w8L+fp3OkLJyQkXk1wxbQabCGwNtG8ZsK5gFIrnxT92AyKU4eLHL1lRtn1pAE19eqR90XgQQBIbzVfCogsoTFQ+1SiXOuGVRTCTN1oCqhDharoWe3JQo70RIn13LGv49N4JQQgvVfz4JchRDbWyy41vK8VJ25iY1C9C37vPT9Slk/bOeZ6PkdkY7rROX+J/mrqTodMXYyBgI+RGptJpfMQsgY+vuMcaF5XBhVA2ja+CiGyrvpgCFCjgMimjnMBYK5GwfhA/I4ap/wdv4kjtpQNClJzsBcBVhfY2MQRRZOAXgDSv5DyVQyj0gBSrft4mtGQVMPnMF1dmW3dqs34246EcTpJiXwfUb3aROdxjZWxp5p+BymlVkPX3DbAY8y1A0nkXE6dO+NSIh+zkRFAXuK5Q1KW40rWQxABf/dP8Qtf/Sb+vm2lWfQpUQDp9bz5rVRu2+ZA3dF4yKmPpS2/CHXKY05UPjaKNnU+JufX/6jETx6O+B+PRxB6H1E7/x0OhS+Ac1MDBB1N1kO++6tfw08cPsR7GhUL17JNq22X8l5hRfWHycwQbfTT1svR7DBYdUXZhk/b+zTz69evd6Z6SkwqXy6R/+638BmbesBGaY6mktyeZQNvPNhxHdoLYBufwPnBv8GbO2FoP7Bfm+Z8vgdl3VE64bSx2R3blI7YhbFv/e4xvHg4oPj9I35ubqp4yh5024qCRsXG6Bzz0SSAbE/jnO7uuSzXl5npPpKQmyUBOQ22JyF5O7cMh71n4ClOcqP3M2XetrYUMIfhfV2v0nlHbXWvZixJqwBKic3vfgO/tN+/VMSmYVkp+ht1WkbPqob8JthUyhposzGrsM/G0cIzIGGAuS9uvL5Zgl43Gk1XFkBirZu6jcnr7tdpSFK3uuAjVBAUMS8pkgkxgo1yK2Vb9I187mivRX7LxmQWrDzTTJs14uXnMaXLUaPhzyiyrq5t4GmL6lDEKoiLqm/FHPk4WBLiKirS/66e7MGwtKjMGwfKE70D4M6WDtT1PQBPrTiLUPvom/aG7DIgM+OGaEXxkMhRrKc4qQ3KXu6rTNqQOymRC03TCCFs/gPAHvF4F6ieNmKLLDejOuYRsmUvogkcj9SU6CnxSOe++0YcIeyMEvpKEsjnrAyWErlWsBOL0R1Rt6Fe+hkLIKuqaeWIoeBbREQBKQVLqTDLBqMPz5zoNqmFjxtXqAoFRRMJ4+Qx14VDo+FZurB1mDEjTh4sUXBCK0Rmssl0OcrvULjoIyAyFSmKzDbOgi/Gc8Y7rBbdKBz6BXpyhqREL6LzEuUr35+zAadayiTEeggP64LkJloGtS388YLfq0MByoQEyFABzvACYHh9T7sGzueh1Mr3WWwATMp3gEStv1MvpMlu/TwgHs2HngtxsBkqUb7y+XwbRL3MEX+mOgNRWMyEQKkdZdG0nGTCJCTtACcyTg+P/SNAKMu1diOPpGNXRRLV/gorTndgzZK+O1d1Ot8NNgiALNTsU+1sUDmSiGjRBmnI7wmIrA15Eep+d6l8TWSVpo4NAmBVVRWhnjmRbifBNQKrX86f68kdkoMwBYk8xriU4jaI55yQqgREhte312kDYA+P6JwzlxL58Yl2gUTA62sTuqtZCjaIN6HUp3E8/nc0xt2cx55WkIcoSJTedXPurR2/DSoY3YmhSMTlimcAqW1sAF/ocEChIltUhLJc4xvf+GldjsgJp02ovWdSEsw5EZFR40VEFCr9wRH/+A/+Hb7Qw/vZ0OY/oCqenuKKvIeuB74kIZCJ0i26HwCmaAtleOSacYiIiJZBD4+4u7+/vXyn2UUwLP3eh2TZYUi7ovWp8/djF5k1UwbaonwOpD6ugHaZaRv+kDOWXwBgXQt8fCZ1MXM+FdKRKJ6I44TT6GkXBbWiTMVgPUHLrhzQE562bd38HjQOpkvouwKQep8VmLv+smUtbup7E1bfzDnRoowT4xHtrK/xEvwagyJZG6ebKJVMZEII1y7XLTYYz+mMD2VDdlf3dUCPJc75YpuWiEKUc7XSPQZ1OmFDRtwOca43PU5E9DYyj+Al2MB37ap9rdp+91bExOHvulYrR77fr2hMkqJSE0FCKIhttL2NaDKfS4Lz9skJytsdgO5LCmG/uOEzYxT9RWbQITe6nboxs+MNXxkDbMHhUOiA0QXATlJuXAcAAIq24IUoAP25lG2il0YipjrW5QUufT98zDy7JOLgUe90v2xsBsDGdqk74MPsVge+Lie8KQMbz7pALXvxDwDGY8sa92K1Pz6+xXMXAlmMafOQ0pZvn/l43FIE33E29YKheA1hCGNIps+gFGvfz8D0Pcmmh4OyeUTPSIxIA0LtrWyVowibzpMoTodVV2qeaKSeL/shg8kxMC6LOeDZqub3JTZJ4tfFh4groJPK0gy+t4/GabZiM4AAdpk61vR5o2bgfYvSALAQp2CacWQyakPP6+HhzuV51fcVb+lgKdgHRDOpGbkaCE4EFmqHcrMHIPXkWd4aOQmZ6xTWClVxC2egMfjvXSoK4dUc/zyHpHGAUgd3msekcKfcQXMGzNb3jfv8lzweosNGI+JERIFTWWLtEhEy5siA6s6aznFCKW8OAiOgD0slZpInbMgJMEAPj7hbquIQCKeJEqVY4/S+ltoWAaBcKRfE16Q4ZqwWh0MRWtPti3fgPDhgH+obInIdNeQuhEb39AKk3EwZQVoqHOhrvN7pvveQO/1dQRQ3UbuRrMQYmYAQme8jfIP4z/BYHJ6OW0DfOY2Fku4bY5xCSmHVpYt1fdec1dTGSkzNBy99jtLJ+0uJXOdWqdCjlxBJ4Pk2NbqDaYpRt0InMnhfA5ykuTtfBtgs3c24ncYZgLPR5jNy7OXa5sYByjR+AdXMfFaO52zBm8fHu9AjlBjvJ6blPv6db8J8WzZE1NyNUquuEosvgEgx2rY5GRCaVvHIYepL/zfftXr3u3RvRMZ42ksnBpynuno+iPQ7vz7jLDR8vZ7/ORPKqujva7jlQBk7D3W/g88BSzOuVXjN9JrSvPcKu7dohuXt7YkA2NlhEAIZLQwh0qoYCDBnFKnX9abQOZ3vLuhQoSDdYV6envC0HfB7aXByV1UoTI4hNCmK1MBnFr4zzQBv1jiz4HAofDgLBUXLSIg0Rz/6eOqso0JLpwJgychnbnMYGn20WwTvqPudzqbHmRkNtw5DbfzNMb0pBKMQ8Ln9YHbzhhcAuzX6A4CVWPZWxKXw5djPB8AqVMVEoBqqoWm8oy4Uy3o5Ujx9MT69S1+WOA5PfYHz2Uvrgg6hW54aZN+u3TV2BnuFFR8p70gSr5dk3RopizNCfg6nDvCUpmHsU4lyPVpWxYRou2tszkQ9DKUwFgkKgewwE5HNBQTo5frRkBw7IfEqLMWmVjZASi6bPZdC8oSNr0ayuY98xt8PmvdeAgAOyglGicga5f/lg2SVJMnfjfy7rt9nzf+g7QnXr4wxz2/9VvLJV76S/O3Mj/lE6/sOe3AwxhASozHGAOC/BPXMv/EbP56j+NgXv/g3Q88mSZIfJ0ui/5T87QcfJJ/4yqtJMl0vMMaGvdcHH3wS27U2jtPfvdVPP/whEiKiZ1mCkuq7ummJSH5e83lLCrQvKgTABG3wmhW50yk4vwPjqf/jE7acYLwDZZBSrHGSm1tCbKMRjYjIN+UIgO3JkZt+vqQ3FnKmfjh6HEglIVjq9+JpOYTBs9UMoUnUedbrWMakKLJe7lkTCuNth16BHHYSTk9JlFjXpYF34zpDm80aA5aPUBTrqdECANZXwkBVFUgSFsoqWwCfA/CFhLHQeT59fKRVrYt00AHG9WOybLCAMtfiJ4gixWC+O48pmnw/AEyIcYqgS3EcDihm7OjeTKnpmTibs9J4/VrtQkj1NhMxXmVboNTKlly62rC5cOch1/2Zuic1loJFHwLKn9F7AJCNXZKiez2usXcrxdq3yz3hpBUvfQiW9cuDqdGymjW7Ru4RnKeoqiIcRSBzlzPRAKflH6YMLpUqW/W+oLLBcCfhCkPB6vdLmSclyldL9dQBkaE6FAtjOi/T6CbhpRetZDhPfYAxNWVsHK5pTXE8bjtl7PX9bpH8NgMXZYmOaifKopT5ZZA5NRur/dCrCsWcUaUG533ny+HH0OTSKMJ06O+OyRZAYx3w+IRtV4ZHSuRCYE2OANEI3ix8NRpU/pigiw1mVBrHhIVydw3YW/rCTrseFZ7rAJBwhEUCyHSNuvCe+p9SWM3lDZ/ngzlHuiSI2E6eCqTURxSVgzFQL4D5vC0RADscUCiFVVlq6DHiQColxkSEi60pco70/RFnRTSKsdfT//ZdirtZsZz6KrwmlEtwIFAjOqTrOinN9xMtWjdmlwEZ57UN1mOHATYIt7o2/OS1d53P83oNNV2NZ/J8KsAHXt/vgGU2ZNU1/ufyO6Y2DrXXOhnAwVOp8S7OUzeHg9k15ESz7sdJxCwEsiRyXducb3H1b+bqQUgAh0R51AVLZI6/1meF21U3dS2nnCOdu2SrLcthW/H55MjPGee1YBdyR9+dGvzsbBGonAp602tDHQWXHbyeK/hM94ghrbU1pvhWDr53FYIjHjq/AUhNbiKdFO0mQ8smfgYgjcxsQuCRxejMEnoX89TwiP1OhUkHIOT5XEjZO0bTdD8PFnIBkcmFpciH8jUApjtaJYrK0UvnyKqTZ54ZQDTvxQyd5/pKj6V9ckzBC9Giog+XzlMsNHbUkU4sLPlWr+3sWbiV3oYQawIDsqPLfcvIEBFZNfiuR1OEW9CVToz0tghiqQYdSVyAPwBYlyMnR+2poBKYuTuy4wA1e0BYLHwd5fp2EjIzJAega5Uo1xWqxaWyFdTumu84eDoWhjoK+ZNyg7KMKkrSkWJv+ibWQMKuURH7Gr3UQtczx47T4HKc3cSOhQFfyoxO0TSzidT97tD5WqLRc0FLdLSikJErdDWdhs7lvgcTZLMDXjqYIhAl1j4D/piwz4sC39JdJ6cRSKLoZORJbHUoFhPOrGl509n8iSRhkJIAwmboajoFHy5CqdV1CjHUtP4Y7OchykKUWAf07szGd0xJjzrxQgNdhiPE8B0PXfT4pl5hfXV3XwDwSzoa2GoUUb38BmPpyvo5j8funRRE7TKr6z5c2BMfoKfPZaggL59q+4HdWYlXXt4ZwOTJLpRyiXKte1WyTdmbm6Zs4wMAnwPwk745nbYiab5gOPNJ58WR6kLcq6rKOqCRlMhd93I0GWmCtCYiInoZmYYMcwsgfcLTVstn9UwyuAJgIiIiIiLy2AiFZBhqQ1Y3jtGWwLHnNu6sbDboQalVzNmFuTDnPuEm3CvsOPV2ERHFYxyCedaI5prbSDfE+KyzrqrClhMQe7NwPU7JU0zsq8HxuPWF78n4E3lDUmKzZIYEEgbJZ0cHVYVCOOwqNrXyN0BDkYdsDF0uuTH6Xhr2jKA6FLr3lfhIQ8tynPO0DX+DJseIRjFbVR0KXchaoUWXAE9xmt8AZgqxEEA2ZP7fVjo/BIAa37diBtmVvTC9MNuJGwCMBSnz65FYzpGOaVi+Lm0AYG/w5s5NZkPvSm4iawwr8zmbvACRXWBnB++hixJr21MDt5SJT0BLhEFvL2IO1Wg2KJkUhQ5xFEbKdp0dqvniXmHnE49ECApHWN5J0tQyb4y0QcrcZ0QyX71SSLmpDocihka8EHDvm4bNt2ftw5x263NyntYyZ8eZBsCS9rFNNvHzZo1wj1lBvECnIb3iZzonk4dtG4jHxxQrOE9tLnxZWi27rXdASuTHJ5zTgywAWcl9zf6clSaA9HJdM4DUFK81K2dXc57X5vm01Z1dOUeUPSCKIRqiVOlUgzjT6TpUKEJyIjh/qYDrdNo8RUhNgW/PMpsqx5cOQyR6iYyrBToesaWzJnoXQVuundY1xPg6ZgVENlYpA2BDl4yEBr/sQyQV89rbmN6rvifzOqHhh0U7n74h2VKpYNRpJdoxxm3XyCF5rntnNqqqcL77HePn2CnymU9liXXXue8VVjacpiatng383cXfN0rhxJGNMQMKzlNfeaqtfNNAAGfnnwfZZzRE0Te1x22S1OtSdQCBNM0Vy9vrXivY9Y2swjrQ91pcRAKlVqgO2tYHK4XJSHN9z1HfTzJE1gd3xofaSGZSUcecqRkePyTRvX9btqGRFbtZ50rzuvJmk9EQxcCWxOB9aXAA6Wu83jk2uBRxu3V6gnFiIeeNoUZ2b7d3EtTjgen0c3aHlFhnJd3oZwBMSuQ46VvQVcH+giGveTfQADGITMcUA+AqigCQ40nPkhYfzjJkvpp8HkjoHD3kWYrip+tD3RNWru9BSmxCXuZFdOFJ+p1xQFbvX08SqP2qr7YIIbIhSFiGot474qia9gorwh03x2vHI2Y7uS4ahIn8pyGlIAFkc9cl7xVWnBaCEfVoO6trY2soTUonuYxI/xx//tkTThs6jW4KwbkSAutDhYJuKyyyNcLbllHifB7AUIlyLaikR9TLfDfqmT7Wr5eCcw0g+y6+++t/jj//rK8OiosMk2enEE0Z4Fa0C3W/A+HLW7+PoDBEAJ7i8eHOp1WgTpRii9fm8/KW0OqZC1tokln8rnQMJnqTNl9sdqL0aFfFmV7j9WT8/1tyBcu9KKHopBNOmyXbuxeXVpZiXS5gyxYA9oSXDXZQarV08I3F8r+hcoktQCSUYk1RXvh6yWuHaeBIHIBVCJm+7+F7/+JjfPxLxHkLoctZz6kMKiNv9oh59BBA1gUmZcp46sge7QNYH0xkXi7njh8KMb3hzXRUD4AJ0e4sA2APj/oak8/TDBWq96hHZ0E0qwkPYPcKO9/WR/YKbafBezeV8Oy/K//XkOJwKCDGN8jQ6BdRuIGLn5MOttL9Or9Dx44QormXwHmK0PYee2pAuvDJUYo1Tu93eLhgoS66acBDUhPlmhNOG1RV0Qc7zWlHABFRnZmghVkm9RyLlHESUmw6shpAWjtTdXTQtZe8RXDboC+DgPu9cABMgD9lgLgNlwuw+3tYQYmcO04UmDFhtH2RiOidPNApROYtNwo9hVKzDQgH0nv13BAJMQzrvQsTPkacbyKi8U4gpYiHkDg+bf/t1/E5XcZK9+po20aUjHaIAt8yD206/eISZpho8tnmMe22t2FIfXPAh2wUbWSfGi8H0OFDvPf738Cv6tJnOsfyAKwBu6OeQW9wBLBZovGAlJvryFdAZCFiuQuBjLCtvZMrFsudCIhsKOy2SX3St8yrzRlu1tEyH/kjlPFjyhDGrajWE/8uW8DZMCx4uUtvXdz9/ax83jXuc0oZQBoa7CgAJoG8bZLlTHuFVShju3Nly1o3/klubG2d5BypJIx9/yN7Hw2DboVmYt0qAIbDoQiEh5xHT+9LbLqAdZ6vsyZAnFGKFjwNteYtCLir5n+lVqHokjH6kZpCB9LDI+66FDQsoPv55gR4P8teY/gzqDChKJv62sq2QmhtXLyYaAB4CnW/i13e26Y4iNqpLLEmQ+KITz0qGZiyg5cjwReBSDFhRXU+5+WYw4Nlcw4XVVXYWkzSRDvOI8S53vqQZibD2YB8qJOlIz3ZCFTW8TOvyhONc0cGxxNSqr885IJ/+hzohq+94yMA6dBmPZzkBpLnjp83kzMd5kOFog3VEwC7ROq0fl9jI0gfI4c5zTk6AFlQivUZWe7h8c2diYUcur3qboCf+cIy5HdGebca0pO+GXmi6DIqmYORsXyA42zM0ZeQk2wBB09D2uopgbwsI91xcw0P2Rj47YIEN5271hOQ+RmVcI4SEJ43yg1VChruhAz182wAnQfxz3h9YrhsQU51pMIzxWsMjRF8ft5acJcpWKajlpDo+ITtX5R/8cpluSZQHtoSDyWJlO7GslEdCgQ2GWJRv5lditSThW2C/LXOL01Dq1nOGfuqI3610oXtD4Bd7lY/VP0NIEgSpoDVoUIRKtOa+FxwnqLys5t5LL/pMGIhzYgTEUXvAMjGdhjU1SrW7Z9TNriZOWSelsD6GkZ3LmOMYqLjcTvE8cJwXP/tze8zMG3QF+3j6bgdi50AgKEUa+LfZ855FGONgD6QqgaXgjIr0RnXZZckjAVAKiBQjEVefLOjusMAsDmG2KWjRTdLdCZ5wkaXDqrlop+/UJZrm46bTSjusTIfbWRJNIxZlgQRC/AUT8dtQPdj0IiDiZ4uWGoGItJi5CVyebKLv97D17lN5xhKrcZkA206AGOcL9sBRRPo9I5q6tZTl+OMzefvep6BdoGEY1AJEW7weQlq+AnuzgyVdjQI3yxFDSCNdmzrWkc1QDlNR37uyXOlDpbo9AZAJvi9bSV6tIFSWzoZQqwp+iOKy/FDvoQOZgiR2Yo2x0SLANicrYkAUmnIGPrUVAm1f9vI7Hsjtg9Q4ETzL/FFOgxVVdCYUtB3SgszrkgIkb1583iXJA1oEmU3jJJS2IXSkDcbctU/fa43Im7kpSUyzm3fsRDILnUbgNQHh5fIgygjBrrXoDgh5cZl2opzpInfWwJHR3wN1KmRfQICyCoLo5+D7w88PeG00XzmeRugFEBd3prP2UjZQEqZH496wOSaTZhs6vup5zC7jILVuBm6a9kLEyKMmuCQZpaLX2Y6zmxAhLYa8tzTlAVyXc2lCmplxkCwZEykNDRKnLLopObl/ozEmBr4nOYoEynxLgx7GLtfIl+JS+S0iMlvg6XHg8T8rU+3mjwu64JA4u+seK380sB4IMVr/Rv0AHwawE/odGa8ObOyXOM0LnJWUKsKVTEkjTlykxjVZyOkOX0UXspMFde64lgcgPneGRKmO43Y+5Vqb3sVrVYluwTQCwA/A+AXo3N2iYgsUIWqGMDT7HrRVghQ5ATiRPQuMlJq9ebxXdOWe0/15XpiAGvbTKsUVksYh7KtdAAwBUWgKDaCA88c74vPXQ0xsN7fUUuTqw9LfoTozoQCYA8PuDNyFpQJazEkde0ttyi0+egUZkdK38me7hnriYmsWgc2pf9g7pjaUsjcytdRuqHQ2enebOxMATBOSJUmbcAsYzwliwEhsrlrx4k0edejHIAbnZ0A7sgYj1XcyIXF6M2VwyQEsvelP6hzRAP584SNKVTSvuCjQlXMzf7geNzqGkc7HrGlMd6XdKhQ6OQRSLmhcWBvHQb7iz26sPe9OZMZTY6ixNqmUoGUm8uSSRNlrePmWXJKx5CCWk3JKKAcB1RmI/2ttyxBfBRzkGLVoJGHM5w4JwAdc8wYfy3uCU+0s35M1F9jAIShnyaWlogCdApiARayuYWKiIjIvnyTwzosEJr7GUIgO3gE1mTyrHyf0TcJnAWAUEItMtuKIiai0IzuvcKOTiIcOuG0WWogVCMtjmxsNDNh4TsyaOfzQcpXUOqzAFLdqIMAUhPTD/q9LgNeYdPNS94W0XjembAFTJezSVH38py+UHTqi2ev+yWcB1llCW8XzImefjMo9Vn8yZ/8ikEGY1aZGAA71zmGgs947cHVs54pgbosSymPbATr3evt+H3ShdxZFtwzG0Kr65yJHxFlgsYWiS6oE2Qh+eCD52mGH/yg/t2iWCUDgHYYY5jB6LnJDnCWJEi+/OXk28m3FyMMPoAjuSTGGMbwZPP7/9WmQQd4eqhQ9I1fAkh//6PEi9FFE9vkLi4hSb7ylfD47Av/848MffYnrT/40pfSwUHZX35p8PIwVIeCesL0kKlpsb7JGCGQHb6Of/bH38RPBeA987QZtSAQHZ3nKmWOo9jSSViNXCfV6Rr0M+J9j3SSPgfPbdYG4CkwvGGN+FAfuSoDAmC/+3/jFx4e3+kjqP3K2R6cm4A9ar+6LDXM/a6yxJq2SC3N8PqR4qRm1Uh46um4xcwlZfVqY7832gmBzKaRmuroNo7Uyo4M8zT01cFeldCQJAxSbgY8NNOxWc51NAWA7T0GCpr7bj5Ga4Ckvg4i32RlFWIBDgAzlboOIbtQBxT9N+dzqaR+roAyOTFFTgCYiHQRz1h0NSIi/5Q7ZWnOOvcN3ty1nRFNsAw4v9oByIbwHJ1Wz6HgeNyGnnaJ/854iqfjlhieKFSSQH58wta+7JhtcI45IvfcmezNlFyPIQPX/0YGDAMsCgGAaejhbcaO44kS62oBKFshOW5tPy9Rvgr8Hal/hIjopVxEl/0zOb45RIfWze8iG9rfMAe112eMhaApRGz3mpGWCWV5vYCIoqLlkFJYjUlv4+HB2UbREuV6DmaJbp3UBG3RZmlN3bOUyLv2Q9g8TynNbdJcNL15fLgLzwEw0ziHqip8L+VEv90rND5Ue383awbKJ1Mb+ZoIc3NpoJYgKwBYHx82ZzG6SZ1zpAnpG88iQI+MVEwpZwhqEiQawS81OidrauSpBlli0WxpM5hZ6DnD9aVuGiLPUiJfiqMw4ncp0PA1AnTMRE7hiAVEVqGiXooYo5iL6M3Zcyi1cqX4mjWtG+KGm3wSrIN0wmlz7cCMKWcCYLZ031inlpPDsChFPTnqpxT2nLPX4/wphZ2rsg/nSLtWztKei2WRoIZVLaOdPqz2ndPgZ/Uhx/5NhYq2+em8g+NxS2nOiQKm7neaPstpFsnHUSAkCcOpPfpWkQJjuabQ5/XPz89Yt22xYRhvNQUb0EPhNuI1aQ028m9WLl4aACsjBeQhmsAPkgdfpzS6hEeLIm3HGic5XI6TPWYq6hy9/9n/g59QHXxdlljHgqwKgD0+TtsXYpUOBxQxAA4Q6heRMd6yPD9MRGRXd/IUT+OWiT3hafsf8B/+h+/he58e+jfij/Hp3/sQvyklNv68ewDpeN0vfPlvpcxE7VIip3Qg0UjezGJZ7iQ0gXEsac1zo4zJ2bJ33vm5ZDu2ZwZAesLpM3LEiLEQyITCp30K1hrQo9ViBKxPwVLTGdESvXEhkJlIX895J4Cnc5qWADDbkzBD3vVW0NEoZOp7iU+20wklZXeL3nrGnEuUa3FjIiFIR3Yo5jERUYi8Pbe++PiIuwlKzNmeeJTlGpXZUaj9lTEfUhemuenlGPGLv83GyoHLbCCkvNlHpKBWVHYefvH5Qt99vdSpiFhS15cb05wKPBImHEM61+u+39/4EqWFZgRjkAVvnkWIzGZHvw90PGLrU/+EWUUjRAyNiVksykIC+dDVx+A8xelEIC2alW/fljkTkM8vswpivfR7sPl9oc//N1gmqRF5EMvacfJHR/zDP1b4RTOMJpD5MmtaK7t4vDsAa3W1GpIogHtT+1WMBk+CsCWIiNzpFbWaUpq7XnAFyfXJMQDmaoNQ0xT0wrMWkcwUxzpqEvsIzZz3O1QodE3B6EI1JCIi8lOvmAJ8G6w4GGP47d9mn7g4kL/8y/bn/KsfJojhwhljYIwF9S6DnMH/+IfrJPko2mhyzr198/9Ifvzrv578rZYH+ehnCV1TqwLmKZSdjJwPDnJMTvr38f3Pfwff+UJ0euWDDz4JX7BKPzfEATIHpeBHGX9xxNZzbgsm+wC4W5pD5JYaeHR342wDekdCoic8/eR38d3PeR7hD7Y1bpulkbAT9DVr+ToWAYgMMdU9Aea/gW557IuGIGAe4wuB7HCwN2t7XSKzuWUxps7z5l02LiLWITgoJul0wsZVmZXIrtM11Ph37dTwipayA7otEvZ1CUeIy0Fq5V937kLd70JyyoRAxt+NA2Y2gT4AFLHgcwzZkCmi3ScQpw5tnDpnjtV1c5yF981ny8CEmr+rXTtL9uRSIbBuGzeRErk8gUbd3N7P1oVjujj8cKIrY/e8KXPp/OD6/QGkIWVW6m2l40vSpHNcXViLt8Y5Ui4JsrSTwQOe0f0//wSf+mOFT9NNErUbu3flqwZPf0tr0M1ShapwDYR1i8p69wdF50READLTELQX37XW1sfSKPeHD/HLf/BNfMHQ85IXb5EPY/gO03TCaXMLG8LUwrgxJCCegaq5DDDaxtbrfwci2zgcihhQlDh5XIOyFc/uXUU4DQE9nbTHJ2w5r9OJphQehMjICbDmAOQjfz/tAn7Std3R03O62WRallj7tKUTScJwcLeiO8ieOH5RJwHAQsdq57g9qgYhMlPgCv4KcsJwFNuEaOmGjxwMzbTvACsjMuuYcJOOeJt9QMIk5CZKBo5l17ou5qJTIIqJeLN5sG+VKVHYzt1SdBd3NP5aItIlQxDCWm3Wd+P/Gq93Y35fCKwToluHNFpQfUsttkbSZEiJvOBFnkLtVzSBEosT5wDee2x3dgg19pAFAkDqc2frGON/r7Ab+2d75fdcq5TIKWtGtGijQWTMmfPVmL5lsuMRW+4tul9t9JuUp1MlfTYUQDIK4KHpbPXCwEAIynAQEY2VG7VfLa3XiMhsUOj0y+eiHFkVvAkesQCy/YQtbVIiP536IEx5GgS0Y9uzOygNXc9UEw0+t50XS2bKcr20newdQRO71hXEpUTT+ClweRqrmIZAg+okIZCJEd/3fETGrdK15ZzV41DmG2EAkdkyIKFPvXgTJTxzwpXXJRylsCpvwgqbkWfC+yfqo786feszQZd/2wR/CgKc6wUdfSUE35UcGcvBxmpHqdrFRec38RyOR2yHOAG2gxSifjrhtOEB90R08SVCWPQ2tov+lmC1eeg2F60sW0HK/Br4pE9pEhEt0JHIbG5/tPA+EeDA2DX+dm1SkE3t+h46pv3VfiuCeWuSwakrOXTFNpaEQGZjNBIPD3c+OqKnEzaua/xyLMLhVYYTQLoE2RUQUTlu3tKQBjmisULuf7oaVVXcUiQcPE0cN/k1y1qC8ah9z77Yej54Pn30wqBafN4Pq//83uUUVP8zL8NRb2C208u7IsyEsYdY17zp0DxUNCE6Ma4j2iUogcbJIQfc1fmX5drV9JQvEyGeyEG2xKmUegQ9AB4AkA31lE3VXMB5itP7k5QlOUcBOiESuZow9umd7FxlW55tRgtofDdkqlAVOmFiFSJczLVQEhCZq2znoUIRBGDZGOMJDFfa4z43YVNnLRtPnxwAIudyBOCOTsIucfCU5J/oRnBLvOHo8Klp8OWZpKGmhSVkfhXhMs/O1j0ID+f50kF4dEX1ffPYS1rh3DiXlE3SeaZCZDGOVhs36uRRhWmo5nYYX/cN6KpxNcptKzC9k71tJhwA69ojb1RRe6JUXM3J29raZvKcATDTfTJDnJwxgUMfSNiSNhYOO1PKHId5cdWBRkgmGH+fzw1AWlUodKO1jRVw3fVkDxwA6wp/DJJak6LdeHh22ZyJnyFAarobYfs+q3EiVmHwLo0yE3Uxhwq/SWcKOmOrsl3oVryyxNqEcaN68jKyFC1PovXOhUAmyvBLoI2DdtcsSEsNf9dd7aTwFE/CGeqeUljR3gjDQh/Fut2556AhhXmoUASKUDU7Y+CslAIwGzsZfKYhjmdIyKHiiC3tCrh5l2vT0xEm5BmH8VlPKZELgpg2e9EhAOq4pvOYnIsxRw6ennDaGLj7dQz47Utv9KMIaRl0OKDYRzCuq1Uv+zwmKiU2MaSertTtYiJcXwwLADalFg4gfcLT9sbPV9SIZDw6X9MZ3+BRtSeDNpyXMuKlFzos0/VB2ueGOUd0NcylpOeQJMxEo57NcUzK7gSr1HLqfYj8jivz+PtLL41NUph9v1PVGNPkhVmKwOesp9Xd1avD24xpfviI43bIGd/qgAfAlraCuG3DpJVIiZyKecFPYNnca7mSkPmtjCCRzZQD0aCznjplAIAJiVcan+UmlCwAtjQFOwKyOu2CGgaQQqndss6NW18nLSU2sWXu6k2d9mQutMBPAJloweOIOYAfZS9Yc6dGLlbTQbtQFp0R3xFbiiK6lcMQBVtPXZATGaIj4wtJSSWCJKkxSEATTH1BC1vQ+7ZmE8Ff2lAIsYaUmyZw09/ZHWPDBqfSx0uGG8k3ABh1bftlsPH4v9+RQSUi6pW77Nx1/xqvd6GUMyFlfp0ZAJASTHisjGrpYvcKq9hKQr5HDQBSvL7fEZd33l0+4PcIhpZoKn9lZx6iiILIv7tMEjalwxagRRRJkiSKRgND1mM5gO2A33O+Grl51mdNdVOAYpyf+UluhjZ0Tsn8xSKLU7OeY7OsxyO2o50TEyArREEpTqazlqhjYgAAIzS0iHnu6bidF0WFHYG1KfYQYcW7EEShrQfsReo6yHs/nbCZ8uwoxXoMVoQ/5VWqKS7dqZhlvAWQUa9AdFzByvIvXt0ab1UKuyGKUgga6/NZ9k0ssQJ42mYMAbAjjlvb7zgV04RzpFIi7qD74QHUWERERNQb+fZFeLHsSfehvwSQ+a3tdufJgtB0d2ilAlPZzQZ8z++zWBrwCRER0Qx9cZKbGMbdAKTg+lfLjjEmKEUvNDOkzE0855KcXDqFC5IS+SWTQsoX6Q9bY4OoDkWIEYVrBQgRXlRA1HGXnKc2oFiJ7OlXkk1/6FChWHT/0pT58LLEWlnY9BRqJEGd6YuVpdSIfApBOOkthnTIamGiMZEwOSaLo74lQJBys5QUExnum2ezCilyqbMgdrNHc+vGS4sMkSSsLcPYpad06z1Zd3tbkXnc3+90fJepwGtpSHxERC+U7xu8ufP2+QIcO3J7n/ZLRwCyOcBOAHZLc0Ivt8BVqAre0vRmCpESQHp8gpWO9LmlzHuFHU3aEBEt1aAFCDwS+32MNfaHAwpKW992oBIkLIjuaPuHQ9F5f5AUtANtJdsOztMQO/ubWmgWrvySAEelbDxotASQml7WNKVHKEnm7eKQErmNHiMiO3Qut+jixzePj3eti3QcNowfqvnOPaSkBtFII5tcwZ81sjget4vba187vhsNdznKsCllrneC13XbFEnCTEUOTW149GfvIzPgl/P2MawrthkpA2BlibWuz7IBDU0ZqGUZ6AzAYlLssYC1THECZiufkb0YNsa+mhWiWaSy2Xt+AFLTpZUa36Dmn7LE2sdIDUCqFAYFGj6nywFkFdyOvnadTZP5m31uXRlE2vrn5rJHpTldM6cuesLTVkIO2MhW0hgakbeRqhAERf3W4TyFD1sLgHG4mTyz4UwmSTeAE5UAiLQKUh+zD2E43RMIhwMKUthdd8K1NMChOhRLR/Eckj0gIrokakDtPhQSpIEepC874H1MVQJgf/Qh/slB4ueXxBdDewFqp+xdGnDICBzUfnWJGQ+A4ft/9E9QHX5+4bK4Ir3lhyNma9ySaOiljKiHAkj7ml7E1CaPCAUUCAs4CaVY66w99TXpCIlXhwo01jjCaRp7fyjFK1RmR0cBpAqET2GLKlQFEF5zZYlyXZZxlxGDyxpAiMx1M5gE8vuBTSs6qGtkaukjR7Q7gEh3xOdzU+J+j5XQ1JV+4/3NwEI7kFMADMcjRfA3KAhHuLqIumoG9VvplyVe6WzIICNHRGQnGjrhNKkZTQDZv/kQ73GDEVWXIeVAejzOT1U3U0Ws7VxCyw4GG+GaPg91vwvOnlx6vSFspQL8HLchWpxBY0t9b9uR/L/5EO/9/hH/4n3pppvdrOOhVgCtV795RvVIKzPAy4XOz6V71EAKipp0Jimp+UJynmnvY2S6nyR5jdfWZqZ9W8pi+1k4kL4vsSG+cxPRN/znbJRQKbXStQVWAatzltuHhtA9oVsSXdJYdCwhkAFIJWQ+d05WDBAyFxGgJgNq1TvnHKmupsalbN4k0uegjW0MBMDKDmyPW0h7ANjhUPN5qLC1KPWt1m7OarC8BjH6PCQCcX35sTStjX8HiooG8u/a9j0KMf87IWWOJ6GjBp0Sln5EBr4Hh8M2rG+S1NggZlL1ZnU71H5l4jxiU6Cs1wA7nCBAVRWxQCb2nTUH0v3evjLvei4Iken0ool8cS6JvHUALgCdQszK3XB4N+gZD2waKnPiA0/h2wW6YThNzyFHcbGPj3cDEPuYXWbDuqsOGMJWRjJ+RBE7BBmqfihylOVaN4Knw4B0cfj4ZYn1ZRYPEJmX5UEpkXelP01EilIiNznDq5OqSm/naZLUjSRlIO8/VMDHpquXDnEbEpnchhhdpD8ild8XFdvGDEB1KKh/RWNg3fR70Um0ZRwMpYT0N2kYGWdhS1eoAzImhAGvmY+njuXZUmKh75aoF+AMO6spjX/Gn5+Mv079Pp6Xby4xmKgMuQcjSSGknK+et1hiysqj898A+E0A77Xxkg6gl4UoofW1fvE6MDhim5DTR7Rkoe0S0ocH3E3xxI9P2Lr2rK9TY/UEgr+1rWbeNE0Su7udBZDNUYCxZBaapqHPdU0C0BbC+VEIgBQijkbQ64miJntETa5EOrmMJUm9E4EaGvUopyAMle5a9a33rioUc6I0ylzo5tN6VJZKNv7rE9M6SEGtpGXkOEgeraERR2xDGok+N/Q1DY0roB0zBEAmIEgHE7UrnblKBKf3Ny5rdY0ApDbOyv19qRUaxEZyALQHAK1Kkg/YWqqDGgRTnTtK0svG5rENgb7KgCmae8ehng3IOTDgTS4o6q1BNhziN9Tp1dHlG1e4D1BqBSk3JCVeOQBZVwS1BCdnCDAQUe/5egs1rRRWbWVKJAnTNlYP4OcAfIai4ucbEm09sy9n1+ZJi6P7vg9v+OvrX/88vv71f+6bsgASRtFAoDyl9iu9S2kouxSh88dMf8EvA/ipmD3lwZ9hOSWOgx/gSEph1Y5fb1+h+IrrACk3+PDD97yXg7qRbTFjWCH3qug2/g+PuAvxHA4H/RgpRETeEkXVnWqM2c7CxGkUebqUFaUEkBI+EUAU0YVEJ1EzAgB2fLo1fw4mhN6oBgAjcI4lOQBgGLkhcspIUgsu/VvZfXjE3e98M/zM4lSnxIZBa5BXqfyzUEpvKYAhH8A98Z5FMxpxr7CrkmrdtZ6yR+i2IUQDjDH8y19k/1/nnfCEvfqnid7o7YMPsuRf/Svb/Q1FzNEZgNTXRUiMMTD22590GfqO3Q6fjHUykk996u37f/vbyep/++gd3/4Nks+skPz8QiO7NLGwIO0HP0jwW7+VwOR3+Lq3XkrktwOp8J34rgCxF4mzwQ7uZcDj0Q+juVdYzUUapBTS/DNSUKvTSWoZD2w6tKO9EyQJC3eEyPxzc450bHQqT9jc6jtpeIoi3pl3/xacbAAf+Fqu1DEe6StJIFcKu1sBs/uoHSKrUFG9NiDqU8iyBqyhUsFUo+cBXPZQqioUY8dez466QbXet9eB1sHqcczz5v8Xvu0RMK3/bo5UCpqmGeuBUdS94IyBtefgPAjDKoFch4GsO/n969kQJdZUcyaK0WZBiIxW1hMRXQqFlF5s0sPxuF3S2l9AZBSNELkwkDSFQ3TLeyKlNPy8vFskwjlSOXGVK9EkHogmZQ0p8+vekCWlj5ei423Vl6nUGB5zpFR/00MCesFahu6NBsDKGQJ+ud2QaLDMBO80Q8oc/+mr/xLf+72fJiW+XAPXlw084bQZUgIDkL7G6x1xCdGSI0OdDkAKYOdaARBFyq+cp/je//XTOIotOE8Jf36YjMf2ToeqB7EvcgyXxepPAMzeOAgZGWJkIt/vn5qAidrI/KSIPmcMSlnNaEqpp0k4ampGNRZ/SL4qWADrDiAZopj58QrYBlLm50wAoB+9kihMp9/HUVhyVIlCFLiUtry9PQwSYI8c9DGRF/UN+UXjM7l1IMIj21/SrAEm3oyZ7u+xO3t/CsqLhROUOm05jx7kQaWwk4ELayz3PuYd6izBnvoFJjn/+ics+veQPKfDAcXpFGe2r5nSSnXwuY+KhuoMyfNdByXKtQ+XyjEeIjV6B2ABDhGXyH3FVScK29FKkvkgVMC7YMngO02CB5+bSRqrYwCkj29ur1bmHKnzoESUWF8bewCMc7MOANT9zkekMqIFKcgaHbDVkYp13TKAzwL4dcLjICdWl3G9jIiN26t6/JlNPN/J9kZBraYsmPOe9gor3cZeDYhSyPgTXVPpACa2E9Yz0owCgFcAftGHDJ/OM+Yc6fuGAapMnhmBpOmhQ4WCsqNTmfAottAwh3k4EBRk7MTBU90KUanxIEHgPIWUWhX/vcJO96iNn9MYbmeuZ69CvjpTk1lLAOwN3tyR5HuulzhSGgOfyuQLwkqfdD4zFqwASGNKIQFIhQcTBmYiJ70KBABDKV55dHcM4CnUvVbgJxwOxRCAn7r0Mo93ALBb606JPNIVnKeQ70920pvma8oYEw00TIZSQLMWrMDO7nfTvRtERD3OGBv2u++yD121Y8IGCObeb9blGwd4Dnx4SlNPjgTaxnfobLgy0UzTfKa30ftl7VN38xoJ3khFdTgUFjqhWWTn1to9Hso00tJlRNcKa9d3eDy+G28UApm7RmAw6Xp0kgNprJ3QOoV8TAoaScJ016uTpO65GBopNdv8Xtxr1xy9AmG2D+YRIbLBvNBjNG7NcEfZjdxCcxE97w2XCBrZL0IpnfY5VABYSPI+d2rhhSPjyN5RhmNBmRKUZpT30NQ/5y+3yyFJGI7H7WLvL0nY5NLODOVlK6oEkKlA8QOaxlA28cUZDGNmhNS5PwQwa+LnOqnRN0A8wRvOBl9mWm+ZUjtyHhbocDzikTqSNTsBMfNLqEpirPGWJ2wu99HHsk459MBnCWfhxAkynX0C7EdHROaETxyxfXgEOQ9EsUoGGSVbJ/3m4c5ljwY8Klc0jmZq6rOd9liQpxcP/d4R//APv4lfi8AByokvB56Voj4OouUGQUgSaxkwE/sXRIm1E8hgpbCiRsBhjBhKY5ZSWF2mSAM+8/TK+46mh+FQvQPSOuG0mRtZoDoMAuaSJ2woXf6c5tRnrcsE5ylO79Oa7etzESKbDTo10A7QdsAZBwYg/fgH+JSvhmaKN3o8YktOVLyCZ8JgXtbs+RXwlMl0YNMgSlkVh3w8p2Fx7rw9kTd8kMcU0PQpumcMLzoUalkvLbKunB4ecTfve8f9bbOgZsqyi9HNTgDYo+1+gJHws74bJIN1v9YRJwFkPAJUNEJ2IyLyQO+hFOshnYSixHq/dzdKFHNk8gwV7Xjc2pwrtnmuALITTqNSlNeOH4BU7yhleGhzDd4A811ecDxuu6YrKFU68AyVWg0t4RARTVDKMh+Cy72Unev2z5+neH1PmOaDEwh6G3oAMBFY3RtS9jZACs0ZMwmZP+FpVFrSxMw5UbAR7YqcPqIpjJOC0OhCv0Nm5nP7DQyEyGKe8e90ACAyoCp03mGIaXuUYg2Mz6i5CnYApFDKWkCwRNmYK1eVRrkKSEG7Egie2obadNVv4EVkqTlq4xzpZVe7XoPUzxeA0AIXCiEyHCgVuxSHVUg4295oyygDYo2TpKmBsbwxcZOlt5DRALZ9GNFLatrR+a6cI5WBpL6oxPOcBy7hcwFEBYhlq++hbYmWN02MALv3dKXw8QlbksLIdIoHJTEAKfHWSANeRjA3H64hTlylYp07vefvN+GY2eLptuUy9wo7XwIKX51enaPDCoQXH3GgUkz4m3TOF0bPTOf3A7CZuwYYQCZhJvUjZdxoeIDMfW6QNL72t0HwO493ojoUU6IIBbUyxYM+3QUZOXdOTolyPTU1btKBDmVT4413yMeMdxt3rK87OeM2QPOBUQDkS1nfukDFahU4Z2oKsQYPirsjv0JVTDFAQ1AxGyW8ss1bIaVqAbAEfjUU6h8Z9lvHwFZJC/v96tLzI1Og+XyFyEJnXDLoREE4DhUKpbBKbtx7A8qUO2BI4kUi/zw9wgu3YIgGLnCJpTnTC+Aaz5s1yTkxQ4cKBeeETEhERBSgs+Dts6n94LSpiVHBKeRrrbzJTrxI7wmBLCTHAEJkEPHh1QMoyEGLj6REziOegPv/AV5y7fWjB4gcAAAAAElFTkSuQmCC';
const BG_L2_B64 = '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';
const BG_L3_B64 = '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';
const BG_LAYERS = [
    { img: null, parallax: 0.05, scale: 55000 },
    { img: null, parallax: 0.35, scale: 50000 }
];function buildBgLayerTextures() {
    const rng = mulberry32(42);
    const SZ = 2048;

    // â”€â”€ Couche 0 : Fond bleu nuit â”€â”€
    const c0 = document.createElement('canvas');
    c0.width = SZ; c0.height = SZ;
    const x0 = c0.getContext('2d');
    const gBg = x0.createRadialGradient(SZ/2, SZ/2, 0, SZ/2, SZ/2, SZ*0.7);
    gBg.addColorStop(0, '#162650');
    gBg.addColorStop(1, '#0a0e28');
    x0.fillStyle = gBg;
    x0.fillRect(0, 0, SZ, SZ);
    BG_LAYERS[0].img = c0;

    // â”€â”€ Couche 1 : 50 Ã©toiles brillantes â”€â”€
    const c1 = document.createElement('canvas');
    c1.width = SZ; c1.height = SZ;
    const x1 = c1.getContext('2d');
    const cols = ['220,230,255','255,210,160','180,210,255','255,185,185','210,255,225'];
    for (let i = 0; i < 50; i++) {
        const sx = rng() * SZ, sy = rng() * SZ;
        const sz = rng() * 2.5 + 1.0;
        const a = rng() * 0.3 + 0.5;
        const col = cols[Math.floor(rng() * cols.length)];
        // halo doux
        const hr = sz * 6;
        const gh = x1.createRadialGradient(sx, sy, 0, sx, sy, hr);
        gh.addColorStop(0, `rgba(${col},${a * 0.6})`);
        gh.addColorStop(0.3, `rgba(${col},${a * 0.15})`);
        gh.addColorStop(1, 'rgba(0,0,0,0)');
        x1.fillStyle = gh;
        x1.beginPath(); x1.arc(sx, sy, hr, 0, Math.PI * 2); x1.fill();
        // croix de diffraction
        x1.strokeStyle = `rgba(${col},${a * 0.25})`;
        x1.lineWidth = 0.6;
        const len = sz * 10;
        x1.beginPath();
        x1.moveTo(sx - len, sy); x1.lineTo(sx + len, sy);
        x1.moveTo(sx, sy - len); x1.lineTo(sx, sy + len);
        x1.stroke();
        // point central brillant
        x1.fillStyle = `rgba(${col},${Math.min(a + 0.3, 1.0)})`;
        x1.beginPath(); x1.arc(sx, sy, sz, 0, Math.PI * 2); x1.fill();
    }
    BG_LAYERS[1].img = c1;
}

const COMET_CFG = {
    freq: 8, speed: 150, size: 8, tail: 80, fgDebris: 10
};

// â•â•â• Listener ZOOM UI â•â•â•
document.getElementById('uiZoomSlider').addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    document.getElementById('uiZoomVal').textContent = val + '%';
    const scale = val / 100;
    // Appliquer le zoom aux Ã©lÃ©ments HUD
    const els = ['evoPanel', 'myPlanets', 'minimap', 'uiZoomControl', 'scoreBoard', 'sporeCounter', 'eventLog', 'codex'];
    els.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.style.transformOrigin = 'top left';
            if (id === 'minimap' || id === 'uiZoomControl') el.style.transformOrigin = 'bottom right';
            if (id === 'scoreBoard' || id === 'sporeCounter') el.style.transformOrigin = 'top right';
            if (id === 'eventLog' || id === 'codex') el.style.transformOrigin = 'bottom left';
            const cur = el.style.transform || '';
            if (cur && cur !== 'none' && /scale\(/.test(cur)) {
                el.style.transform = cur.replace(/scale\([^)]*\)/, `scale(${scale})`);
            } else {
                el.style.transform = scale !== 1 ? `scale(${scale})` : (cur === 'none' ? 'none' : '');
            }
        }
    });
});

// â•â•â• Listeners MULTIPLICITÃ‰ â•â•â•
document.getElementById('evoSacrifice').addEventListener('input', (e) => {
    const human = gameState.players[0];
    if (human) human.multiSacrifice = parseInt(e.target.value);
});
document.getElementById('evoGrowth').addEventListener('click', () => {
    const human = gameState.players[0];
    if (human && human._multiPending) applyMultiChoice(human, 'growth');
});
document.getElementById('evoVelocity').addEventListener('click', () => {
    const human = gameState.players[0];
    if (human && human._multiPending) applyMultiChoice(human, 'velocity');
});
document.getElementById('evoDensity').addEventListener('click', () => {
    const human = gameState.players[0];
    if (human && human._multiPending) applyMultiChoice(human, 'density');
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUTH SUPABASE â€” Login + Pseudo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const SUPABASE_URL = 'https://hcjajtpbzusqgxkyzbgc.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhjamFqdHBienVzcWd4a3l6YmdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxMTIwNjgsImV4cCI6MjA4NzY4ODA2OH0.UXiZvC3kQmQzZ4BSWp6X19ISPjlac87YZlLonUqzvic';
const _supa = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

let currentUser = null;
let currentProfile = null;
let currentRoom = null;
let currentRoomChannel = null;
let isHost = false;

let authHandled = false;

async function handleSession(session) {
    console.log('handleSession called, authHandled:', authHandled);
    if (authHandled) return;
    authHandled = true;
    currentUser = session.user;
    console.log('handleSession user:', currentUser.id);
    const profile = await loadProfile(currentUser.id);
    console.log('handleSession profile:', profile);
    if (profile) {
        currentProfile = profile;
        await loadPanelConfig();
        enterGame();
    } else {
        showPseudoStep();
    }
}

async function initAuth() {
    _supa.auth.onAuthStateChange(async (event, session) => {
        if ((event === 'SIGNED_IN' || event === 'INITIAL_SESSION') && session) {
            await handleSession(session);
        }
        if (event === 'SIGNED_OUT') {
            currentUser = null;
            currentProfile = null;
            authHandled = false;
            showAuthScreen();
        }
    });

    const { data: { session } } = await _supa.auth.getSession();
    if (session) {
        await handleSession(session);
    } else {
        showAuthScreen();
    }
}

function showAuthScreen() {
    document.getElementById('authScreen').classList.remove('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
}

function showPseudoStep() {
    document.getElementById('authScreen').classList.remove('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('authStep1').style.display = 'none';
    document.getElementById('authStep2').style.display = 'block';
}

function enterGame() {
    document.getElementById('authScreen').classList.add('hidden');
    setPhase('title');
}

async function loadProfile(userId) {
    try {
    console.log('loadProfile START', userId);
    const { data, error } = await _supa
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();
    console.log('loadProfile RESULT:', data, error);
    if (error || !data) return null;
    return data;
    } catch(e) { console.error('loadProfile CRASH:', e); return null; }
}

document.getElementById('btnAuthLogin').addEventListener('click', async () => {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    const msg = document.getElementById('authMsg');
    if (!email || !email.includes('@')) {
        msg.textContent = 'Entrez un email valide.';
        msg.style.color = '#EF4444';
        return;
    }
    if (password.length < 6) {
        msg.textContent = 'Mot de passe : 6 caractÃ¨res minimum.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'Connexion...';
    msg.style.color = '#8B5CF6';
    const { error } = await _supa.auth.signInWithPassword({ email, password });
    if (error) {
        msg.textContent = 'Email ou mot de passe incorrect.';
        msg.style.color = '#EF4444';
    }
});

document.getElementById('btnAuthSignup').addEventListener('click', async () => {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    const msg = document.getElementById('authMsg');
    if (!email || !email.includes('@')) {
        msg.textContent = 'Entrez un email valide.';
        msg.style.color = '#EF4444';
        return;
    }
    if (password.length < 6) {
        msg.textContent = 'Mot de passe : 6 caractÃ¨res minimum.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'CrÃ©ation du compte...';
    msg.style.color = '#8B5CF6';
    const { error } = await _supa.auth.signUp({ email, password });
    if (error) {
        msg.textContent = 'Erreur : ' + error.message;
        msg.style.color = '#EF4444';
    } else {
        msg.textContent = 'âœ“ Compte crÃ©Ã© ! Connexion automatique...';
        msg.style.color = '#22C55E';
    }
});

document.getElementById('btnAuthPseudo').addEventListener('click', async () => {
    const pseudo = document.getElementById('authPseudo').value.trim();
    const msg = document.getElementById('pseudoMsg');
    if (pseudo.length < 3 || pseudo.length > 20) {
        msg.textContent = 'Le pseudo doit faire entre 3 et 20 caractÃ¨res.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'Enregistrement...';
    msg.style.color = '#8B5CF6';
    const { data, error } = await _supa
        .from('profiles')
        .insert({ id: currentUser.id, pseudo: pseudo })
        .select()
        .single();
    if (error) {
        if (error.code === '23505') {
            msg.textContent = 'Ce pseudo est dÃ©jÃ  pris.';
        } else {
            msg.textContent = 'Erreur : ' + error.message;
        }
        msg.style.color = '#EF4444';
    } else {
        currentProfile = data;
        enterGame();
    }
});

async function startMultiGame() {
    if (!isHost || !currentRoom) return;
    // VÃ©rifier que tous sont prÃªts
    const { data: players } = await _supa.from('game_room_players').select('*').eq('room_id', currentRoom.id);
    if (!players || players.length < 2 || !players.every(p => p.ready)) return;
    // Passer la room en "playing"
    await _supa.from('game_rooms').update({ status: 'playing' }).eq('id', currentRoom.id);
}

function onMultiGameStart(room) {
    currentRoom = room;
    // Pour l'instant : placeholder â€” on connectera le vrai startGame Ã  l'Ã©tape D
    console.log('Partie multi lancÃ©e ! Seed:', room.seed);
}

async function toggleReady() {
    if (!currentRoom || !currentUser) return;
    const { data } = await _supa.from('game_room_players').select('ready').eq('room_id', currentRoom.id).eq('player_id', currentUser.id).single();
    if (!data) return;
    await _supa.from('game_room_players').update({ ready: !data.ready }).eq('room_id', currentRoom.id).eq('player_id', currentUser.id);
}

async function leaveRoom() {
    if (!currentRoom || !currentUser) return;
    if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); currentRoomChannel = null; }
    await _supa.from('game_room_players').delete().eq('room_id', currentRoom.id).eq('player_id', currentUser.id);
    // Si host, supprimer la room
    if (isHost) {
        await _supa.from('game_rooms').delete().eq('id', currentRoom.id);
    }
    currentRoom = null;
    isHost = false;
    setPhase('lobby');
}

async function enterRoom(roomId) {
    setPhase('room');
    document.getElementById('roomCode').textContent = 'CODE : ' + roomId.substring(0, 8).toUpperCase();
    document.getElementById('btnRoomStart').style.display = isHost ? 'inline-block' : 'none';
    // Charger les joueurs
    await refreshRoomSlots(roomId);
    // Subscribe Realtime sur la table game_room_players
    if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); }
    currentRoomChannel = _supa.channel('room-' + roomId)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'game_room_players', filter: 'room_id=eq.' + roomId }, () => {
            refreshRoomSlots(roomId);
        })
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'game_rooms', filter: 'id=eq.' + roomId }, (payload) => {
            if (payload.new.status === 'playing') onMultiGameStart(payload.new);
        })
        .subscribe();
}

async function refreshRoomSlots(roomId) {
    const { data: players } = await _supa.from('game_room_players').select('*').eq('room_id', roomId).order('slot_number');
    const max = currentRoom ? currentRoom.max_players : 4;
    const slotsEl = document.getElementById('roomSlots');
    let html = '';
    for (let i = 0; i < max; i++) {
        const p = (players || []).find(x => x.slot_number === i);
        if (p) {
            const readyCls = p.ready ? 'yes' : 'no';
            const readyTxt = p.ready ? 'PRÃŠT' : '...';
            html += `<div class="room-slot"><div class="slot-color" style="background:${p.color}"></div><span class="slot-name">${p.pseudo}</span><span class="slot-ready ${readyCls}">${readyTxt}</span></div>`;
        } else {
            html += `<div class="room-slot empty"><div class="slot-color" style="background:#333"></div><span class="slot-name" style="color:#64748B;">Slot libre</span></div>`;
        }
    }
    slotsEl.innerHTML = html;
    // Activer le bouton LANCER si host et tous prÃªts
    if (isHost) {
        const allReady = players && players.length > 0 && players.every(p => p.ready);
        document.getElementById('btnRoomStart').style.opacity = allReady ? '1' : '0.4';
    }
}

async function joinRoom(roomId) {
    if (!currentUser || !currentProfile) return;
    // Charger la room
    const { data: room, error: re } = await _supa.from('game_rooms').select('*').eq('id', roomId).single();
    if (re || !room || room.status !== 'waiting') { alert('Partie indisponible.'); loadRoomList(); return; }
    // Trouver le prochain slot libre
    const { data: players } = await _supa.from('game_room_players').select('slot_number').eq('room_id', roomId);
    const taken = (players || []).map(p => p.slot_number);
    let slot = -1;
    for (let i = 0; i < room.max_players; i++) { if (!taken.includes(i)) { slot = i; break; } }
    if (slot === -1) { alert('Partie pleine.'); loadRoomList(); return; }
    const { error } = await _supa.from('game_room_players').insert({
        room_id: roomId, player_id: currentUser.id,
        pseudo: currentProfile.pseudo,
        color: gameState.playerColor || '#C8A0FF',
        slot_number: slot, ready: false
    });
    if (error) { console.warn('Erreur join:', error); return; }
    currentRoom = room;
    isHost = (room.host_id === currentUser.id);
    enterRoom(roomId);
}

async function createRoom() {
    console.log('createRoom', currentUser?.id, currentProfile?.pseudo);
    if (!currentUser || !currentProfile) { console.warn('createRoom: pas connectÃ©'); return; }
    const settings = { sunCount: 4, difficulty: 'normal', useIA: true, cleanerCount: 3, useAsteroids: true };
    const { data, error } = await _supa.from('game_rooms').insert({
        host_id: currentUser.id,
        host_pseudo: currentProfile.pseudo,
        settings: settings,
        max_players: 4,
        status: 'waiting'
    }).select().single();
    console.log('insert room result:', data, error);
    if (error) { console.warn('Erreur crÃ©ation room:', error); return; }
    currentRoom = data;
    isHost = true;
    // S'ajouter comme joueur slot 0
    await _supa.from('game_room_players').insert({
        room_id: data.id, player_id: currentUser.id,
        pseudo: currentProfile.pseudo,
        color: gameState.playerColor || '#C8A0FF',
        slot_number: 0, ready: true
    });
    enterRoom(data.id);
}

async function loadRoomList() {
    const list = document.getElementById('lobbyRoomList');
    list.innerHTML = '<p style="color:#64748B; text-align:center; padding:20px; font-size:13px;">Chargement...</p>';
    const { data, error } = await _supa.from('game_rooms').select('*, game_room_players(count)').eq('status', 'waiting').order('created_at', { ascending: false }).limit(20);
    if (error || !data || data.length === 0) {
        list.innerHTML = '<p style="color:#64748B; text-align:center; padding:20px; font-size:13px;">Aucune partie disponible.</p>';
        return;
    }
    list.innerHTML = data.map(r => {
        const count = r.game_room_players?.[0]?.count || 0;
        return `<div class="lobby-room-row" onclick="joinRoom('${r.id}')"><div><span style="color:#E0E7FF; font-size:14px;">${r.host_pseudo}</span><br><span style="color:#64748B; font-size:11px;">${r.settings.sunCount || 4} soleils Â· ${r.max_players} joueurs</span></div><div style="text-align:right;"><span style="color:#4ADE80; font-family:'Orbitron',monospace; font-size:13px;">${count}/${r.max_players}</span><br><span style="color:#64748B; font-size:10px;">EN ATTENTE</span></div></div>`;
    }).join('');
}

document.getElementById('btnMulti').addEventListener('click', () => {
    playClickSound();
    fadeTransition(() => setPhase('lobby'));
});
document.getElementById('btnLobbyBack').addEventListener('click', () => {
    playClickSound();
    fadeTransition(() => setPhase('title'));
});
document.getElementById('btnCreateRoom').addEventListener('click', () => {
    playClickSound();
    createRoom();
});
document.getElementById('btnRoomLeave').addEventListener('click', () => {
    playClickSound();
    leaveRoom();
});
document.getElementById('btnRoomReady').addEventListener('click', () => {
    playClickSound();
    toggleReady();
});
document.getElementById('btnRoomStart').addEventListener('click', () => {
    playClickSound();
    startMultiGame();
});
document.getElementById('btnLeaderboard').addEventListener('click', () => {
    playClickSound();
    showLeaderboard();
});

document.getElementById('btnLeaderboardBack').addEventListener('click', () => {
    playClickSound();
    setPhase('title');
});

async function showLeaderboard() {
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('leaderboardScreen').classList.remove('hidden');
    const body = document.getElementById('leaderboardBody');
    const empty = document.getElementById('leaderboardEmpty');
    body.innerHTML = '<tr><td colspan="5" style="color:#94A3B8; text-align:center; padding:20px;">Chargement...</td></tr>';
    empty.style.display = 'none';

    try {
        const { data, error } = await _supa.from('leaderboard').select('*').limit(50);
        if (error) throw error;
        if (!data || data.length === 0) {
            body.innerHTML = '';
            empty.style.display = 'block';
            return;
        }
        body.innerHTML = data.map((row, i) => {
            const rank = i + 1;
            const medal = rank === 1 ? 'ğŸ¥‡' : rank === 2 ? 'ğŸ¥ˆ' : rank === 3 ? 'ğŸ¥‰' : rank;
            const isMe = currentProfile && row.pseudo === currentProfile.pseudo;
            const bg = isMe ? 'background:rgba(139,92,246,0.15);' : '';
            return `<tr style="${bg} border-bottom:1px solid rgba(139,92,246,0.1);">
                <td style="padding:8px; color:#E0E7FF;">${medal}</td>
                <td style="padding:8px; color:${row.avatar_color || '#E0E7FF'}; font-weight:${isMe ? 'bold' : 'normal'};">${row.pseudo}</td>
                <td style="padding:8px; text-align:center; color:#22C55E;">${row.wins}</td>
                <td style="padding:8px; text-align:center; color:#94A3B8;">${row.total_games}</td>
                <td style="padding:8px; text-align:center; color:#FBBF24;">${row.win_rate}%</td>
            </tr>`;
        }).join('');
    } catch (e) {
        body.innerHTML = '<tr><td colspan="5" style="color:#EF4444; text-align:center; padding:20px;">Erreur de chargement</td></tr>';
        console.warn('Erreur leaderboard:', e);
    }
}

document.getElementById('uiResetBtn').addEventListener('click', () => {
    panelConfig = {};
    _panelsInitialized = false;
    for (const id of PANEL_IDS) {
        const el = document.getElementById(id);
        if (!el) continue;
        const handle = el.querySelector('.panel-drag-handle');
        if (handle) el.removeChild(handle);
        el.classList.remove('panel-collapsed');
        el.style.position = '';
        el.style.left = '';
        el.style.top = '';
        el.style.right = '';
        el.style.bottom = '';
        el.style.transform = '';
        el.style.transformOrigin = '';
    }
    const slider = document.getElementById('uiZoomSlider');
    if (slider) { slider.value = 100; document.getElementById('uiZoomVal').textContent = '100%'; }
    initPanels();
    savePanelConfig();
});

document.querySelectorAll('#eventLog .log-filter').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('#eventLog .log-filter').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        refreshEventLog();
    });
});

initAuth();

</script>
</body>
</html>
