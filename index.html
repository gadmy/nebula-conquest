<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nebula Conquest</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Exo+2:wght@300;400;600&display=swap" rel="stylesheet">
<style>
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   NEBULA CONQUEST ‚Äî CSS
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

* { margin: 0; padding: 0; box-sizing: border-box; }

html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #000;
    font-family: 'Exo 2', sans-serif;
    color: #ccc;
    user-select: none;
}

canvas#gameCanvas {
    display: block;
    width: 100vw;
    height: 100vh;
    cursor: grab;
}

canvas#gameCanvas.grabbing {
    cursor: grabbing;
}

/* ‚îÄ‚îÄ HUD overlay (pr√©par√© pour √©tape 4) ‚îÄ‚îÄ */
#hud {
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 10;
}

/* ‚îÄ‚îÄ FPS counter (debug) ‚îÄ‚îÄ */
#fps {
    position: fixed;
    top: 8px;
    right: 12px;
    font-family: 'Orbitron', monospace;
    font-size: 12px;
    color: rgba(0, 255, 180, 0.6);
    z-index: 100;
    pointer-events: none;
}

/* ‚îÄ‚îÄ √âcrans UI (menu, config, etc.) ‚îÄ‚îÄ */
.screen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
    pointer-events: auto;
}

.screen.hidden { display: none; }
.hidden { display: none !important; }

/* ‚îÄ‚îÄ √âcran titre ‚îÄ‚îÄ */
#titleScreen {
    background: radial-gradient(ellipse at center, rgba(14,27,61,0.85) 0%, rgba(6,8,26,0.95) 100%);
}

#titleScreen h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 52px;
    font-weight: 900;
    color: #C8A0FF;
    text-shadow: 0 0 30px rgba(160,80,255,0.5), 0 0 60px rgba(120,40,200,0.3);
    letter-spacing: 6px;
    margin-bottom: 12px;
}

#titleScreen .subtitle {
    font-family: 'Exo 2', sans-serif;
    font-size: 16px;
    color: rgba(180, 190, 220, 0.6);
    letter-spacing: 3px;
    margin-bottom: 50px;
}

#titleScreen h1 .title-letter {
    display: inline-block;
    opacity: 0;
    transform: translateY(20px);
    animation: letterAppear 0.4s forwards;
}

@keyframes letterAppear {
    to { opacity: 1; transform: translateY(0); }
}

#titleScreen .title-glow {
    animation: titlePulse 3s ease-in-out infinite;
}

@keyframes titlePulse {
    0%, 100% { text-shadow: 0 0 30px rgba(160,80,255,0.5), 0 0 60px rgba(120,40,200,0.3); }
    50% { text-shadow: 0 0 40px rgba(160,80,255,0.7), 0 0 80px rgba(120,40,200,0.4), 0 0 120px rgba(100,30,180,0.2); }
}

#titleScreen canvas {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
}

#titleScreen .btn {
    opacity: 0;
    animation: fadeInUp 0.6s 2s forwards;
}
#titleScreen.no-intro .btn,
#titleScreen.no-intro .subtitle,
#titleScreen.no-intro .title-letter,
#titleScreen.no-intro #quickMatchPanel,
#titleScreen.no-intro #titlePseudo,
#titleScreen.no-intro #btnLogout {
    opacity: 1 !important;
    transform: none !important;
    animation: none !important;
}

#quickMatchPanel {
    opacity: 0;
    animation: fadeInUp 0.6s 2s forwards;
}

#titlePseudo {
    opacity: 0;
    animation: fadeInUp 0.5s 2.2s forwards;
}

#titleScreen #btnLogout {
    opacity: 0;
    animation: fadeInUp 0.5s 2.4s forwards;
}

#titleScreen .subtitle {
    opacity: 0;
    animation: fadeInUp 0.5s 1.5s forwards;
}

@keyframes fadeInUp {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.btn {
    font-family: 'Orbitron', sans-serif;
    font-size: 15px;
    padding: 14px 40px;
    border: 1px solid rgba(160, 120, 255, 0.4);
    background: rgba(40, 20, 80, 0.5);
    color: #C8A0FF;
    cursor: pointer;
    letter-spacing: 2px;
    transition: all 0.3s;
    border-radius: 4px;
    margin: 6px;
}

.btn:hover {
    background: rgba(80, 40, 140, 0.6);
    border-color: rgba(180, 140, 255, 0.7);
    box-shadow: 0 0 20px rgba(140, 80, 220, 0.3);
}

/* ‚îÄ‚îÄ Nidification ‚îÄ‚îÄ */
#nidPanel .nid-planet-btn {
    font-family: 'Exo 2', sans-serif; font-size: 9px;
    padding: 3px 8px; border-radius: 4px; cursor: pointer;
    border: 1px solid rgba(34,197,94,0.4); color: #4ADE80;
    background: rgba(34,197,94,0.15); transition: all 0.2s;
}
#nidPanel .nid-planet-btn:hover {
    background: rgba(34,197,94,0.3); border-color: #4ADE80;
}
.mp-mother-badge {
    font-family: 'Orbitron', sans-serif; font-size: 7px;
    color: #FBBF24; background: rgba(234,179,8,0.2);
    border: 1px solid rgba(234,179,8,0.4); border-radius: 3px;
    padding: 1px 4px; cursor: pointer; transition: all 0.2s;
    letter-spacing: 0.5px;
}
.mp-mother-badge:hover {
    background: rgba(234,179,8,0.4); border-color: #FBBF24;
}

/* ‚îÄ‚îÄ Lobby & Room ‚îÄ‚îÄ */
.room-slot {
    display: flex; align-items: center; gap: 10px;
    padding: 8px 12px; border-radius: 6px;
    background: rgba(20,15,50,0.5); border: 1px solid rgba(100,70,180,0.2);
}
.room-slot .slot-color {
    width: 14px; height: 14px; border-radius: 50%; flex-shrink: 0;
}
.room-slot .slot-name { flex: 1; color: #E0E7FF; font-size: 13px; }
.room-slot .slot-ready {
    font-family: 'Orbitron',monospace; font-size: 10px;
    letter-spacing: 1px; padding: 2px 8px; border-radius: 3px;
}
.room-slot .slot-ready.yes { color: #4ADE80; background: rgba(34,197,94,0.15); }
.room-slot .slot-ready.no { color: #64748B; background: rgba(100,116,139,0.1); }
.room-slot.empty { border-style: dashed; opacity: 0.4; }
.lobby-room-row {
    display: flex; align-items: center; justify-content: space-between;
    padding: 10px 12px; border-radius: 6px; margin-bottom: 6px;
    background: rgba(20,15,50,0.5); border: 1px solid rgba(100,70,180,0.2);
    cursor: pointer; transition: all 0.2s;
}
.lobby-room-row:hover {
    background: rgba(40,30,80,0.6); border-color: rgba(34,197,94,0.4);
}

/* ‚îÄ‚îÄ √âcran config ‚îÄ‚îÄ */
#configScreen {
    background: radial-gradient(ellipse at center, rgba(14,27,61,0.9) 0%, rgba(6,8,26,0.97) 100%);
}

#configScreen h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 28px;
    color: #C8A0FF;
    margin-bottom: 30px;
    letter-spacing: 3px;
}

.config-panel {
    background: rgba(20, 15, 50, 0.6);
    border: 1px solid rgba(100, 70, 180, 0.25);
    border-radius: 8px;
    padding: 25px 35px;
    width: 420px;
    max-width: 90vw;
}

.config-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin: 12px 0;
    font-size: 14px;
}

.config-row label {
    color: rgba(180, 190, 220, 0.8);
    font-family: 'Exo 2', sans-serif;
}

.config-row input[type="range"] {
    width: 140px;
    accent-color: #8B5CF6;
}

.config-row .val {
    color: #C8A0FF;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    min-width: 30px;
    text-align: right;
}

.config-row select {
    background: rgba(30, 20, 60, 0.8);
    border: 1px solid rgba(100, 70, 180, 0.4);
    color: #C8A0FF;
    padding: 4px 8px;
    font-family: 'Exo 2', sans-serif;
    border-radius: 3px;
}

.stat-group { margin: 16px 0 8px; }

.stat-group .stat-title {
    color: rgba(180, 190, 220, 0.6);
    font-size: 12px;
    letter-spacing: 2px;
    text-transform: uppercase;
    margin-bottom: 8px;
}

.stat-group .points-left {
    color: #FFD700;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    text-align: center;
    margin-bottom: 6px;
}

.color-picker {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
    margin: 10px 0;
}

.color-swatch {
    width: 30px; height: 30px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: all 0.2s;
}

.color-swatch:hover { transform: scale(1.2); }
.color-swatch.selected { border-color: #FFF; box-shadow: 0 0 10px rgba(255,255,255,0.5); }

.config-buttons {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-top: 20px;
}

/* ‚îÄ‚îÄ √âcran spawn ‚îÄ‚îÄ */
#spawnScreen .spawn-banner {
    position: fixed;
    top: 20px; left: 50%;
    transform: translateX(-50%);
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    color: #FFD700;
    text-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    letter-spacing: 2px;
    z-index: 55;
    pointer-events: none;
}

/* ‚îÄ‚îÄ HUD en jeu ‚îÄ‚îÄ */
#gameHud {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 20;
    display: none;
}

#sporeCounter {
    position: absolute;
    top: 12px; left: 16px;
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    color: #C8A0FF;
    pointer-events: auto;
}

#sporeCounter .count {
    font-size: 22px;
    color: #FFD700;
}

#evoPanel {
    position: absolute;
    top: 48px; left: 16px;
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    background: rgba(10,8,30,0.75);
    border: 1px solid rgba(100,70,180,0.3);
    border-radius: 6px;
    padding: 8px 12px;
    pointer-events: auto;
    min-width: 260px;
}
#evoPanel .evo-stats {
    display: flex;
    flex-direction: column;
    gap: 4px;
    margin-bottom: 8px;
}
#evoPanel .stat-row {
    display: flex;
    align-items: center;
    gap: 6px;
}
#evoPanel .stat-icon { font-size: 12px; width: 16px; text-align: center; }
#evoPanel .stat-name {
    color: rgba(200,170,255,0.5);
    font-size: 9px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    width: 55px;
}
#evoPanel .stat-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
    color: #E9D5FF;
    width: 20px;
    text-align: center;
}
#evoPanel .stat-bonus {
    font-size: 9px;
    color: #A855F7;
    width: 25px;
}
#evoPanel .stat-effect {
    font-size: 9px;
    color: rgba(200,170,255,0.4);
    flex: 1;
}
#evoPanel .evo-sep {
    height: 1px;
    background: rgba(168,85,247,0.2);
    margin: 4px 0 6px;
}
#evoPanel .evo-multi-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: #C084FC;
    letter-spacing: 1px;
    text-align: center;
    margin-bottom: 5px;
}
#evoPanel .evo-tier {
    display: flex;
    justify-content: center;
    gap: 3px;
    margin-bottom: 5px;
}
#evoPanel .tier-pip {
    width: 16px; height: 16px;
    border-radius: 50%;
    border: 2px solid rgba(168,85,247,0.3);
    background: rgba(0,0,0,0.5);
    transition: all 0.3s;
    display: flex; align-items: center; justify-content: center;
    font-size: 7px; color: transparent;
}
#evoPanel .tier-pip.filled {
    border-color: #A855F7;
    background: radial-gradient(circle, #C084FC, #7C3AED);
    box-shadow: 0 0 6px rgba(168,85,247,0.5);
    color: #fff;
}
#evoPanel .tier-pip.current {
    border-color: #E9D5FF;
    animation: tierPulse 1.5s infinite;
}
#evoPanel .evo-bar-bg {
    width: 100%; height: 6px;
    background: rgba(168,85,247,0.12);
    border-radius: 3px; overflow: hidden;
    margin-bottom: 4px;
}
#evoPanel .evo-bar {
    height: 100%; width: 0%;
    background: linear-gradient(90deg, #7C3AED, #C084FC);
    border-radius: 3px;
    transition: width 0.3s;
}
#evoPanel .evo-info {
    font-size: 9px;
    color: rgba(200,170,255,0.5);
    text-align: center;
    margin-bottom: 5px;
}
#evoPanel .evo-sacrifice {
    display: flex;
    align-items: center;
    gap: 6px;
    justify-content: center;
}
#evoPanel .evo-sacrifice label {
    font-size: 9px;
    color: rgba(200,170,255,0.5);
}
#evoPanel .evo-sacrifice input[type="range"] {
    width: 100px;
    accent-color: #A855F7;
}
#evoPanel .evo-sacrifice .sac-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: #C084FC;
    min-width: 30px;
    text-align: right;
}
#evoPanel .evo-choose {
    display: none;
    text-align: center;
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid rgba(168,85,247,0.2);
}
#evoPanel .evo-choose .choose-title {
    font-size: 9px; color: #E9D5FF;
    margin-bottom: 5px;
}
#evoPanel .evo-choose button {
    background: rgba(168,85,247,0.15);
    border: 1px solid rgba(168,85,247,0.4);
    color: #E9D5FF;
    padding: 4px 10px;
    margin: 0 3px;
    cursor: pointer;
    font-family: 'Exo 2', sans-serif;
    font-size: 10px;
    border-radius: 4px;
    transition: all 0.2s;
}
#evoPanel .evo-choose button:hover {
    background: rgba(168,85,247,0.3);
    border-color: #C084FC;
}
#evoPanel .evo-choose .stat-current {
    font-size: 8px; color: rgba(200,170,255,0.4);
}
#evoPanel .evo-tabs { display:flex; gap:0; margin-bottom:6px; }
#evoPanel .evo-tab { flex:1; padding:4px 2px; text-align:center; font-size:9px; font-family:'Orbitron',sans-serif; color:rgba(200,170,255,0.4); cursor:pointer; border-bottom:2px solid transparent; transition:all 0.2s; }
#evoPanel .evo-tab:hover { color:rgba(200,170,255,0.7); }
#evoPanel .evo-tab.active { color:#E9D5FF; border-bottom-color:#A855F7; }
#evoPanel .evo-tab-content { display:none; }
#evoPanel .evo-tab-content.active { display:block; }
#evoPanel .tech-branch { margin-bottom:8px; padding:6px 8px; background:rgba(168,85,247,0.06); border:1px solid rgba(168,85,247,0.15); border-radius:5px; }
#evoPanel .tech-branch-header { display:flex; align-items:center; gap:6px; margin-bottom:4px; }
#evoPanel .tech-branch-icon { font-size:14px; }
#evoPanel .tech-branch-name { font-family:'Orbitron',sans-serif; font-size:10px; color:#E9D5FF; flex:1; }
#evoPanel .tech-branch-lvl { font-family:'Orbitron',sans-serif; font-size:9px; color:#C084FC; }
#evoPanel .tech-pips { display:flex; gap:2px; margin-bottom:4px; }
#evoPanel .tech-pip { flex:1; height:4px; border-radius:2px; background:rgba(168,85,247,0.15); transition:all 0.3s; }
#evoPanel .tech-pip.filled { background:linear-gradient(90deg,#7C3AED,#C084FC); }
#evoPanel .tech-desc { font-size:8px; color:rgba(200,170,255,0.4); margin-bottom:4px; line-height:1.3; }
#evoPanel .tech-lvl-name { font-size:9px; color:rgba(200,170,255,0.6); text-align:center; margin-bottom:3px; }
#evoPanel .tech-buy { display:block; width:100%; padding:4px; background:rgba(168,85,247,0.15); border:1px solid rgba(168,85,247,0.4); color:#E9D5FF; cursor:pointer; font-family:'Exo 2',sans-serif; font-size:10px; border-radius:4px; transition:all 0.2s; }
#evoPanel .tech-buy:hover { background:rgba(168,85,247,0.3); border-color:#C084FC; }
#evoPanel .tech-buy:disabled { opacity:0.35; cursor:default; background:rgba(168,85,247,0.08); }
#evoPanel .tech-buy .tech-cost { font-family:'Orbitron',sans-serif; font-size:9px; color:#C084FC; }

#scoreBoard {
    position: absolute;
    top: 12px; right: 50px;
    background: rgba(10, 8, 30, 0.7);
    border: 1px solid rgba(100, 70, 180, 0.2);
    border-radius: 6px;
    padding: 10px 14px;
    min-width: 180px;
    pointer-events: auto;
}

.score-row {
    display: flex;
    align-items: center;
    margin: 4px 0;
    font-size: 12px;
    font-family: 'Exo 2', sans-serif;
}

.score-color {
    width: 10px; height: 10px;
    border-radius: 50%;
    margin-right: 8px;
    flex-shrink: 0;
}

.score-name {
    flex: 1;
    color: rgba(200, 210, 230, 0.8);
}

.score-bar-bg {
    width: 60px; height: 6px;
    background: rgba(255,255,255,0.1);
    border-radius: 3px;
    margin-left: 8px;
    overflow: hidden;
}

.score-bar {
    height: 100%;
    border-radius: 3px;
    transition: width 0.5s;
}

.score-pct {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: rgba(200, 200, 220, 0.6);
    margin-left: 6px;
    min-width: 28px;
    text-align: right;
}

/* ‚îÄ‚îÄ Codex (panneau lat√©ral au clic astre) ‚îÄ‚îÄ */
#codex {
    position: fixed;
    right: -260px;
    top: 50%;
    transform: translateY(-50%);
    width: 240px;
    background: rgba(10, 8, 35, 0.85);
    border: 1px solid rgba(100, 70, 180, 0.3);
    border-right: none;
    border-radius: 8px 0 0 8px;
    padding: 18px;
    z-index: 30;
    transition: right 0.3s;
    pointer-events: auto;
}

#codex.open { right: 0; }

#codex h3 {
    font-family: 'Orbitron', sans-serif;
    font-size: 14px;
    color: #C8A0FF;
    margin-bottom: 12px;
    letter-spacing: 1px;
}

#codex .codex-row {
    display: flex;
    justify-content: space-between;
    font-size: 13px;
    margin: 6px 0;
    color: rgba(180, 190, 220, 0.7);
}

#codex .codex-row .codex-val {
    color: rgba(220, 225, 240, 0.9);
    font-family: 'Orbitron', sans-serif;
    font-size: 12px;
}

#codex .close-btn {
    position: absolute;
    top: 6px; left: 8px;
    cursor: pointer;
    color: rgba(180,180,200,0.5);
    font-size: 16px;
    pointer-events: auto;
}

#codex .close-btn:hover { color: #FFF; }

#codex .codex-symbiose {
    margin: 8px 0 4px;
}

#codex .codex-symbiose .sym-label {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: rgba(180, 190, 220, 0.7);
    margin-bottom: 4px;
}

#codex .codex-symbiose .sym-label .sym-val {
    color: #22C55E;
    font-family: 'Orbitron', sans-serif;
    font-size: 11px;
}

#codex .codex-symbiose .sym-bar-bg {
    width: 100%;
    height: 6px;
    background: rgba(255,255,255,0.08);
    border-radius: 3px;
    overflow: hidden;
}

#codex .codex-symbiose .sym-bar {
    height: 100%;
    background: linear-gradient(90deg, #22C55E, #86EFAC);
    border-radius: 3px;
    transition: width 0.5s;
}

#codex .codex-symbiose .sym-bonus {
    font-size: 10px;
    color: rgba(34, 197, 94, 0.6);
    margin-top: 2px;
    text-align: right;
}

#codex .codex-build {
    margin-top: 6px;
    padding: 6px 0;
    border-top: 1px solid rgba(100,70,180,0.2);
}
#codex .codex-build .build-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    color: #A78BFA;
    letter-spacing: 1px;
    margin-bottom: 4px;
}
#codex .codex-build .build-radios {
    display: flex; gap: 8px; margin-bottom: 6px;
}
#codex .codex-build .build-radios label {
    font-size: 11px; color: rgba(200,200,220,0.7);
    cursor: pointer; display: flex; align-items: center; gap: 3px;
}
#codex .codex-build .build-radios input[type="radio"] {
    accent-color: #A78BFA;
}
#codex .codex-build .build-info {
    font-size: 10px; color: rgba(200,200,220,0.5);
}
#codex .codex-build .build-count {
    font-size: 11px; color: #C8A0FF; margin-top: 3px;
}
#codex .codex-build .build-progress-bg {
    height: 4px; background: rgba(255,255,255,0.08);
    border-radius: 2px; margin-top: 3px; overflow: hidden;
}
#codex .codex-build .build-progress {
    height: 100%; border-radius: 2px;
    transition: width 0.3s;
}
#codex .codex-build .build-progress.nid { background: linear-gradient(90deg, #22C55E, #4ADE80); }
#codex .codex-build .build-progress.biome { background: linear-gradient(90deg, #3B82F6, #60A5FA); }

/* ‚îÄ‚îÄ Liste plan√®tes du joueur ‚îÄ‚îÄ */
#myPlanets {
    position: fixed;
    left: 0;
    top: 50%;
    transform: translateY(-50%);
    width: auto;
    min-width: 78px;
    background: rgba(10, 8, 35, 0.8);
    border: 1px solid rgba(100, 70, 180, 0.2);
    border-left: none;
    border-radius: 0 8px 8px 0;
    padding: 10px 8px;
    z-index: 25;
    pointer-events: auto;
    max-height: 80vh;
    overflow-y: auto;
    overflow-x: hidden;
    display: none;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
}

#myPlanets::-webkit-scrollbar { width: 3px; }
#myPlanets::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }

#myPlanets .mp-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: rgba(200,160,255,0.6);
    text-align: center;
    letter-spacing: 1px;
    margin-bottom: 8px;
}

#myPlanets .mp-sun-group {
    margin-bottom: 8px;
    padding-bottom: 6px;
    border-bottom: 1px solid rgba(100, 70, 180, 0.15);
}

#myPlanets .mp-sun-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: rgba(255, 220, 100, 0.5);
    letter-spacing: 1px;
    text-transform: uppercase;
    margin-bottom: 4px;
    padding-left: 2px;
}
#myPlanets .mp-sun-label .sys-complete {
    color: #FFD700;
    font-size: 8px;
    margin-left: 3px;
    text-shadow: 0 0 6px rgba(255,215,0,0.5);
}

#myPlanets .mp-row {
    display: flex;
    gap: 2px;
    padding-left: 2px;
    overflow-x: auto;
    overflow-y: hidden;
    max-width: 62px;
    transition: max-width 0.3s ease;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
    padding-bottom: 3px;
}

#myPlanets .mp-row::-webkit-scrollbar { height: 3px; }
#myPlanets .mp-row::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }

#myPlanets .mp-sun-group:hover .mp-row {
    max-width: 300px;
}

#myPlanets .mp-item {
    width: 58px;
    min-width: 58px;
    display: flex;
    flex-direction: column;
    align-items: center;
    cursor: pointer;
    position: relative;
    padding: 3px;
    border-radius: 6px;
    border: 2px solid transparent;
    transition: all 0.2s;
}

#myPlanets .mp-item:hover {
    border-color: rgba(200, 160, 255, 0.5);
    background: rgba(100, 70, 180, 0.1);
}

#myPlanets .mp-item.active {
    border-color: #FFD700;
    box-shadow: 0 0 8px rgba(255, 215, 0, 0.3);
    background: rgba(255, 215, 0, 0.05);
}

#myPlanets .mp-item canvas {
    border-radius: 50%;
}

#myPlanets .mp-item .mp-name {
    font-family: 'Exo 2', sans-serif;
    font-size: 7px;
    color: rgba(200, 210, 230, 0.8);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 54px;
    text-align: center;
    margin-bottom: 2px;
}

#myPlanets .mp-type-badge {
    font-family: 'Orbitron', sans-serif;
    font-size: 6px;
    letter-spacing: 0.5px;
    padding: 1px 4px;
    border-radius: 2px;
    margin-bottom: 2px;
}

.planet-badge {
    color: rgba(100, 180, 255, 0.8);
    background: rgba(100, 180, 255, 0.1);
}

.moon-badge {
    color: rgba(200, 200, 220, 0.7);
    background: rgba(200, 200, 220, 0.1);
}

#myPlanets .mp-spores {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: #FFD700;
    margin-top: 1px;
}

/* ‚îÄ‚îÄ Pause overlay ‚îÄ‚îÄ */
.panel-drag-handle {
    cursor: grab;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 3px 6px;
    background: rgba(100,70,180,0.12);
    border-bottom: 1px solid rgba(100,70,180,0.15);
    border-radius: 6px 6px 0 0;
    user-select: none;
}
.panel-drag-handle:active { cursor: grabbing; }
.panel-drag-handle .panel-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 7px;
    color: rgba(200,160,255,0.4);
    letter-spacing: 1px;
}
.panel-drag-handle .panel-collapse {
    cursor: pointer;
    font-size: 12px;
    color: rgba(200,160,255,0.4);
    transition: transform 0.2s;
    line-height: 1;
}
.panel-drag-handle .panel-collapse:hover { color: rgba(200,160,255,0.8); }
.panel-collapsed > *:not(.panel-drag-handle) { display: none !important; }
.panel-collapsed { min-height: auto !important; max-height: none !important; height: auto !important; overflow: hidden !important; }
#eventLog {
    position: fixed;
    bottom: 12px;
    left: 90px;
    width: 280px;
    max-height: 200px;
    background: rgba(6,8,26,0.85);
    border: 1px solid rgba(100,70,180,0.3);
    border-radius: 6px;
    z-index: 25;
    pointer-events: auto;
    display: none;
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    overflow: hidden;
}
#eventLog .log-header {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 6px 8px;
    border-bottom: 1px solid rgba(100,70,180,0.2);
    flex-wrap: wrap;
}
#eventLog .log-header .log-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: rgba(200,160,255,0.6);
    letter-spacing: 1px;
    margin-right: auto;
}
#eventLog .log-filter {
    padding: 2px 6px;
    border-radius: 3px;
    border: 1px solid rgba(100,70,180,0.3);
    background: rgba(100,70,180,0.1);
    color: rgba(200,200,220,0.6);
    font-size: 8px;
    cursor: pointer;
    font-family: 'Exo 2', sans-serif;
    transition: all 0.2s;
}
#eventLog .log-filter.active {
    background: rgba(100,70,180,0.3);
    color: #c8a0ff;
    border-color: rgba(160,120,255,0.5);
}
#eventLog .log-body {
    max-height: 160px;
    overflow-y: auto;
    padding: 4px 0;
    scrollbar-width: thin;
    scrollbar-color: rgba(100,70,180,0.3) transparent;
}
#eventLog .log-body::-webkit-scrollbar { width: 3px; }
#eventLog .log-body::-webkit-scrollbar-thumb { background: rgba(100,70,180,0.4); border-radius: 3px; }
#eventLog .log-entry {
    padding: 3px 8px;
    color: rgba(200,210,230,0.7);
    cursor: pointer;
    transition: background 0.15s;
    display: flex;
    gap: 6px;
    align-items: baseline;
}
#eventLog .log-entry:hover { background: rgba(100,70,180,0.1); }
#eventLog .log-entry .log-time {
    font-family: 'Orbitron', sans-serif;
    font-size: 8px;
    color: rgba(200,200,220,0.4);
    min-width: 35px;
}
#eventLog .log-entry .log-icon { font-size: 10px; }
#eventLog .log-entry .log-text { flex: 1; }
#pauseOverlay {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.6);
    display: none;
    align-items: center;
    justify-content: center;
    flex-direction: column;
    z-index: 60;
}

#pauseOverlay.active { display: flex; }

#pauseOverlay h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 36px;
    color: #C8A0FF;
    margin-bottom: 30px;
    letter-spacing: 4px;
}

/* ‚îÄ‚îÄ Contr√¥le volume ‚îÄ‚îÄ */
#volumeControl {
    position: fixed;
    bottom: 12px;
    right: 12px;
    z-index: 25;
    display: flex;
    align-items: center;
    gap: 6px;
    pointer-events: auto;
    opacity: 0.5;
    transition: opacity 0.3s;
}
#volumeControl:hover { opacity: 1; }
#volumeControl .vol-icon {
    font-size: 16px;
    cursor: pointer;
    color: rgba(200,160,255,0.7);
}
#volumeControl input[type="range"] {
    width: 70px;
    accent-color: #8B5CF6;
}

/* ‚îÄ‚îÄ Minimap ‚îÄ‚îÄ */
/* ‚ïê‚ïê‚ïê ZOOM UI ‚ïê‚ïê‚ïê */
#uiZoomControl {
    position: fixed;
    bottom: 178px;
    right: 90px;
    width: 160px;
    z-index: 23;
    display: none;
    pointer-events: auto;
    text-align: center;
}
#uiZoomControl label {
    font-family: 'Orbitron', sans-serif;
    font-size: 8px;
    color: rgba(200,170,255,0.4);
    letter-spacing: 1px;
}
#uiZoomControl input[type="range"] {
    width: 100%;
    accent-color: #A78BFA;
    margin-top: 2px;
}
#uiZoomControl .uz-val {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    color: #C8A0FF;
}

#minimap {
    position: fixed;
    bottom: 12px;
    right: 90px;
    width: 160px;
    height: 160px;
    background: rgba(6, 8, 26, 0.85);
    border: 1px solid rgba(100, 70, 180, 0.3);
    border-radius: 6px;
    z-index: 22;
    pointer-events: auto;
    cursor: pointer;
    display: none;
}

#minimap canvas {
    width: 100%;
    height: 100%;
    border-radius: 5px;
}

/* ‚îÄ‚îÄ Compteur temps ‚îÄ‚îÄ */
#gameTimer {
    position: absolute;
    top: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
    color: rgba(200, 200, 220, 0.5);
    letter-spacing: 1px;
    pointer-events: none;
}

/* ‚îÄ‚îÄ Indicateurs hors-√©cran ‚îÄ‚îÄ */
.offscreen-indicator {
    position: fixed;
    width: 0; height: 0;
    z-index: 21;
    pointer-events: none;
}

/* ‚îÄ‚îÄ Transitions ‚îÄ‚îÄ */
#screenFade {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #000;
    z-index: 100;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.5s;
}

#screenFade.active { opacity: 1; }

/* ‚îÄ‚îÄ Loading screen ‚îÄ‚îÄ */
#loadingScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: #06081A;
    z-index: 200;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

#loadingScreen.hidden { display: none; }

#loadingScreen h2 {
    font-family: 'Orbitron', sans-serif;
    font-size: 24px;
    color: #C8A0FF;
    letter-spacing: 4px;
    margin-bottom: 30px;
}

#loadingBar {
    width: 250px;
    height: 4px;
    background: rgba(255,255,255,0.08);
    border-radius: 2px;
    overflow: hidden;
}

#loadingBarFill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, #8B5CF6, #C8A0FF);
    border-radius: 2px;
    transition: width 0.2s;
}

#loadingText {
    font-family: 'Exo 2', sans-serif;
    font-size: 11px;
    color: rgba(180, 190, 220, 0.4);
    margin-top: 12px;
    letter-spacing: 1px;
}

/* ‚îÄ‚îÄ √âcran de fin ‚îÄ‚îÄ */
#endScreen {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 70;
}

#endScreen.active { display: flex; }

#endScreen h1 {
    font-family: 'Orbitron', sans-serif;
    font-size: 42px;
    letter-spacing: 4px;
    margin-bottom: 10px;
}

#endScreen h1.victory { color: #FFD700; text-shadow: 0 0 30px rgba(255,215,0,0.5); }
#endScreen h1.defeat { color: #EF4444; text-shadow: 0 0 30px rgba(239,68,68,0.4); }

#endScreen .end-subtitle {
    font-family: 'Exo 2', sans-serif;
    font-size: 16px;
    color: rgba(200,210,230,0.6);
    margin-bottom: 30px;
}

#endScreen .end-stats {
    background: rgba(20, 15, 50, 0.6);
    border: 1px solid rgba(100, 70, 180, 0.25);
    border-radius: 8px;
    padding: 20px 30px;
    margin-bottom: 25px;
    min-width: 300px;
}

#endScreen .end-stat-row {
    display: flex;
    justify-content: space-between;
    margin: 8px 0;
    font-family: 'Exo 2', sans-serif;
    font-size: 14px;
    color: rgba(180,190,220,0.7);
}

#endScreen .end-stat-row .end-stat-val {
    color: #C8A0FF;
    font-family: 'Orbitron', sans-serif;
    font-size: 13px;
}

#endScreen .end-buttons { display: flex; gap: 12px; }


#authScreen {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
    background: linear-gradient(180deg, #162650, #0a0e28);
}
#authScreen input:focus {
    border-color: #8B5CF6;
    box-shadow: 0 0 8px rgba(139,92,246,0.3);
}
#authScreen .btn { font-size: 14px; padding: 10px 20px; }

</style>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.49.4"></script>
</head>
<body>

<!-- ‚ïê‚ïê‚ïê √âCRAN TITRE ‚ïê‚ïê‚ïê -->
<!-- ‚ïê‚ïê‚ïê √âCRAN AUTH ‚ïê‚ïê‚ïê -->
<div id="authScreen" class="screen">
    <h1 class="title-glow" style="font-family:'Orbitron',monospace; font-size:2.5rem; color:#E0E7FF; text-shadow:0 0 30px rgba(139,92,246,0.5); margin-bottom:30px;">NEBULA CONQUEST</h1>
    <div id="authBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(139,92,246,0.3); border-radius:12px; padding:30px; max-width:360px; margin:0 auto; text-align:center;">
        <div id="authStep1">
            <p style="color:#94A3B8; margin-bottom:16px; font-size:14px;">Connectez-vous ou cr√©ez un compte</p>
            <input type="email" id="authEmail" placeholder="votre@email.com" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <input type="password" id="authPassword" placeholder="Mot de passe (6 car. min)" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <button class="btn" id="btnAuthLogin" style="width:100%; margin-top:4px;">CONNEXION</button>
            <button class="btn" id="btnAuthSignup" style="width:100%; margin-top:8px; background:rgba(139,92,246,0.2); border:1px solid rgba(139,92,246,0.4);">CR√âER UN COMPTE</button>
            <p id="authMsg" style="color:#8B5CF6; margin-top:12px; font-size:13px; min-height:20px;"></p>
        </div>
        <div id="authStep2" style="display:none;">
            <p style="color:#94A3B8; margin-bottom:16px; font-size:14px;">Choisissez votre pseudo de commandant</p>
            <input type="text" id="authPseudo" placeholder="Pseudo (3-20 car.)" maxlength="20" style="width:100%; padding:10px 14px; background:rgba(30,41,59,0.8); border:1px solid rgba(139,92,246,0.3); border-radius:8px; color:#E0E7FF; font-size:14px; margin-bottom:12px; box-sizing:border-box; outline:none;">
            <button class="btn" id="btnAuthPseudo" style="width:100%; margin-top:4px;">CONFIRMER</button>
            <p id="pseudoMsg" style="color:#8B5CF6; margin-top:12px; font-size:13px; min-height:20px;"></p>
        </div>
    </div>
</div>

<div id="titleScreen" class="screen hidden">
    <canvas id="titleBgCanvas"></canvas>
    <h1 id="titleText" class="title-glow"></h1>
    <div class="subtitle">CONQU√äTE SPATIALE EN TEMPS R√âEL</div>
    <div id="quickMatchPanel" style="background:rgba(34,197,94,0.08); border:1px solid rgba(34,197,94,0.3); border-radius:10px; padding:14px 22px; margin-bottom:14px; min-width:340px; text-align:center;">
        <div style="font-family:'Orbitron',sans-serif; font-size:10px; color:rgba(34,197,94,0.5); letter-spacing:2px; margin-bottom:8px;">PROCHAINE PARTIE EN LIGNE</div>
        <div id="qmParams" style="font-family:'Exo 2',sans-serif; font-size:12px; color:rgba(200,210,230,0.7); margin-bottom:10px;">Chargement...</div>
        <button class="btn" id="btnQuickMatch" style="width:100%; font-size:14px; padding:10px; background:rgba(34,197,94,0.25); border-color:rgba(34,197,94,0.6); color:#4ADE80; letter-spacing:3px;">‚ñ∂ REJOINDRE</button>
    </div>
    <button class="btn" id="btnNewGame">NOUVELLE PARTIE (SOLO)</button>
    <button class="btn" id="btnMulti" style="margin-top:8px; background:rgba(34,197,94,0.15); border:1px solid rgba(34,197,94,0.4); color:#4ADE80;">CR√âER PARTIE MULTI</button>
    <button class="btn" id="btnLeaderboard" style="margin-top:8px; background:rgba(139,92,246,0.2); border:1px solid rgba(139,92,246,0.4);">CLASSEMENT</button>
    <button class="btn" id="btnHelp" style="margin-top:8px; background:rgba(100,180,255,0.15); border:1px solid rgba(100,180,255,0.4); color:#7DD3FC;">AIDE</button>
    <div id="titlePseudo" style="margin-top:20px; font-family:'Orbitron',sans-serif; font-size:11px; color:rgba(200,170,255,0.5); letter-spacing:2px;"></div>
    <button id="btnLogout" style="margin-top:8px; background:none; border:none; color:rgba(200,170,255,0.3); font-family:'Exo 2',sans-serif; font-size:11px; cursor:pointer; letter-spacing:1px;">D√âCONNEXION</button>
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN LEADERBOARD ‚ïê‚ïê‚ïê -->
<div id="leaderboardScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#E0E7FF; text-shadow:0 0 20px rgba(139,92,246,0.4); margin-bottom:20px;">CLASSEMENT</h2>
    <div id="leaderboardBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(139,92,246,0.3); border-radius:12px; padding:20px; max-width:500px; margin:0 auto; max-height:60vh; overflow-y:auto;">
        <table style="width:100%; border-collapse:collapse; font-size:14px;">
            <thead>
                <tr style="color:#8B5CF6; border-bottom:1px solid rgba(139,92,246,0.3);">
                    <th style="padding:8px; text-align:left;">#</th>
                    <th style="padding:8px; text-align:left;">Joueur</th>
                    <th style="padding:8px; text-align:center;">Victoires</th>
                    <th style="padding:8px; text-align:center;">Parties</th>
                    <th style="padding:8px; text-align:center;">%</th>
                </tr>
            </thead>
            <tbody id="leaderboardBody"></tbody>
        </table>
        <p id="leaderboardEmpty" style="color:#94A3B8; text-align:center; padding:20px; display:none;">Aucune partie enregistr√©e.</p>
    </div>
    <button class="btn" id="btnLeaderboardBack" style="margin-top:16px;">RETOUR</button>
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN AIDE ‚ïê‚ïê‚ïê -->
<div id="helpScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#7DD3FC; text-shadow:0 0 20px rgba(100,180,255,0.4); margin-bottom:20px; letter-spacing:3px;">AIDE</h2>
    <div style="background:rgba(15,23,42,0.92); border:1px solid rgba(100,180,255,0.3); border-radius:12px; padding:24px 28px; max-width:560px; margin:0 auto; max-height:65vh; overflow-y:auto; scrollbar-width:thin; scrollbar-color:rgba(100,180,255,0.3) transparent; font-family:'Exo 2',sans-serif; font-size:13px; color:rgba(200,210,230,0.85); line-height:1.6;">
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üéØ OBJECTIF</p>
        <p style="margin-bottom:16px;">Conqu√©rir <span style="color:#FFD700;">80%</span> des astres de la galaxie. Colonisez des plan√®tes et des lunes en envoyant vos <span style="color:#C8A0FF;">spores</span> √† travers l'espace.</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üöÄ CONTR√îLES</p>
        <p style="margin-bottom:6px;"><span style="color:#E9D5FF;">Clic maintenu + glisser</span> depuis un astre poss√©d√© ‚Üí lance un jet de spores vers la cible</p>
        <p style="margin-bottom:6px;"><span style="color:#E9D5FF;">Clic droit + glisser</span> ‚Üí d√©placer la cam√©ra</p>
        <p style="margin-bottom:6px;"><span style="color:#E9D5FF;">Molette</span> ‚Üí zoom / d√©zoom</p>
        <p style="margin-bottom:6px;"><span style="color:#E9D5FF;">√âchap</span> ‚Üí pause (solo uniquement)</p>
        <p style="margin-bottom:16px;"><span style="color:#E9D5FF;">Clic sur un astre</span> ‚Üí ouvre le codex (infos d√©taill√©es)</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üß¨ SPORES & CONQU√äTE</p>
        <p style="margin-bottom:6px;">Vos plan√®tes produisent des spores automatiquement. La <span style="color:#4ADE80;">Flore</span> d√©termine la vitesse de production.</p>
        <p style="margin-bottom:6px;">Pour conqu√©rir un astre ennemi ou neutre, vos spores doivent d'abord vaincre sa <span style="color:#EF4444;">Faune</span> (d√©fense naturelle), puis ses spores.</p>
        <p style="margin-bottom:16px;">Plus vous envoyez de spores, plus le jet est puissant ‚Äî mais vous laissez aussi l'astre d'origine vuln√©rable !</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üìä STATS DU COMMANDANT</p>
        <p style="margin-bottom:6px;"><span style="color:#4ADE80;">Croissance</span> ‚Äî augmente la vitesse de production de spores (+5%/pt)</p>
        <p style="margin-bottom:6px;"><span style="color:#60A5FA;">V√©locit√©</span> ‚Äî augmente la vitesse des jets (+5%/pt)</p>
        <p style="margin-bottom:16px;"><span style="color:#F472B6;">Densit√©</span> ‚Äî augmente la puissance des jets √† l'impact (+5%/pt)</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üèóÔ∏è NIDS & BIOMES</p>
        <p style="margin-bottom:6px;"><span style="color:#4ADE80;">Nid</span> ‚Äî augmente la production locale (+0.2%/nid)</p>
        <p style="margin-bottom:6px;"><span style="color:#3B82F6;">Biome</span> ‚Äî augmente la d√©fense locale (+0.2%/biome)</p>
        <p style="margin-bottom:16px;">Activez dans le codex d'un astre poss√©d√© (clic sur l'astre).</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üß¨ MULTIPLICIT√â</p>
        <p style="margin-bottom:16px;">Sacrifiez une part de production pour √©voluer. Chaque palier = +1 stat permanent. 10 paliers au total.</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">ü™∫ NIDIFICATION</p>
        <p style="margin-bottom:16px;">Syst√®me solaire enti√®rement conquis ‚Üí choisissez une plan√®te m√®re ‚Üí 5000 spores ‚Üí elle et ses lunes deviennent invincibles. La nidification reste active tant que vous poss√©dez au moins 50% du syst√®me. L'appel de nidification ne rassemble que les spores de vos propres astres.</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">‚ö†Ô∏è DANGERS</p>
        <p style="margin-bottom:6px;"><span style="color:#A78BFA;">Trou noir</span> ‚Äî d√©truit les jets trop proches, courbe les trajectoires</p>
        <p style="margin-bottom:6px;"><span style="color:#EF4444;">Vaisseaux rouges</span> ‚Äî attaquent vos jets</p>
        <p style="margin-bottom:6px;"><span style="color:#4ADE80;">Vaisseaux verts</span> ‚Äî doublent les jets crois√©s</p>
        <p style="margin-bottom:6px;"><span style="color:#888;">Vaisseaux noirs</span> ‚Äî renvoient vos jets contre vous</p>
        <p style="margin-bottom:6px;"><span style="color:#888;">Ast√©ro√Ødes noirs</span> √∑2 ¬∑ <span style="color:#EF4444;">rouges</span> d√©vient ¬∑ <span style="color:#4ADE80;">verts</span> √ó5</p>
        <p style="margin-bottom:16px;"><span style="color:#60A5FA;">Com√®tes</span> ‚Äî d√©truisent les spores au contact</p>
        <p style="font-family:'Orbitron',sans-serif; font-size:11px; color:#7DD3FC; letter-spacing:2px; margin-bottom:10px;">üí° ASTUCES</p>
        <p style="margin-bottom:6px;">La <span style="color:#22C55E;">symbiose</span> augmente avec le temps (+20% prod plan√®tes, +10% lunes).</p>
        <p>Les panneaux d'interface sont d√©pla√ßables et r√©tractables !</p>
    </div>
    <button class="btn" id="btnHelpBack" style="margin-top:16px;">RETOUR</button>
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN CR√âER PARTIE MULTI ‚ïê‚ïê‚ïê -->
<div id="lobbyScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#4ADE80; text-shadow:0 0 20px rgba(34,197,94,0.4); margin-bottom:20px;">CR√âER UNE PARTIE</h2>
    <div id="lobbyBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(34,197,94,0.3); border-radius:12px; padding:20px; max-width:420px; margin:0 auto;">
        <div class="config-row"><label>Soleils</label><input type="range" id="multiCfgSuns" min="1" max="8" value="4"><span class="val" id="multiCfgSunsVal">4</span></div>
        <div class="config-row"><label>Joueurs humains</label><input type="range" id="multiCfgHumans" min="2" max="8" value="2"><span class="val" id="multiCfgHumansVal">2</span></div>
        <div class="config-row"><label>Joueurs IA</label><input type="range" id="multiCfgAI" min="0" max="8" value="2"><span class="val" id="multiCfgAIVal">2</span></div>
        <div class="config-row"><label>Difficult√© IA</label><select id="multiCfgDiff"><option value="easy">Facile</option><option value="normal" selected>Normal</option><option value="brutal">Brutal</option></select></div>
        <div class="config-row"><label>Vaisseaux ennemis</label><input type="range" id="multiCfgCleaners" min="0" max="25" value="3"><span class="val" id="multiCfgCleanersVal">3</span></div>
        <div class="config-row"><label>M√©t√©orites</label><select id="multiCfgAsteroids"><option value="on" selected>Activ√©s</option><option value="off">D√©sactiv√©s</option></select></div>
        <button class="btn" id="btnCreateRoom" style="width:100%; margin-top:16px; font-size:14px; padding:10px; background:rgba(34,197,94,0.25); border-color:rgba(34,197,94,0.6); color:#4ADE80; letter-spacing:2px;">CR√âER LA PARTIE</button>
    </div>
    <button class="btn" id="btnLobbyBack" style="margin-top:16px;">RETOUR</button>
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN ROOM (salle d'attente) ‚ïê‚ïê‚ïê -->
<div id="roomScreen" class="screen hidden">
    <h2 style="font-family:'Orbitron',monospace; color:#4ADE80; text-shadow:0 0 20px rgba(34,197,94,0.4); margin-bottom:6px;">SALLE D'ATTENTE</h2>
    <p id="roomCode" style="font-family:'Orbitron',monospace; font-size:11px; color:#64748B; letter-spacing:2px; margin-bottom:8px;"></p>
    <div id="roomParams" style="font-family:'Exo 2',sans-serif; font-size:12px; color:rgba(200,210,230,0.6); margin-bottom:8px; text-align:center;"></div>
    <div id="roomCounter" style="font-family:'Orbitron',sans-serif; font-size:22px; color:#4ADE80; text-shadow:0 0 12px rgba(34,197,94,0.4); margin-bottom:14px; text-align:center;"></div>
    <div id="roomStatus" style="font-family:'Exo 2',sans-serif; font-size:13px; color:#FBBF24; margin-bottom:14px; text-align:center; min-height:20px;"></div>
    <div id="roomBox" style="background:rgba(15,23,42,0.9); border:1px solid rgba(34,197,94,0.3); border-radius:12px; padding:20px; max-width:420px; margin:0 auto;">
        <div id="roomSlots" style="display:flex; flex-direction:column; gap:8px;"></div>
        <div style="display:flex; justify-content:center; gap:10px; margin-top:16px;">
            <button class="btn" id="btnRoomReady" style="font-size:13px; padding:10px 24px; background:rgba(34,197,94,0.2); border-color:rgba(34,197,94,0.5); color:#4ADE80;">PR√äT</button>
            <button class="btn" id="btnRoomStart" style="font-size:13px; padding:10px 24px; background:rgba(234,179,8,0.2); border-color:rgba(234,179,8,0.5); color:#FBBF24; display:none;">LANCER</button>
        </div>
    </div>
    <div id="inviteBox" style="margin-top:12px; display:flex; gap:6px; justify-content:center; align-items:center;">
        <input type="text" id="invitePseudoInput" placeholder="Pseudo √† inviter..." style="font-family:'Exo 2',sans-serif; font-size:12px; padding:6px 10px; border-radius:4px; border:1px solid rgba(100,180,255,0.4); background:rgba(15,23,42,0.8); color:#7DD3FC; width:180px; outline:none;">
        <button class="btn" id="btnInvite" style="font-size:9px; padding:5px 12px; margin:0; background:rgba(100,180,255,0.2); border-color:rgba(100,180,255,0.5); color:#7DD3FC;">INVITER</button>
    </div>
    <div id="inviteMsg" style="font-family:'Exo 2',sans-serif; font-size:11px; color:#94A3B8; text-align:center; margin-top:6px; min-height:16px;"></div>
    <button class="btn" id="btnRoomLeave" style="margin-top:16px; font-size:12px; padding:8px 20px;">QUITTER</button>
</div>

<!-- ‚ïê‚ïê‚ïê POPUP INVITATION ‚ïê‚ïê‚ïê -->
<div id="invitePopup" class="hidden" style="position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:200; background:rgba(10,15,35,0.95); border:2px solid rgba(100,180,255,0.6); border-radius:14px; padding:24px 32px; text-align:center; box-shadow:0 0 40px rgba(100,180,255,0.3); pointer-events:auto;">
    <div style="font-family:'Orbitron',sans-serif; font-size:12px; color:rgba(100,180,255,0.6); letter-spacing:2px; margin-bottom:12px;">INVITATION</div>
    <div id="invitePopupText" style="font-family:'Exo 2',sans-serif; font-size:15px; color:#E0E7FF; margin-bottom:6px;"></div>
    <div id="invitePopupParams" style="font-family:'Exo 2',sans-serif; font-size:11px; color:rgba(200,210,230,0.5); margin-bottom:16px;"></div>
    <div style="display:flex; gap:10px; justify-content:center;">
        <button class="btn" id="btnInviteAccept" style="font-size:12px; padding:8px 20px; background:rgba(34,197,94,0.25); border-color:rgba(34,197,94,0.6); color:#4ADE80;">ACCEPTER</button>
        <button class="btn" id="btnInviteDecline" style="font-size:12px; padding:8px 20px; background:rgba(239,68,68,0.2); border-color:rgba(239,68,68,0.5); color:#F87171;">REFUSER</button>
    </div>
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN CONFIG ‚ïê‚ïê‚ïê -->
<div id="configScreen" class="screen hidden">
    <h2>CONFIGURATION</h2>
    <div class="config-panel">
        <div class="config-row">
            <label>Soleils</label>
            <input type="range" id="cfgSuns" min="1" max="8" value="4">
            <span class="val" id="cfgSunsVal">4</span>
        </div>
        <div class="config-row">
            <label>Joueurs</label>
            <input type="range" id="cfgPlayers" min="2" max="10" value="4">
            <span class="val" id="cfgPlayersVal">4</span>
        </div>
        <div class="config-row">
            <label>Difficult√© IA</label>
            <select id="cfgDifficulty">
                <option value="easy">Facile</option>
                <option value="normal" selected>Normal</option>
                <option value="brutal">Brutal</option>
            </select>
        </div>

        <div class="config-row">
            <label>IA</label>
            <select id="cfgIA">
                <option value="on" selected>Activ√©e</option>
                <option value="off">D√©sactiv√©e</option>
            </select>
        </div>
        <div class="config-row">
            <label>Vaisseaux ennemis</label>
            <input type="range" id="cfgCleaners" min="1" max="25" value="3">
            <span class="val" id="cfgCleanersVal">3</span>
        </div>

        <div class="config-row">
            <label>Amas de m√©t√©orites</label>
            <select id="cfgAsteroids">
                <option value="on" selected>Activ√©s</option>
                <option value="off">D√©sactiv√©s</option>
            </select>
        </div>

        <div class="stat-group">
            <div class="stat-title">ATTRIBUTS DU JOUEUR</div>
            <div class="points-left">Points restants : <span id="pointsLeft">10</span></div>
            <div class="config-row">
                <label>Croissance</label>
                <input type="range" id="statGrowth" min="0" max="10" value="0">
                <span class="val" id="statGrowthVal">0</span>
            </div>
            <div class="config-row">
                <label>V√©locit√©</label>
                <input type="range" id="statVelocity" min="0" max="10" value="0">
                <span class="val" id="statVelocityVal">0</span>
            </div>
            <div class="config-row">
                <label>Densit√©</label>
                <input type="range" id="statDensity" min="0" max="10" value="0">
                <span class="val" id="statDensityVal">0</span>
            </div>
        </div>

        <div class="config-buttons">
            <button class="btn" id="btnBack">RETOUR</button>
            <button class="btn" id="btnStart">LANCER</button>
        </div>
    </div>
</div>

<!-- ‚ïê‚ïê‚ïê BANNI√àRE SPAWN ‚ïê‚ïê‚ïê -->
<div id="spawnBanner" class="hidden" style="position:fixed;top:20px;left:50%;transform:translateX(-50%);font-family:'Orbitron',sans-serif;font-size:18px;color:#FFD700;text-shadow:0 0 15px rgba(255,215,0,0.4);letter-spacing:2px;z-index:55;pointer-events:none;">CHOISISSEZ VOTRE PLAN√àTE DE D√âPART</div>

<!-- ‚ïê‚ïê‚ïê LOADING ‚ïê‚ïê‚ïê -->
<div id="loadingScreen">
    <h2>NEBULA CONQUEST</h2>
    <div id="loadingBar"><div id="loadingBarFill"></div></div>
    <div id="loadingText">Initialisation...</div>
</div>

<!-- ‚ïê‚ïê‚ïê FADE ‚ïê‚ïê‚ïê -->
<div id="screenFade"></div>

<!-- ‚ïê‚ïê‚ïê CANVAS ‚ïê‚ïê‚ïê -->
<canvas id="gameCanvas"></canvas>
<div id="fps">-- FPS</div>

<!-- ‚ïê‚ïê‚ïê HUD EN JEU ‚ïê‚ïê‚ïê -->
<div id="gameHud">
    <div id="sporeCounter" title="Total de spores sur tous vos astres">SPORES <span class="count" id="sporeCount">0</span></div>
    <div id="evoPanel">
        <div class="evo-tabs">
            <div class="evo-tab active" data-tab="tabEvo">‚ú¶ √âVOLUTION</div>
            <div class="evo-tab" data-tab="tabTech">üß¨ MUTATIONS</div>
        </div>
        <div class="evo-tab-content active" id="tabEvo">
        <div class="evo-stats">
            <div class="stat-row" title="Multiplie la vitesse de production de spores sur vos plan√®tes (+30% par point)"><span class="stat-icon">üå±</span><span class="stat-name">Growth</span><span class="stat-val" id="evoStatGrowth">3</span><span class="stat-bonus" id="evoStatGrowthBonus"></span><span class="stat-effect" id="evoStatGrowthFx"></span></div>
            <div class="stat-row" title="Augmente la vitesse de d√©placement des jets de spores (+6 par point)"><span class="stat-icon">‚ö°</span><span class="stat-name">Velocity</span><span class="stat-val" id="evoStatVelocity">4</span><span class="stat-bonus" id="evoStatVelocityBonus"></span><span class="stat-effect" id="evoStatVelocityFx"></span></div>
            <div class="stat-row" title="Augmente les spores d√©livr√©es √† l'impact (+5% par point)"><span class="stat-icon">üíé</span><span class="stat-name">Density</span><span class="stat-val" id="evoStatDensity">3</span><span class="stat-bonus" id="evoStatDensityBonus"></span><span class="stat-effect" id="evoStatDensityFx"></span></div>
        </div>
        <div class="evo-sep"></div>
        <div class="evo-sacrifice" style="margin-bottom:2px;">
            <label title="Pourcentage de spores envoy√©es lors d'un jet">üöÄ Envoi</label>
            <input type="range" id="jetRatioSlider" min="0" max="100" value="50" step="5">
            <span class="sac-val" id="jetRatioVal">50%</span>
        </div>
        <div class="evo-sep"></div>
        <div class="evo-multi-title" title="Sacrifiez une partie de votre production pour gagner des paliers d'√©volution. Chaque palier donne +1 point de stat au choix.">‚ú¶ MULTIPLICIT√â ‚ú¶</div>
        <div class="evo-tier" id="evoTierPips"></div>
        <div class="evo-bar-bg"><div class="evo-bar" id="evoBar"></div></div>
        <div class="evo-info" id="evoInfo">Palier 0/10 ‚Äî 0 / 500 spores</div>
        <div class="evo-sacrifice">
            <label title="Pourcentage de production redirig√© vers l'√©volution (r√©duit la production de spores)">Sacrifice</label>
            <input type="range" id="evoSacrifice" min="0" max="50" value="0" step="5">
            <span class="sac-val" id="evoSacVal">0%</span>
        </div>
        <div class="evo-choose" id="evoChoose">
            <div class="choose-title">‚¨Ü CHOISISSEZ UN BONUS ‚¨Ü</div>
            <button id="evoGrowth">üå± Growth <div class="stat-current" id="evoGrowthCur"></div></button>
            <button id="evoVelocity">‚ö° Velocity <div class="stat-current" id="evoVelocityCur"></div></button>
            <button id="evoDensity">üíé Density <div class="stat-current" id="evoDensityCur"></div></button>
        </div>
        </div><!-- /tabEvo -->
        <div class="evo-tab-content" id="tabTech">
            <div class="tech-branch" id="techHoming">
                <div class="tech-branch-header"><span class="tech-branch-icon">üéØ</span><span class="tech-branch-name">T√™te chercheuse</span><span class="tech-branch-lvl" id="techHomingLvl">0/10</span></div>
                <div class="tech-pips" id="techHomingPips"></div>
                <div class="tech-lvl-name" id="techHomingName">‚Äî</div>
                <div class="tech-desc" id="techHomingDesc">Les jets d√©vient vers les plan√®tes neutres/ennemies proches.</div>
                <button class="tech-buy" id="techHomingBuy">D√©bloquer</button>
            </div>
            <div class="tech-branch" id="techTenacity">
                <div class="tech-branch-header"><span class="tech-branch-icon">üí™</span><span class="tech-branch-name">T√©nacit√©</span><span class="tech-branch-lvl" id="techTenacityLvl">0/10</span></div>
                <div class="tech-pips" id="techTenacityPips"></div>
                <div class="tech-lvl-name" id="techTenacityName">‚Äî</div>
                <div class="tech-desc" id="techTenacityDesc">Jets s√©par√©s conservent plus de spores et visent les syst√®mes.</div>
                <button class="tech-buy" id="techTenacityBuy">D√©bloquer</button>
            </div>
            <div class="tech-branch" id="techMimicry">
                <div class="tech-branch-header"><span class="tech-branch-icon">ü¶é</span><span class="tech-branch-name">Mim√©tisme</span><span class="tech-branch-lvl" id="techMimicryLvl">0/10</span></div>
                <div class="tech-pips" id="techMimicryPips"></div>
                <div class="tech-lvl-name" id="techMimicryName">‚Äî</div>
                <div class="tech-desc" id="techMimicryDesc">√Ä la conqu√™te, jets se scindent vers les lunes.</div>
                <button class="tech-buy" id="techMimicryBuy">D√©bloquer</button>
            </div>
        <div class="evo-sep"></div>
            <div id="nidPanel" style="font-family:'Exo 2',sans-serif; font-size:11px;">
                <div style="font-family:'Orbitron',sans-serif; font-size:9px; color:#4ADE80; letter-spacing:1px; text-align:center; margin-bottom:5px;">üè∞ NIDIFICATION üè∞</div>
                <div id="nidSystemName" style="font-size:10px; color:#E9D5FF; text-align:center; margin-bottom:5px;"></div>
                <div class="evo-bar-bg"><div class="evo-bar" id="nidBar" style="width:0%; background:linear-gradient(90deg,#15803d,#4ADE80);"></div></div>
                <div id="nidInfo" style="font-size:9px; color:rgba(200,170,255,0.5); text-align:center; margin:4px 0;">0 / 2500 spores</div>
                <div class="evo-sacrifice">
                    <label>Sacrifice</label>
                    <input type="range" id="nidSacrifice" min="0" max="50" value="0" step="5">
                    <span class="sac-val" id="nidSacVal">0%</span>
                </div>
                <div id="nidChoose" style="display:none; text-align:center; margin-top:6px; padding-top:6px; border-top:1px solid rgba(34,197,94,0.2);">
                    <div style="font-size:9px; color:#E9D5FF; margin-bottom:5px;">üëë CHOISIR LA PLAN√àTE M√àRE üëë</div>
                    <div id="nidPlanetList" style="display:flex; flex-wrap:wrap; gap:4px; justify-content:center;"></div>
                </div>
            </div>
        </div><!-- /tabTech -->
    </div>
</div>
<div id="spawnPopup" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:rgba(10,8,30,0.92); border:1px solid rgba(167,139,250,0.4); border-radius:10px; padding:16px 22px; pointer-events:auto; z-index:1000; text-align:center; font-family:'Exo 2',sans-serif; min-width:200px; box-shadow:0 0 30px rgba(100,70,180,0.3);">
        <div id="spawnPopupName" style="font-family:'Orbitron',sans-serif; font-size:14px; color:#E9D5FF; letter-spacing:1px; margin-bottom:8px;"></div>
        <div id="spawnPopupPreview" style="margin:8px auto;"></div>
        <div style="display:flex; gap:12px; justify-content:center; font-size:11px; color:rgba(200,200,220,0.7); margin:8px 0;">
            <span>üåø Flore: <strong id="spawnPopupFlore" style="color:#4ADE80;"></strong></span>
            <span>üêæ Faune: <strong id="spawnPopupFaune" style="color:#FF6B6B;"></strong></span>
        </div>
        <div style="font-size:10px; color:rgba(200,200,220,0.5); margin-bottom:10px;">
            Rayon: <span id="spawnPopupRadius"></span> ¬∑ Max spores: <span id="spawnPopupMax"></span>
        </div>
        <button id="spawnPopupBtn" class="btn" style="font-size:13px; padding:8px 24px; background:rgba(34,197,94,0.25); border-color:rgba(34,197,94,0.5); color:#4ADE80; letter-spacing:2px; cursor:pointer;">‚ú¶ APPARA√éTRE ‚ú¶</button>
        <div style="margin-top:6px;">
            <span id="spawnPopupClose" style="font-size:9px; color:rgba(200,200,220,0.4); cursor:pointer; letter-spacing:1px;">‚úï FERMER</span>
        </div>
    </div>
    <div id="gameTimer">00:00</div>
    <div id="scoreBoard"></div>
</div>

<!-- ‚ïê‚ïê‚ïê MINIMAP ‚ïê‚ïê‚ïê -->
<div id="uiZoomControl">
    <label>TAILLE UI</label>
    <input type="range" id="uiZoomSlider" min="60" max="140" value="100" step="5">
    <span class="uz-val" id="uiZoomVal">100%</span>
    <br><span id="uiResetBtn" style="font-family:'Orbitron',sans-serif;font-size:7px;color:rgba(200,170,255,0.5);cursor:pointer;letter-spacing:1px;margin-top:3px;display:inline-block;" title="R√©initialiser positions des panneaux">‚ü≤ RESET POSITIONS</span>
</div>
<div id="minimap"><canvas id="minimapCanvas" width="160" height="160"></canvas></div>

<!-- ‚ïê‚ïê‚ïê MES PLAN√àTES ‚ïê‚ïê‚ïê -->

<div id="myPlanets">
    <div class="mp-title">MES ASTRES</div>
    <div id="myPlanetsList"></div>
</div>

<!-- ‚ïê‚ïê‚ïê CODEX ‚ïê‚ïê‚ïê -->
<div id="eventLog">
    <div class="log-header">
        <span class="log-title">√âV√âNEMENTS</span>
        <span class="log-filter active" data-cat="all">Tous</span>
        <span class="log-filter" data-cat="neutral">Neutres</span>
        <span class="log-filter" data-cat="war">Guerres</span>
        <span class="log-filter" data-cat="mine">Mes astres</span>
        <span class="log-filter" data-cat="build">Constructions</span>
    </div>
    <div class="log-body" id="eventLogBody"></div>
</div>

<div id="codex">
    <span class="close-btn" id="codexClose">‚úï</span>
    <h3 id="codexName">‚Äî</h3>
    <div id="codexPreview" style="text-align:center;margin:8px 0;"></div>
    <div class="codex-row"><span>Type</span><span class="codex-val" id="codexType">‚Äî</span></div>
    <div class="codex-row"><span>Radius</span><span class="codex-val" id="codexRadius">‚Äî</span></div>
    <div class="codex-row" title="D√©termine la vitesse de production de spores (plus c'est haut, mieux c'est)"><span>Flore</span><span class="codex-val" id="codexFlore">‚Äî</span></div>
    <div class="codex-row" title="D√©fense naturelle : absorbe les spores ennemies lors d'une conqu√™te"><span>Faune</span><span class="codex-val" id="codexFaune">‚Äî</span></div>
    <div class="codex-row"><span>Propri√©taire</span><span class="codex-val" id="codexOwner">‚Äî</span></div>
    <div class="codex-row" title="Nombre de spores actuellement stock√©es sur cet astre"><span>Spores</span><span class="codex-val" id="codexSpores">‚Äî</span></div>
    <div class="codex-symbiose" id="codexSymbiose" style="display:none;">
        <div class="sym-label" title="Augmente avec le temps de possession (+20% prod max pour plan√®tes, +10% pour lunes)"><span>Symbiose</span><span class="sym-val" id="codexSymVal">0%</span></div>
        <div class="sym-bar-bg"><div class="sym-bar" id="codexSymBar" style="width:0%"></div></div>
        <div class="sym-bonus" id="codexSymBonus"></div>
    </div>
    <div class="codex-build" id="codexBuild" style="display:none;">
        <div class="build-title">PRODUCTION</div>
        <div class="build-radios">
            <label><input type="radio" name="buildMode" value="off" checked> Off</label>
            <label title="Construit un nid : +0.2% de production locale par nid"><input type="radio" name="buildMode" value="nid"> Nid</label>
            <label title="Construit un biome : +0.2% de d√©fense locale par biome (r√©duit l'attaque ennemie)"><input type="radio" name="buildMode" value="biome"> Biome</label>
        </div>
        <div class="build-count" id="codexBuildCount"></div>
        <div class="build-info" id="codexBuildInfo"></div>
        <div class="build-progress-bg"><div class="build-progress" id="codexBuildBar" style="width:0%"></div></div>
    </div>
</div>

<!-- ‚ïê‚ïê‚ïê PAUSE ‚ïê‚ïê‚ïê -->
<div id="pauseOverlay">
    <h2 id="pauseTitle">PAUSE</h2>
    <button class="btn" id="btnResume">REPRENDRE</button>
    <button class="btn" id="btnQuit">QUITTER</button>
</div>

<script>
"use strict";
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   NEBULA CONQUEST ‚Äî JAVASCRIPT
   Version: 1.1.0

   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   DEV LOG
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   v2.4.8 | 2026-02-28 | Corrections, aide & nidification am√©lior√©e
     - Fix auth : syst√®me de connexion simplifi√© et robuste
     - Fix multijoueur : cr√©ation de lobby, couleurs uniques par joueur
     - Fix hitbox : lunes et plan√®tes plus faciles √† cliquer
     - Fix noms joueurs : pseudo affich√© partout
     - Cin√©matique titre jou√©e une seule fois
     - Menu titre r√©organis√© : rejoindre partie rapide, cr√©er multi, aide
     - √âcran aide complet
     - Salle d'attente multi avec param√®tres et compteur joueurs
     - Bouton d√©connexion
     - Panneaux de jeu cach√©s au retour menu
     - Nidification : plan√®te m√®re invincible tant que >= 50% du syst√®me poss√©d√©
     - Appel de nidification ne rassemble que les spores des astres poss√©d√©s
   v2.4.7 | 2026-02-27 | Nidification de syst√®me solaire
     - Syst√®me complet conquis ‚Üí panneau Nidification avec jauge sacrifice (5000 spores)
     - Choix de la plan√®te m√®re ‚Üí couronne visuelle (emoji üëë)
     - Plan√®te m√®re + ses lunes invincibles aux attaques
     - Bouton NIDIFIER dans panneau Mes Astres : aspire tous les spores du syst√®me
     - Plan√®te m√®re positionn√©e en premier dans la ligne du syst√®me
     - Perte d'une plan√®te du syst√®me ‚Üí nidification annul√©e
     - √âv√©nements journal : plan√®te m√®re choisie, nidification effectu√©e, nidification perdue
     - Feedback visuel des boutons Off/Nid/Biome (vert/bleu/violet)
     - Sacrifices multiplicit√© + nidification partagent la production (plafond 80%)
     - Pseudo du joueur affich√© dans le classement en jeu
   v2.4.6 | 2026-02-27 | Multijoueur complet
     - Bouton MULTIJOUEUR sur l'√©cran titre
     - √âcran lobby : liste des parties ouvertes en temps r√©el
     - √âcran salle d'attente : slots joueurs, statut pr√™t, code room
     - Cr√©ation / rejoindre / quitter une room via Supabase
     - Supabase Realtime : sync automatique des joueurs dans la room
     - Bouton PR√äT et LANCER (h√¥te uniquement, quand tous pr√™ts)
     - Tables game_rooms et game_room_players avec RLS
     - Univers d√©terministe : seed partag√©, PRNG mulberry32 sur toute la g√©n√©ration
     - Sync actions en jeu via Supabase Broadcast (jets, spawn, multiplicit√©)
     - Countdown 10s pour le spawn en multi, placement auto si pas choisi
     - Joueurs identifi√©s par slot, contr√¥le local via localSlot()
     - Pause d√©sactiv√©e en multijoueur
     - Cleanup channels au retour menu

   v2.4.5 | 2026-02-27 | Panneaux UI ‚Äî Scale, Snap & Reset
     - Zoom UI (slider taille) affecte d√©sormais TOUS les panneaux (eventLog, codex, sporeCounter, scoreBoard)
     - Drag des panneaux pr√©serve le scale UI en cours
     - 8 panneaux draggables : Spores, √âvolution, Scores, Minimap, Taille UI, Mes Astres, √âv√©nements, Codex
     - Tableau des scores (scoreBoard) et compteur Spores rendus interactifs (pointer-events)
     - Handle du scoreBoard pr√©serv√© lors des mises √† jour dynamiques du contenu
     - Accrochage magn√©tique (snap) entre panneaux au rel√¢chement du drag (14px)
     - Snap aux bords de l'√©cran
     - Bouton ‚ü≤ RESET POSITIONS pour r√©initialiser toute la disposition UI
     - Reset remet aussi le slider de taille √† 100%

   v2.4.3 | 2026-02-27 | Gameplay avanc√© & UI
     - Param√®tres de partie : soleils (1-8), joueurs (2-10), IA on/off, vaisseaux (1-25), m√©t√©orites on/off
     - 3 types de ceintures d'ast√©ro√Ødes : noir (√∑2 spores), rouge (d√©viation), vert (split √ó5)
     - 3 types de vaisseaux ennemis : rouge (attaque), vert (√ó2 boost), noir (renvoi √† la base)
     - Graphismes am√©lior√©s : m√©t√©orites polygonales, vaisseaux d√©taill√©s avec cockpit et tra√Æn√©e
     - Vaisseaux patrouillent entre plan√®tes (navigation intelligente)
     - Jets renvoy√©s par vaisseaux noirs suivent la cible en temps r√©el (homing)
     - Journal d'√©v√©nements avec filtres (Tous/Neutres/Guerres/Mes astres/Constructions)
     - √âv√©nements cliquables pour naviguer vers le lieu de l'action
     - Ic√¥nes color√©es selon le joueur dans le journal
     - Contr√¥le Nid/Biome/Off par syst√®me solaire dans le panneau gauche
     - Panneaux draggables et r√©tractables (6 panneaux)
     - Sauvegarde positions des panneaux dans Supabase (profil joueur)
     - Synchronisation curseurs config au d√©marrage
     - Espacement orbites solaires augment√© (pas de chevauchement avec m√©t√©orites)
     - Collision m√©t√©orites par proximit√© r√©elle d'amas (plus de faux positifs)

   v2.4.2 | 2026-02-27 | Mise en ligne & Auth
     - D√©ploiement GitHub Pages (gadmy.github.io/nebula-conquest)
     - Int√©gration Supabase Auth (inscription email + mot de passe)
     - √âcran de login avec choix de pseudo √† la premi√®re connexion
     - Tables Supabase : profiles, games, leaderboard (vue)
     - Row Level Security (RLS) sur toutes les tables
     - Sauvegarde automatique des parties en fin de game
     - √âcran Classement (leaderboard) accessible depuis le menu titre

   v2.4.1 | 2026-02-26 | Nettoyage debug & config
     - Suppression compl√®te du code debug (CSS, HTML, JS)
     - Suppression panneaux debug F2-F7
     - Config par d√©faut : 4 soleils, 4 joueurs, stats 0/0/0
     - Hitbox am√©lior√©es : lunes +12, petites plan√®tes +10
     - Couleurs ciel √©claircies (RGB 22,38,78)
     - Vitesse jets : 0.25 ‚Üí 0.70
     - Suppression fonction orpheline generateBackgroundFromConfig
     - Correction r√©f√©rence BG_CFG

   v2.4.0 | 2026-02-25 | Optimisation performances
     - √âtoiles de base pr√©-rendues sur canvas offscreen (‚àí2500 draw calls)
     - Amas stellaires pr√©-rendus sur canvas offscreen (‚àí660 draw calls)
     - LOD dynamique selon le zoom (3 niveaux de d√©tail)
     - Cache gradients √©toiles brillantes, soleils, atmosph√®res plan√©taires
     - Jets optimis√©s : tra√Æne simplifi√©e, sparkles LOD
     - Array allBodies pr√©-calcul√© (‚àí11 allocations/frame)
     - Minimap throttle (toutes les 15 frames)
     - FPS adaptatif (auto-LOD si FPS < 25)

   v2.3.0 | 2026-02-25 | Com√®tes, d√©bris & effets d'impact
     - Com√®tes destructrices (d√©truisent les spores au contact d'une plan√®te)
     - D√©bris au premier plan (effet parallaxe profondeur)
     - Debug F5 (vaisseaux/jets) et F6 (com√®tes)
     - Effets d'impact sur soleils et trou noir

   v2.2.0 | 2026-02-25 | UX ‚Äî Interface adaptable
     - Jauge de taille d'interface au-dessus de la minimap
     - Scroll horizontal dans "Mes Astres" pour les syst√®mes avec beaucoup de plan√®tes
     - Clic sur un astre dans "Mes Astres" ouvre aussi le codex

   v2.1.0 | 2026-02-25 | Multiplicit√©
     - Sacrifice : slider 0-50% de production globale d√©di√© √† l'√©volution
     - 10 paliers, co√ªt croissant (500 * 1.8^N)
     - Chaque palier = +1 point de stat (growth, velocity ou density)
     - Choix du stat √† chaque palier atteint
     - IA utilise aussi le syst√®me de multiplicit√©

   v2.0.0 | 2026-02-25 | Nids & Biomes
     - Mode production par plan√®te : OFF / NID / BIOME (radio dans codex)
     - Activation = maxSpores √∑ 3, production allou√©e au compteur
     - Co√ªt nid/biome = maxSpores, infini par plan√®te
     - Nid : +0.2% production locale par nid
     - Biome : +0.2% d√©fense locale par biome (co√ªt conqu√™te augment√©)
     - Reset √† la conqu√™te, IA utilise aussi

   v1.9.0 | 2026-02-25 | Fond spatial 5 couches
     - Couche 1 : voiles galactiques immenses (gradient + blobs irr√©guliers)
     - Couche 2 : 10 n√©buleuses denses avec rim lighting et c≈ìur lumineux
     - Couche 3 : filaments de gaz (tra√Æn√©es longues)
     - Couche 4 : 12 amas stellaires (distribution gaussienne)
     - Couche 5 : 25 √©toiles brillantes avec diffraction 8 branches + scintillement
     - 2500 √©toiles de base + 40 particules cosmiques + √©toiles filantes
     - Parallaxe individuelle par objet, drift et rotation

   v1.8.0 | 2026-02-24 | Polish final
     - Animation titre : lettres qui apparaissent une par une
     - √âtoiles filantes en fond sur l'√©cran titre
     - √âcran de chargement avec progression r√©elle
     - Transitions fade entre les √©crans
     - Panneau debug cach√© (F2 toggle conserv√©)
     - Nettoyage commentaires

   v1.7.0 | 2026-02-24 | Performance
     - Pool d'objets pour jets, impacts et effets
     - Cache des √©l√©ments DOM fr√©quemment acc√©d√©s
     - Throttle scoreboard (innerHTML moins fr√©quent)
     - Optimisation drawJets (moins de createRadialGradient)
     - R√©duction allocations dans les boucles de rendu

   v1.6.0 | 2026-02-24 | Audio avanc√©
     - Ambiance adaptative (tension quand attaqu√©, calme sinon)
     - Son de clic sur les boutons du menu
     - Son d'orbite subtil quand zoom√© sur une plan√®te
     - Variation de pitch sur les sons existants

   v1.5.0 | 2026-02-24 | Interface avanc√©e
     - Minimap (coin bas-droit, vue globale, rectangle de vue)
     - Indicateurs hors-√©cran (fl√®ches color√©es pour jets ennemis)
     - Compteur de temps de partie dans le HUD
     - Transitions fluides entre √©crans (fade 0.5s)
     - √âcran de chargement avec barre de progression

   v1.4.0 | 2026-02-24 | Fond spatial am√©lior√©
     - Parallaxe 3 couches (n√©buleuses lentes, √©toiles moyennes, poussi√®re rapide)
     - Particules ambiantes flottantes (poussi√®re cosmique)
     - √âtoiles filantes occasionnelles (1 toutes les 5-10s)

   v1.3.0 | 2026-02-24 | Textures & rendu am√©lior√©s
     - Anneaux pour les plan√®tes gazeuses
     - Atmosph√®re lumineuse (halo color√©, ocean/ice/gas)
     - Lunes vari√©es (glace, roche sombre, volcanique)
     - √âclairage directionnel des soleils sur plan√®tes proches
     - Animation d'impact (onde de choc + particules √©clats)

   v1.2.0 | 2026-02-24 | Symbiose
     - Propri√©t√© symbiose (0-100%) sur chaque astre poss√©d√©
     - Croissance : 100% en 10 min (plan√®tes), 100% en 5 min (lunes)
     - Reset √† 0 si l'astre change de propri√©taire
     - Bonus production : +20% √† 100% (plan√®tes), +10% (lunes)
     - Barre de symbiose dans le codex
     - Indicateur symbiose dans le panneau Mes Plan√®tes
     - Les IAs b√©n√©ficient aussi de la symbiose

   v1.1.0 | 2026-02-24 | Polish interface
     - Panneau plan√®tes : group√© par syst√®me solaire, d√©ploiement au survol
     - Ic√¥ne du soleil dans le label de chaque groupe
     - Badge PLAN√àTE / LUNE sur chaque astre
     - Codex : aper√ßu texture 80px de l'astre s√©lectionn√©
     - Zoom max augment√© √† x10
     - Valeurs jets ajust√©es (core:2, speed:0.70)

   v1.0.0 | 2026-02-24 | √âtape 10 ‚Äî Polish & optimisation
     - Culling : ne dessine que les astres visibles √† l'√©cran
     - Batch rendering des √©toiles de fond
     - Optimisation des collisions (grille spatiale)
     - √âquilibrage Flore/Faune/vitesses orbites
     - √âcran de fin complet avec stats d√©taill√©es
     - Boutons Rejouer/Menu fonctionnels
     - Nettoyage du code et commentaires
     - Compatible Chrome/Firefox/Safari/Edge
     - GitHub Pages ready (fichier unique)

   v0.9.0 | 2026-02-24 | √âtape 9 ‚Äî Audio g√©n√©ratif
     - Web Audio API : aucun fichier externe
     - Ambiance spatiale : drone basse fr√©quence modul√©
     - Son de lancement de jet (texture granulaire)
     - Son de fusion sur astre ami (accord harmonique)
     - Son de conqu√™te/√©closion (accord ascendant)
     - Son de neutralisation (collision sourde)
     - Son de vaisseau nettoyeur (ping directionnel)
     - Son de victoire/d√©faite (s√©quence m√©lodique)
     - Contr√¥le du volume g√©n√©ral

   v0.8.0 | 2026-02-24 | √âtape 8 ‚Äî Obstacles & dangers
     - Trou noir : gravit√© active courbant les jets
     - Zone de destruction visible (jets trop proches d√©truits)
     - Vaisseaux nettoyeurs : patrouille entre syst√®mes solaires
     - Nettoyeurs tirent sur les jets √† port√©e (r√©duction de spores)
     - Nettoyeurs invincibles (contournement uniquement)
     - Trajectoires semi-al√©atoires lisibles √† court terme
     - Scaling : 1 vaisseau ‚â§5 plan√®tes, 2 pour 5-8, 3 pour 8-10

   v0.7.0 | 2026-02-24 | √âtape 7 ‚Äî Intelligence artificielle
     - IA Facile : cibles al√©atoires, r√©action lente (3s)
     - IA Normale : √©value Flore+proximit√©, interception basique, r√©action 1.5s
     - IA Brutale : interception orbitale, coordination multi-astres, r√©action 0.5s
     - Gestion attaque/d√©fense : garde des r√©serves sur astres expos√©s
     - Les IAs jouent selon les m√™mes r√®gles que le joueur humain

   v0.6.0 | 2026-02-24 | √âtape 6 ‚Äî Conqu√™te & √©conomie
     - Indicateur visuel de conqu√™te (chiffre flottant au-dessus des astres)
     - Animation d'√©closion √† 100% de conqu√™te
     - R√©g√©n√©ration de la Faune si attaque interrompue
     - Condition de victoire : 80% de la masse totale
     - √âlimination : plus d'astres + plus de jets ‚Üí mode spectateur
     - √âcran de fin avec stats et boutons Rejouer/Quitter
     - Affichage spores sur chaque astre poss√©d√©

   v0.5.0 | 2026-02-24 | √âtape 5 ‚Äî M√©canique de spores
     - Lancement de jets : clic maintenu sur astre ‚Üí glisser ‚Üí rel√¢cher
     - Pr√©visualisation trajectoire (70% en pointill√©s bioluminescents)
     - Trajectoire courb√©e par gravit√© du trou noir
     - Jets rendus comme gerbes bioluminescentes avec tra√Æne
     - Taille/intensit√© proportionnelles au nombre de spores
     - Collision jet-astre (d√©p√¥t de spores)
     - Neutralisation de jets crois√©s (proportionnelle)
     - Jets comme entit√©s uniques (jamais de spore individuelle)

   v0.4.0 | 2026-02-24 | √âtape 4 ‚Äî Interface & menus
     - √âcran titre avec bouton Nouvelle Partie
     - Config : soleils (4-20), joueurs (2-8), difficult√© IA
     - R√©partition des 10 points (Croissance, V√©locit√©, Densit√©)
     - S√©lecteur de couleur d'√©quipe
     - Phase de s√©lection de plan√®te de d√©part
     - HUD : compteur spores, tableau des scores
     - Panneau codex au clic sur un astre
     - Pause (mode solo)
     - Machine √† √©tats : menu ‚Üí config ‚Üí spawn ‚Üí game ‚Üí end

   v0.3.0 | 2026-02-24 | √âtape 3 ‚Äî Rendu visuel des astres
     - Textures proc√©durales pour plan√®tes (continents, mers, d√©serts, gazeuses)
     - Textures cach√©es sur canvas hors-√©cran (perf)
     - Soleils avec pulsation anim√©e
     - Trou noir avec disque d'accr√©tion rotatif
     - Lunes avec surface crat√©ris√©e
     - Types de plan√®tes : rocheuse, gazeuse, glaciale, d√©sertique, oc√©anique

   v0.2.0 | 2026-02-24 | √âtape 2 ‚Äî G√©n√©ration de l'univers
     - Trou noir central avec zone de danger
     - Soleils en orbite autour du trou noir (4-20)
     - Plan√®tes en orbite autour des soleils (2-10 par soleil)
     - Lunes en orbite autour des plan√®tes (0-3 par plan√®te)
     - G√©n√©rateur de noms proc√©duraux
     - Propri√©t√©s : Radius, Flore, Faune
     - Animation continue de toutes les orbites

   v0.1.0 | 2026-02-24 | √âtape 1 ‚Äî Squelette & Canvas
     - Structure HTML/CSS de base (single file)
     - Canvas plein √©cran avec fond √©toil√©
     - Boucle de jeu (requestAnimationFrame + delta time)
     - Syst√®me de cam√©ra : zoom (molette), panoramique (clic droit + drag)
     - Objet gameState centralis√©
     - Compteur FPS (debug)
     - G√©n√©ration d'√©toiles de fond (d√©cor statique)

   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   M√âTHODE DE TRAVAIL
   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   √âtapes du projet :
     1. ‚úÖ Squelette & Canvas
     2. ‚úÖ G√©n√©ration de l'univers
     3. ‚úÖ Rendu visuel des astres
     4. ‚úÖ Interface & menus
     5. ‚úÖ M√©canique de spores
     6. ‚úÖ Conqu√™te & √©conomie
     7. ‚úÖ Intelligence artificielle
     8. ‚úÖ Obstacles & dangers
     9. ‚úÖ Audio g√©n√©ratif
    10. ‚úÖ Polish & optimisation
    
   Post-v1.0 ‚Äî Am√©liorations :
    v1.1  ‚úÖ Polish interface (panneau plan√®tes, codex image, zoom x10)
    v1.2  ‚úÖ Symbiose (bonus production +20% plan√®tes / +10% lunes)
    v1.3  ‚úÖ Textures & rendu (anneaux gazeuses, atmosph√®re, √©clairage, impacts)
    v1.4  ‚úÖ Fond spatial (parallaxe 3 couches, particules, √©toiles filantes)
    v1.5  ‚úÖ Interface avanc√©e (minimap, indicateurs hors-√©cran, compteur temps, transitions)
    v1.6  ‚úÖ Audio avanc√© (ambiance adaptative, sons clic, son orbite, variation pitch)
    v1.7  ‚úÖ Performance (pool objets, cache gradients, batch particules, throttle DOM)
    v1.8  ‚úÖ Polish final (animation titre, √©cran chargement, nettoyage, suppression debug)

   ‚îÄ‚îÄ PHASE 2 : M√©caniques avanc√©es ‚îÄ‚îÄ
    v1.9  ‚úÖ Fond spatial 5 couches (voiles, n√©buleuses, filaments, amas, √©toiles)
    v2.0  ‚úÖ Nids & Biomes (production alternative par plan√®te, +0.2% prod/d√©fense local)
    v2.1  ‚úÖ Multiplicit√© (jauge √©volution, consomme spores, 10 paliers, +1 stat/palier)
    v2.2  ‚úÖ UX ‚Äî Interface adaptable (zoom UI, scroll astres, clic‚Üícodex)
    v2.3  ‚úÖ Com√®tes, d√©bris & effets d'impact
    v2.4  ‚úÖ Optimisation performances (LOD, cache offscreen, FPS adaptatif)

   ‚îÄ‚îÄ PHASE 3 : Mise en ligne & multijoueur ‚îÄ‚îÄ
    v2.4.1 ‚úÖ Nettoyage debug & config (suppression debug F2-F7, r√©glages par d√©faut)
    v2.4.2 ‚úÖ Mise en ligne & Auth (GitHub Pages, Supabase, login, pseudo, leaderboard)
    v2.4.3 ‚úÖ Gameplay avanc√© & UI (ast√©ro√Ødes, vaisseaux 3 types, journal, panneaux draggables)
    v2.4.5 ‚úÖ Panneaux UI (scale tous panneaux, snap magn√©tique, reset positions, 8 panneaux draggables)
    v2.4.6 üîß Multijoueur & minification

   Protocole par session :
     1. Uploader le fichier HTML actuel
     2. Pr√©ciser la fonctionnalit√© ou correction souhait√©e
     3. Claude analyse et propose une strat√©gie
     4. Modifications en CHERCHE/REMPLACE (‚â§150 car.)
     5. Appliquer chaque modification par copier-coller
     6. Tester dans le navigateur apr√®s chaque changement
     7. Valider ou signaler un probl√®me
     8. It√©rer jusqu'√† compl√©tion

   R√®gles :
     - Jamais de r√©√©criture en bloc
     - Tester apr√®s chaque CHERCHE/REMPLACE
     - Un probl√®me = on corrige avant de continuer
     - Versionnement d√©cid√© par le d√©veloppeur uniquement
     - Backup avant chaque session
   ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// GAME STATE ‚Äî Objet central
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const gameState = {
    // ‚îÄ‚îÄ Machine √† √©tats ‚îÄ‚îÄ
    phase: 'title',  // 'title' | 'config' | 'spawn' | 'game' | 'paused' | 'end'
    isMulti: false,
    multiSeed: null,

    // ‚îÄ‚îÄ Canvas & rendu ‚îÄ‚îÄ
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,

    // ‚îÄ‚îÄ Cam√©ra ‚îÄ‚îÄ
    camera: {
        x: 0,        // position monde (centre de vue)
        y: 0,
        zoom: 1,
        minZoom: 0.05,
        maxZoom: 10,
        zoomSpeed: 0.1
    },

    // ‚îÄ‚îÄ Boucle de jeu ‚îÄ‚îÄ
    running: false,
    lastTime: 0,
    deltaTime: 0,

    // ‚îÄ‚îÄ Input ‚îÄ‚îÄ
    input: {
        isDragging: false,
        dragStartX: 0,
        dragStartY: 0,
        cameraStartX: 0,
        cameraStartY: 0,
        mouseX: 0,
        mouseY: 0
    },

    // ‚îÄ‚îÄ D√©cor ‚îÄ‚îÄ
    cosmicDust: [],       // particules ambiantes
    shootingStars: [],    // √©toiles filantes
    shootingStarTimer: 0,
    comets: [],           // com√®tes destructrices
    cometTimer: 0,
    foregroundDebris: [],  // d√©bris premier plan
    time: 0,              // temps total √©coul√© (pour animations)

    // ‚îÄ‚îÄ Performance ‚îÄ‚îÄ
    allBodies: [],         // planets + moons (recalcul√© √† la conqu√™te)
    lod: 2,               // 0=low, 1=mid, 2=high
    lodAutoTimer: 0,       // timer pour FPS adaptatif
    lodFpsAccum: 0,        // accumulateur FPS pour moyenne
    lodFpsSamples: 0,      // nombre d'√©chantillons FPS

    // ‚îÄ‚îÄ FPS ‚îÄ‚îÄ
    fps: 0,
    fpsFrames: 0,
    fpsLastCheck: 0,

    // ‚îÄ‚îÄ Univers (pr√©par√© pour √©tape 2) ‚îÄ‚îÄ
    blackHole: null,
    suns: [],
    planets: [],
    moons: [],

    // ‚îÄ‚îÄ Joueurs (pr√©par√© pour √©tape 4) ‚îÄ‚îÄ
    players: [],

    // ‚îÄ‚îÄ Jets (pr√©par√© pour √©tape 5) ‚îÄ‚îÄ
    jets: [],

    // ‚îÄ‚îÄ Vaisseaux nettoyeurs ‚îÄ‚îÄ
    cleaners: [],

    // ‚îÄ‚îÄ Amas de m√©t√©orites ‚îÄ‚îÄ
    asteroidBelts: [],

    // ‚îÄ‚îÄ Audio ‚îÄ‚îÄ
    audio: {
        ctx: null,
        masterGain: null,
        ambDrone: null,
        volume: 0,
        muted: true,
        initialized: false,
        tension: 0,
        tensionTarget: 0,
        orbitHum: null,
        orbitHumGain: null
    },

    // ‚îÄ‚îÄ Config partie ‚îÄ‚îÄ
    config: {
        sunCount: 4,
        playerCount: 4,
        difficulty: 'normal',  // 'easy' | 'normal' | 'brutal'
        useIA: true,
        cleanerCount: 3,
        useAsteroids: true
    },

    // ‚îÄ‚îÄ Joueur humain stats ‚îÄ‚îÄ
    playerStats: {
        growth: 3,
        velocity: 4,
        density: 3
    },
    playerColor: '#8B5CF6',

    // ‚îÄ‚îÄ Couleurs disponibles ‚îÄ‚îÄ
    teamColors: ['#8B5CF6','#EC4899','#EF4444','#F97316','#EAB308','#22C55E','#06B6D4','#3B82F6','#A855F7','#F472B6'],

    // ‚îÄ‚îÄ Codex ‚îÄ‚îÄ
    selectedBody: null,
    codexOpen: false,

    // ‚îÄ‚îÄ Effets visuels conqu√™te ‚îÄ‚îÄ
    conquestEffects: [],   // {x, y, text, color, age, maxAge}
    bloomEffects: [],      // {body, age, maxAge, color}
    impactEffects: [],     // {x, y, color, particles[], age, maxAge}

    // ‚îÄ‚îÄ Log d'√©v√©nements ‚îÄ‚îÄ
    eventLog: [],

    // ‚îÄ‚îÄ Stats de partie ‚îÄ‚îÄ
    gameStats: {
        jetsLaunched: 0,
        jetsNeutralized: 0,
        bodiesConquered: 0,
        sporesProduced: 0,
        timeElapsed: 0
    },

    // ‚îÄ‚îÄ Lancement de jets ‚îÄ‚îÄ
    jetRatio: 0.5,         // pourcentage de spores envoy√©es (0.0 √† 1.0)
    launching: false,
    launchSource: null,
    launchPreview: [],
    mouseWorldX: 0,
    mouseWorldY: 0
};


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CACHE DOM
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DOM = {};
function cacheDom() {
    DOM.fps = document.getElementById('fps');
    DOM.sporeCount = document.getElementById('sporeCount');
    DOM.scoreBoard = document.getElementById('scoreBoard');
    DOM.gameTimer = document.getElementById('gameTimer');
    DOM.codexName = document.getElementById('codexName');
    DOM.codexType = document.getElementById('codexType');
    DOM.codexRadius = document.getElementById('codexRadius');
    DOM.codexFlore = document.getElementById('codexFlore');
    DOM.codexFaune = document.getElementById('codexFaune');
    DOM.codexOwner = document.getElementById('codexOwner');
    DOM.codexSpores = document.getElementById('codexSpores');
    DOM.codexSymVal = document.getElementById('codexSymVal');
    DOM.codexSymBar = document.getElementById('codexSymBar');
    DOM.codexSymBonus = document.getElementById('codexSymBonus');
    DOM.codexSymbiose = document.getElementById('codexSymbiose');
    DOM.codexPreview = document.getElementById('codexPreview');
    DOM.codex = document.getElementById('codex');
    DOM.myPlanetsList = document.getElementById('myPlanetsList');
    DOM.myPlanets = document.getElementById('myPlanets');
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INITIALISATION
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function init() {
    // Canvas setup
    gameState.canvas = document.getElementById('gameCanvas');
    gameState.ctx = gameState.canvas.getContext('2d');
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Cache DOM
    cacheDom();

    // Input listeners
    setupInput();

    // Interface
    setupUI();

    // Cacher le loading
    hideLoading();

    // D√©marrer sur l'√©cran titre
    setPhase('title');
}

function resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    gameState.width = window.innerWidth;
    gameState.height = window.innerHeight;
    gameState.canvas.width = gameState.width * dpr;
    gameState.canvas.height = gameState.height * dpr;
    gameState.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FOND SPATIAL (pr√©-rendu sur canvas hors-√©cran)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function generateBackground() {
    const rng = mulberry32(42);
    // ‚ïê‚ïê Fond bleu d√©grad√© (canvas offscreen) ‚ïê‚ïê
    const bgW = 2048, bgH = 2048;
    const bgC = document.createElement('canvas');
    bgC.width = bgW; bgC.height = bgH;
    const bgCtx = bgC.getContext('2d');
    // Gradient de base : bleu profond
    const gBase = bgCtx.createLinearGradient(0, 0, bgW, bgH);
    gBase.addColorStop(0, '#0a1628');
    gBase.addColorStop(0.3, '#0f2040');
    gBase.addColorStop(0.5, '#162d50');
    gBase.addColorStop(0.7, '#0d1a35');
    gBase.addColorStop(1, '#081020');
    bgCtx.fillStyle = gBase;
    bgCtx.fillRect(0, 0, bgW, bgH);
    // Taches lumineuses diffuses (blobs radial)
    const blobColors = [
        [20, 40, 80], [15, 50, 90], [25, 35, 70],
        [10, 30, 65], [30, 50, 100], [18, 45, 85]
    ];
    for (let i = 0; i < 18; i++) {
        const bx = rng() * bgW;
        const by = rng() * bgH;
        const br = 200 + rng() * 500;
        const bc = blobColors[i % blobColors.length];
        const ba = 0.08 + rng() * 0.12;
        const g = bgCtx.createRadialGradient(bx, by, 0, bx, by, br);
        g.addColorStop(0, `rgba(${bc[0]+20},${bc[1]+20},${bc[2]+30}, ${ba})`);
        g.addColorStop(0.5, `rgba(${bc[0]},${bc[1]},${bc[2]}, ${ba * 0.5})`);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        bgCtx.fillStyle = g;
        bgCtx.beginPath();
        bgCtx.arc(bx, by, br, 0, Math.PI * 2);
        bgCtx.fill();
    }
    gameState._bgCanvas = bgC;

    // ‚ïê‚ïê √âtoiles (canvas offscreen tuilable) ‚ïê‚ïê
    const stW = 2048, stH = 2048;
    const stC = document.createElement('canvas');
    stC.width = stW; stC.height = stH;
    const stCtx = stC.getContext('2d');
    const starColors = ['255,255,255','220,230,255','200,210,240','255,240,220','180,200,255'];
    const starsCount = 3000;
    for (let i = 0; i < starsCount; i++) {
        const sx = rng() * stW;
        const sy = rng() * stH;
        const sr = rng() * 1.3 + 0.3;
        const sa = rng() * 0.6 + 0.2;
        const sc = starColors[Math.floor(rng() * starColors.length)];
        stCtx.fillStyle = `rgba(${sc}, ${sa})`;
        stCtx.beginPath();
        stCtx.arc(sx, sy, sr, 0, Math.PI * 2);
        stCtx.fill();
        // Quelques √©toiles plus brillantes avec halo
        if (rng() > 0.95) {
            const gh = stCtx.createRadialGradient(sx, sy, 0, sx, sy, sr * 4);
            gh.addColorStop(0, `rgba(${sc}, 0.3)`);
            gh.addColorStop(1, 'rgba(0,0,0,0)');
            stCtx.fillStyle = gh;
            stCtx.beginPath();
            stCtx.arc(sx, sy, sr * 4, 0, Math.PI * 2);
            stCtx.fill();
        }
    }
    gameState._starsCanvas = stC;

    // ‚ïê‚ïê Particules ambiantes (poussi√®re cosmique) ‚Äî on garde ‚ïê‚ïê
    gameState.cosmicDust = [];
    const rng4 = mulberry32(55);
    for (let i = 0; i < 40; i++) {
        gameState.cosmicDust.push({
            x: (rng4() - 0.5) * 15000,
            y: (rng4() - 0.5) * 15000,
            vx: (rng4() - 0.5) * 3,
            vy: (rng4() - 0.5) * 3,
            size: rng4() * 2 + 0.5,
            alpha: rng4() * 0.12 + 0.03,
            phase: rng4() * Math.PI * 2
        });
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PERFORMANCE ‚Äî Caches offscreen (√©toiles, clusters, halos)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function buildSunHaloCache() {
    for (const sun of gameState.suns) {
        const haloR = sun.radius * 3;
        const dim = Math.ceil(haloR * 2 + 4);
        const c = document.createElement('canvas');
        c.width = dim; c.height = dim;
        const ctx = c.getContext('2d');
        const cx = dim / 2, cy = dim / 2;
        const g = ctx.createRadialGradient(cx, cy, sun.radius * 0.3, cx, cy, haloR);
        g.addColorStop(0, sun.color + '50');
        g.addColorStop(0.5, sun.color + '15');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.beginPath();
        ctx.arc(cx, cy, haloR, 0, Math.PI * 2);
        ctx.fill();
        sun._haloCache = c;
        sun._haloDim = dim;
        sun._haloR = haloR;
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// TEXTURES PROC√âDURALES (canvas hors-√©cran)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function createPlanetTexture(planet) {
    const size = Math.max(Math.floor(planet.radius * 2 * 3), 16);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    // Type de plan√®te bas√© sur le nom (seed d√©terministe)
    const seed = planet.name.charCodeAt(0) + planet.name.charCodeAt(1) * 7;
    const types = ['rocky','ocean','desert','gas','ice'];
    planet.planetType = types[seed % types.length];

    const palettes = {
        rocky:  { base: '#8B7355', c1: '#6B5B45', c2: '#A09070', sea: null },
        ocean:  { base: '#2266AA', c1: '#1B5090', c2: '#33AACC', sea: '#1A4477' },
        desert: { base: '#C4A35A', c1: '#B8943F', c2: '#D4B870', sea: null },
        gas:    { base: '#C9956B', c1: '#B07850', c2: '#DDB88A', sea: null },
        ice:    { base: '#A0C4D8', c1: '#88B0CC', c2: '#C8E0F0', sea: '#7099B8' }
    };
    const pal = palettes[planet.planetType];

    // Fond circulaire
    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Base
    cx.fillStyle = pal.base;
    cx.fillRect(0, 0, size, size);

    // Bruit pseudo-al√©atoire pour les continents/bandes
    const rng = mulberry32(seed);

    if (planet.planetType === 'gas') {
        // Bandes horizontales pour gazeuses
        for (let y = 0; y < size; y += 3) {
            const intensity = Math.sin(y * 0.3 + rng() * 6) * 0.3;
            cx.fillStyle = intensity > 0 ? pal.c2 + '80' : pal.c1 + '60';
            cx.fillRect(0, y, size, 2);
        }
    } else {
        // Continents / taches
        const patches = 4 + Math.floor(rng() * 6);
        for (let i = 0; i < patches; i++) {
            const px = rng() * size;
            const py = rng() * size;
            const pr = rng() * r * 0.6 + r * 0.15;
            const g = cx.createRadialGradient(px, py, 0, px, py, pr);
            g.addColorStop(0, pal.c1 + 'AA');
            g.addColorStop(0.6, pal.c2 + '66');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            cx.fillStyle = g;
            cx.beginPath();
            cx.arc(px, py, pr, 0, Math.PI * 2);
            cx.fill();
        }

        // Mers si applicable
        if (pal.sea) {
            const seaPatches = 2 + Math.floor(rng() * 3);
            for (let i = 0; i < seaPatches; i++) {
                const sx = rng() * size;
                const sy = rng() * size;
                const sr = rng() * r * 0.5 + r * 0.1;
                const g = cx.createRadialGradient(sx, sy, 0, sx, sy, sr);
                g.addColorStop(0, pal.sea + 'BB');
                g.addColorStop(1, 'rgba(0,0,0,0)');
                cx.fillStyle = g;
                cx.beginPath();
                cx.arc(sx, sy, sr, 0, Math.PI * 2);
                cx.fill();
            }
        }
    }

    // Ombre sph√©rique (√©clairage)
    const gShade = cx.createRadialGradient(half * 0.7, half * 0.7, 0, half, half, r);
    gShade.addColorStop(0, 'rgba(255,255,255,0.15)');
    gShade.addColorStop(0.5, 'rgba(0,0,0,0)');
    gShade.addColorStop(1, 'rgba(0,0,0,0.4)');
    cx.fillStyle = gShade;
    cx.fillRect(0, 0, size, size);

    // Atmosph√®re (pour ocean, ice, gas)
    const atmoColors = {
        ocean: 'rgba(60, 140, 255, 0.12)',
        ice: 'rgba(150, 210, 255, 0.10)',
        gas: 'rgba(200, 160, 100, 0.08)',
        rocky: null,
        desert: null
    };
    const atmoCol = atmoColors[planet.planetType];
    if (atmoCol) {
        planet._hasAtmosphere = true;
        planet._atmoColor = atmoCol;
    }

    // Anneaux pour gazeuses
    if (planet.planetType === 'gas') {
        planet._hasRings = true;
        planet._ringColor1 = pal.c2 + '40';
        planet._ringColor2 = pal.c1 + '20';
        planet._ringTilt = 0.3 + rng() * 0.4;
    }

    planet._texture = c;
}

function createMoonTexture(moon) {
    const size = Math.max(Math.floor(moon.radius * 2 * 3), 10);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Type de lune (seed d√©terministe)
    const seed = moon.name.charCodeAt(0) + moon.name.charCodeAt(1) * 3;
    const rng = mulberry32(seed);
    const moonTypes = ['rock', 'ice', 'dark', 'volcanic'];
    moon.moonType = moonTypes[seed % moonTypes.length];

    const moonPalettes = {
        rock:     { base: '#9A9AAA', crater: 'rgba(60,60,70,0.5)', highlight: 'rgba(255,255,255,0.12)' },
        ice:      { base: '#B8D8E8', crater: 'rgba(80,100,120,0.4)', highlight: 'rgba(200,230,255,0.18)' },
        dark:     { base: '#4A4A55', crater: 'rgba(20,20,30,0.6)', highlight: 'rgba(180,180,200,0.08)' },
        volcanic: { base: '#6A4A3A', crater: 'rgba(200,60,20,0.5)', highlight: 'rgba(255,120,40,0.15)' }
    };
    const mp = moonPalettes[moon.moonType];

    // Base
    cx.fillStyle = mp.base;
    cx.fillRect(0, 0, size, size);

    // Variation de surface
    for (let i = 0; i < 3; i++) {
        const vx = rng() * size;
        const vy = rng() * size;
        const vr = rng() * r * 0.5 + r * 0.2;
        const g = cx.createRadialGradient(vx, vy, 0, vx, vy, vr);
        g.addColorStop(0, mp.base + '80');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = g;
        cx.beginPath();
        cx.arc(vx, vy, vr, 0, Math.PI * 2);
        cx.fill();
    }

    // Crat√®res
    const craters = 3 + Math.floor(rng() * 5);
    for (let i = 0; i < craters; i++) {
        const cx2 = rng() * size;
        const cy2 = rng() * size;
        const cr = rng() * r * 0.3 + 1;
        const g = cx.createRadialGradient(cx2, cy2, 0, cx2, cy2, cr);
        g.addColorStop(0, mp.crater);
        g.addColorStop(0.7, mp.crater);
        g.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = g;
        cx.beginPath();
        cx.arc(cx2, cy2, cr, 0, Math.PI * 2);
        cx.fill();

        // Liser√© de crat√®re (rebord lumineux)
        cx.strokeStyle = mp.highlight;
        cx.lineWidth = 0.5;
        cx.beginPath();
        cx.arc(cx2, cy2, cr, 0, Math.PI * 2);
        cx.stroke();
    }

    // Points lumineux volcaniques
    if (moon.moonType === 'volcanic') {
        for (let i = 0; i < 4; i++) {
            const lx = rng() * size;
            const ly = rng() * size;
            const lr = rng() * 2 + 0.5;
            const g = cx.createRadialGradient(lx, ly, 0, lx, ly, lr * 2);
            g.addColorStop(0, 'rgba(255, 80, 20, 0.6)');
            g.addColorStop(0.5, 'rgba(255, 40, 0, 0.2)');
            g.addColorStop(1, 'rgba(0,0,0,0)');
            cx.fillStyle = g;
            cx.beginPath();
            cx.arc(lx, ly, lr * 2, 0, Math.PI * 2);
            cx.fill();
        }
    }

    // Reflets glac√©s
    if (moon.moonType === 'ice') {
        for (let i = 0; i < 3; i++) {
            const lx = rng() * size;
            const ly = rng() * size;
            const lr = rng() * r * 0.15 + 1;
            cx.fillStyle = 'rgba(220, 240, 255, 0.15)';
            cx.beginPath();
            cx.arc(lx, ly, lr, 0, Math.PI * 2);
            cx.fill();
        }
    }

    // Ombre sph√©rique
    const gShade = cx.createRadialGradient(half * 0.7, half * 0.7, 0, half, half, r);
    gShade.addColorStop(0, mp.highlight);
    gShade.addColorStop(0.5, 'rgba(0,0,0,0)');
    gShade.addColorStop(1, 'rgba(0,0,0,0.35)');
    cx.fillStyle = gShade;
    cx.fillRect(0, 0, size, size);

    moon._texture = c;
}

function createSunTexture(sun) {
    const size = Math.floor(sun.radius * 2 * 3);
    const c = document.createElement('canvas');
    c.width = size; c.height = size;
    const cx = c.getContext('2d');
    const half = size / 2;
    const r = half - 1;

    cx.beginPath();
    cx.arc(half, half, r, 0, Math.PI * 2);
    cx.clip();

    // Gradient de base
    const g = cx.createRadialGradient(half * 0.8, half * 0.8, 0, half, half, r);
    g.addColorStop(0, '#FFFFFF');
    g.addColorStop(0.2, sun.color);
    g.addColorStop(1, sun.color + '88');
    cx.fillStyle = g;
    cx.fillRect(0, 0, size, size);

    // Taches solaires
    const seed = sun.name.charCodeAt(0) * 13;
    const rng = mulberry32(seed);
    for (let i = 0; i < 3; i++) {
        const sx = half + (rng() - 0.5) * r;
        const sy = half + (rng() - 0.5) * r;
        const sr = rng() * r * 0.2 + 2;
        const gs = cx.createRadialGradient(sx, sy, 0, sx, sy, sr);
        gs.addColorStop(0, 'rgba(0,0,0,0.15)');
        gs.addColorStop(1, 'rgba(0,0,0,0)');
        cx.fillStyle = gs;
        cx.beginPath();
        cx.arc(sx, sy, sr, 0, Math.PI * 2);
        cx.fill();
    }

    sun._texture = c;
}

// PRNG global pour g√©n√©ration d√©terministe
let _worldRng = null;
function worldRandom() { return _worldRng ? _worldRng() : Math.random(); }
let _gameRng = null;
function gameRandom() { return _gameRng ? _gameRng() : Math.random(); }

// PRNG d√©terministe (mulberry32)
function mulberry32(a) {
    return function() {
        a |= 0; a = a + 0x6D2B79F5 | 0;
        var t = Math.imul(a ^ a >>> 15, 1 | a);
        t = t + Math.imul(t ^ t >>> 7, 61 | t) ^ t;
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// G√âN√âRATEUR DE NOMS PROC√âDURAUX
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function generateName() {
    const prefixes = ['Zan','Kry','Vel','Xor','Neb','Thal','Aur','Pyx','Cel','Dra','Ith','Vor','Syn','Pal','Eri','Omi','Zet','Sig','Cor','Lyr'];
    const mids = ['a','o','u','i','e','an','on','ar','el','is','ax','um','al','en','os','ir'];
    const suffixes = ['th','ra','nis','xis','ton','ria','mus','pha','dis','lux','vyn','don','zar','mir','bus','tis'];
    return prefixes[Math.floor(worldRandom()*prefixes.length)]
        + mids[Math.floor(worldRandom()*mids.length)]
        + suffixes[Math.floor(worldRandom()*suffixes.length)];
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// G√âN√âRATION DE L'UNIVERS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function generateUniverse() {
    const cfg = gameState.config;
    const seed = gameState.multiSeed || Math.floor(Math.random() * 2147483647);
    gameState.multiSeed = seed;
    _worldRng = mulberry32(seed);
    const sunCount = cfg.sunCount;

    // ‚îÄ‚îÄ Trou noir central ‚îÄ‚îÄ
    gameState.blackHole = {
        x: 0, y: 0,
        radius: 300,
        dangerZone: 300,
        gravityRange: 1500,
        gravityStrength: 1260
    };

    // ‚îÄ‚îÄ Soleils ‚îÄ‚îÄ
    gameState.suns = [];
    gameState.planets = [];
    gameState.moons = [];

    const _d = window._debugCfg || {};
    const baseOrbitRadius = _d.sunOrbitBase || 200;
    const orbitSpacing = _d.sunOrbitSpacing || 100;
    const MIN_BH_GAP = 50;
    const MIN_SYS_GAP = 10;

    // Orbites partag√©es : capacit√© max par anneau
    const orbitSlots = [
        [2, 3], [3, 5], [3, 5],
        [3, 5], [3, 5], [3, 5]  // anneaux suppl√©mentaires si beaucoup de soleils
    ];
    // R√©partir les soleils sur les orbites
    let remaining = sunCount;
    let orbitIdx = 0;
    const orbitPlan = []; // [{orbitR, speed, count}]
    while (remaining > 0 && orbitIdx < orbitSlots.length) {
        const [minS, maxS] = orbitSlots[orbitIdx];
        const count = Math.min(remaining, minS + Math.floor(worldRandom() * (maxS - minS + 1)));
        const orbitR = baseOrbitRadius + orbitIdx * orbitSpacing + (worldRandom() - 0.5) * 40;
        const speed = (0.02 + worldRandom() * 0.015) / (1 + orbitIdx * 0.15);
        orbitPlan.push({ orbitR, speed, count });
        remaining -= count;
        orbitIdx++;
    }

    for (const orbit of orbitPlan) {
        // Angle de d√©part al√©atoire pour cette orbite
        const baseAngle = worldRandom() * Math.PI * 2;
        // Espacement angulaire avec variation
        const angleStep = (Math.PI * 2) / orbit.count;
        const angleJitter = angleStep * 0.2; // ¬±20% de variation

        for (let i = 0; i < orbit.count; i++) {
            const angle = baseAngle + i * angleStep + (worldRandom() - 0.5) * angleJitter;

            const sun = {
                type: 'sun',
                name: generateName(),
                radius: (_d.sunRadMin || 80) + worldRandom() * (_d.sunRadVar || 24),
                orbitRadius: orbit.orbitR,
                orbitSpeed: orbit.speed,
                angle: angle,
                x: 0, y: 0,
                color: ['#FFE44D','#FFB830','#FF8C42','#FF6B6B','#7CB9FF'][Math.floor(worldRandom()*5)],
                planets: []
            };

            // Position initiale
            sun.x = Math.cos(sun.angle) * sun.orbitRadius;
            sun.y = Math.sin(sun.angle) * sun.orbitRadius;

        // ‚îÄ‚îÄ Plan√®tes pour ce soleil ‚îÄ‚îÄ
        const planetCount = 2 + Math.floor(worldRandom() * 9); // 2-10
        const pBaseOrbit = sun.radius * 2.5 + (_d.pOrbitBase || 30);
        const pSpacing = (_d.pOrbitSpacing || 95) + worldRandom() * (_d.pOrbitSpacingVar || 15);

        for (let p = 0; p < planetCount; p++) {
            const pOrbitR = pBaseOrbit + p * pSpacing + worldRandom() * 20;
            const pSpeed = (0.08 + worldRandom() * 0.06) / (1 + p * 0.2);
            const pAngle = worldRandom() * Math.PI * 2;
            const pRadius = (_d.pRadMin || 20) + worldRandom() * (_d.pRadVar || 12);

            const planet = {
                type: 'planet',
                name: generateName(),
                radius: pRadius,
                flore: Math.floor(worldRandom() * 101),
                faune: Math.floor(worldRandom() * 101),
                _baseFaune: 0,
                symbiosis: 0,
                symOwnerTime: 0,
                buildMode: 'off',
                buildProgress: 0,
                nids: 0,
                biomes: 0,
                orbitRadius: pOrbitR,
                orbitSpeed: pSpeed,
                angle: pAngle,
                parent: sun,
                x: 0, y: 0,
                owner: null,
                spores: 0,
                maxSpores: Math.floor(pRadius * 50),
                moons: []
            };

            planet._baseFaune = planet.faune;
            planet.x = sun.x + Math.cos(planet.angle) * planet.orbitRadius;
            planet.y = sun.y + Math.sin(planet.angle) * planet.orbitRadius;

            // ‚îÄ‚îÄ Lunes (0-3, pas pour toutes) ‚îÄ‚îÄ
            const hasMoons = worldRandom() > 0.4;
            if (hasMoons) {
                const moonCount = 1 + Math.floor(worldRandom() * 3);
                for (let m = 0; m < moonCount; m++) {
                    const mOrbitR = planet.radius * 2 + (_d.mOrbitBase || 12) + m * (_d.mOrbitSpacing || 14) + worldRandom() * 5;
                    const mSpeed = 0.15 + worldRandom() * 0.2;
                    const mRadius = (_d.mRadMin || 10) + worldRandom() * (_d.mRadVar || 2);

                    const moon = {
                        type: 'moon',
                        name: generateName(),
                        radius: mRadius,
                        flore: Math.floor(worldRandom() * 51),
                        faune: Math.floor(worldRandom() * 61),
                        symbiosis: 0,
                        symOwnerTime: 0,
                        buildMode: 'off',
                        buildProgress: 0,
                        nids: 0,
                        biomes: 0,
                        orbitRadius: mOrbitR,
                        orbitSpeed: mSpeed,
                        angle: worldRandom() * Math.PI * 2,
                        parent: planet,
                        x: 0, y: 0,
                        owner: null,
                        spores: 0,
                        maxSpores: Math.floor(mRadius * 50)
                    };

                    moon.x = planet.x + Math.cos(moon.angle) * moon.orbitRadius;
                    moon.y = planet.y + Math.sin(moon.angle) * moon.orbitRadius;

                    planet.moons.push(moon);
                    gameState.moons.push(moon);
                }
            }

            sun.planets.push(planet);
            gameState.planets.push(planet);
        }

        gameState.suns.push(sun);
        }
    }

    // ‚îÄ‚îÄ Espacement s√©curis√© des syst√®mes solaires ‚îÄ‚îÄ
    function systemOuterRadius(sun) {
        let maxR = 0;
        for (const p of sun.planets) {
            let pr = p.orbitRadius + p.radius;
            for (const m of p.moons) pr = Math.max(pr, p.orbitRadius + m.orbitRadius + m.radius);
            maxR = Math.max(maxR, pr);
        }
        // Marge pour les ceintures d'ast√©ro√Ødes ext√©rieures
        if (maxR > 0) maxR += 280;
        return maxR;
    }
    // Trier les soleils par orbitRadius croissant
    gameState.suns.sort((a, b) => a.orbitRadius - b.orbitRadius);
    const bhSafe = gameState.blackHole.dangerZone;
    for (let i = 0; i < gameState.suns.length; i++) {
        const sun = gameState.suns[i];
        const sysR = systemOuterRadius(sun);
        // 1) Ne pas toucher le trou noir
        const minFromBH = bhSafe + sysR + MIN_BH_GAP;
        if (sun.orbitRadius < minFromBH) sun.orbitRadius = minFromBH;
        // 2) Ne pas croiser le syst√®me pr√©c√©dent
        if (i > 0) {
            const prev = gameState.suns[i - 1];
            const prevR = systemOuterRadius(prev);
            const minDist = prevR + sysR + MIN_SYS_GAP;
            if (sun.orbitRadius - prev.orbitRadius < minDist) {
                sun.orbitRadius = prev.orbitRadius + minDist;
            }
        }
        // Recalculer position initiale
        sun.x = Math.cos(sun.angle) * sun.orbitRadius;
        sun.y = Math.sin(sun.angle) * sun.orbitRadius;
        for (const p of sun.planets) {
            p.x = sun.x + Math.cos(p.angle) * p.orbitRadius;
            p.y = sun.y + Math.sin(p.angle) * p.orbitRadius;
            for (const m of p.moons) {
                m.x = p.x + Math.cos(m.angle) * m.orbitRadius;
                m.y = p.y + Math.sin(m.angle) * m.orbitRadius;
            }
        }
    }

    // ‚îÄ‚îÄ Vaisseaux nettoyeurs ‚îÄ‚îÄ
    gameState.cleaners = [];
    const cleanerCount = gameState.config.cleanerCount || 3;

    const clTypes = ['red', 'green', 'dark'];
    for (let c = 0; c < cleanerCount; c++) {
        const angle = (c / cleanerCount) * Math.PI * 2 + worldRandom() * 0.5;
        const dist = 400 + worldRandom() * 2000;
        gameState.cleaners.push({
            x: Math.cos(angle) * dist,
            y: Math.sin(angle) * dist,
            vx: (worldRandom() - 0.5) * 15,
            vy: (worldRandom() - 0.5) * 15,
            angle: angle,
            turnTimer: 0,
            turnInterval: 4 + worldRandom() * 6,
            detectionRange: 200,
            fireRate: 1.5,
            fireTimer: 0,
            size: 8,
            type: clTypes[c % 3]
        });
    }

    // ‚îÄ‚îÄ Amas de m√©t√©orites (4 ceintures : 1 interne + 3 externes) ‚îÄ‚îÄ
    gameState.asteroidBelts = [];
    if (gameState.config.useAsteroids) {
        const beltTypes = ['dark', 'red', 'green'];
        for (const sun of gameState.suns) {
            const firstPlanet = sun.planets[0];
            const lastPlanet = sun.planets[sun.planets.length - 1];
            // 1 ceinture interne (entre le soleil et la premi√®re plan√®te)
            const innerRadius = firstPlanet ? sun.radius * 2.5 + (firstPlanet.orbitRadius - sun.radius * 2.5) * (0.3 + worldRandom() * 0.3) : sun.radius * 4;
            // 3 ceintures externes (apr√®s la derni√®re plan√®te, espac√©es)
            const outerBase = lastPlanet ? lastPlanet.orbitRadius + 100 + worldRandom() * 60 : sun.radius * 6 + 120;
            const beltRadii = [
                innerRadius,
                outerBase,
                outerBase + 80 + worldRandom() * 60,
                outerBase + 180 + worldRandom() * 80
            ];
            for (let bi = 0; bi < 4; bi++) {
                const isInner = (bi === 0);
                const asteroidCount = isInner ? 1 : (3 + Math.floor(worldRandom() * 6));
                const rocks = [];
                for (let a = 0; a < asteroidCount; a++) {
                    const rockType = beltTypes[Math.floor(worldRandom() * 3)];
                    const aAngle = (a / asteroidCount) * Math.PI * 2 + (worldRandom() - 0.5) * 0.4;
                    const rOff = (worldRandom() - 0.5) * 25;
                    const rockCount = 3 + Math.floor(worldRandom() * 4);
                    const subRocks = [];
                    for (let r = 0; r < rockCount; r++) {
                        const baseR = 50 + Math.floor(worldRandom() * 50);
                        const baseG = 40 + Math.floor(worldRandom() * 40);
                        const baseB = 35 + Math.floor(worldRandom() * 35);
                        let cr = baseR, cg = baseG, cb = baseB;
                        if (r % 3 === 0) {
                            if (rockType === 'dark') { cr -= 15; cg -= 15; cb -= 10; }
                            else if (rockType === 'red') { cr += 60; cg -= 10; cb -= 10; }
                            else { cr -= 10; cg += 50; cb -= 10; }
                        }
                        subRocks.push({
                            offX: (worldRandom() - 0.5) * 16,
                            offY: (worldRandom() - 0.5) * 16,
                            size: 2 + worldRandom() * 4,
                            color: `rgb(${Math.max(0,cr)},${Math.max(0,cg)},${Math.max(0,cb)})`
                        });
                    }
                    rocks.push({
                        angle: aAngle,
                        radiusOff: rOff,
                        subRocks: subRocks,
                        type: rockType
                    });
                }
                gameState.asteroidBelts.push({
                    sun: sun,
                    radius: beltRadii[bi],
                    orbitSpeed: isInner ? (0.012 + worldRandom() * 0.008) : (0.005 + worldRandom() * 0.006),
                    rocks: rocks
                });
            }
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PERFORMANCE ‚Äî allBodies cache
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function rebuildAllBodies() {
    gameState.allBodies = gameState.planets.concat(gameState.moons);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PERFORMANCE ‚Äî LOD dynamique + FPS adaptatif
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateLOD(dt) {
    const z = gameState.camera.zoom;
    let zoomLod = 2;
    if (z < 0.35) zoomLod = 0;
    else if (z < 0.6) zoomLod = 1;

    gameState.lodFpsAccum += gameState.fps;
    gameState.lodFpsSamples++;
    gameState.lodAutoTimer += dt;
    let fpsLod = 2;
    if (gameState.lodAutoTimer >= 1.5 && gameState.lodFpsSamples > 0) {
        const avgFps = gameState.lodFpsAccum / gameState.lodFpsSamples;
        if (avgFps < 25) fpsLod = 0;
        else if (avgFps < 40) fpsLod = 1;
        gameState.lodAutoTimer = 0;
        gameState.lodFpsAccum = 0;
        gameState.lodFpsSamples = 0;
    } else {
        fpsLod = gameState.lod;
    }

    gameState.lod = Math.min(zoomLod, fpsLod);
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// UPDATE ‚Äî Orbites
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateOrbits(dt) {
    // Soleils autour du trou noir
    for (let i = 0; i < gameState.suns.length; i++) {
        const sun = gameState.suns[i];
        sun.angle += sun.orbitSpeed * dt;
        sun.x = Math.cos(sun.angle) * sun.orbitRadius;
        sun.y = Math.sin(sun.angle) * sun.orbitRadius;

        // Plan√®tes autour du soleil
        for (let j = 0; j < sun.planets.length; j++) {
            const planet = sun.planets[j];
            planet.angle += planet.orbitSpeed * dt;
            planet.x = sun.x + Math.cos(planet.angle) * planet.orbitRadius;
            planet.y = sun.y + Math.sin(planet.angle) * planet.orbitRadius;

            // Lunes autour de la plan√®te
            for (let k = 0; k < planet.moons.length; k++) {
                const moon = planet.moons[k];
                moon.angle += moon.orbitSpeed * dt;
                moon.x = planet.x + Math.cos(moon.angle) * moon.orbitRadius;
                moon.y = planet.y + Math.sin(moon.angle) * moon.orbitRadius;
            }
        }
    }

    // Amas de m√©t√©orites
    for (const belt of gameState.asteroidBelts) {
        for (const rock of belt.rocks) {
            rock.angle += belt.orbitSpeed * dt;
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INTERFACE ‚Äî Setup UI
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setupUI() {
    // ‚îÄ‚îÄ Couleur automatique (slot 0 = premi√®re couleur) ‚îÄ‚îÄ
    gameState.playerColor = gameState.teamColors[0];

    // ‚îÄ‚îÄ Sliders config ‚îÄ‚îÄ
    const cfgSuns = document.getElementById('cfgSuns');
    const cfgPlayers = document.getElementById('cfgPlayers');
    cfgSuns.addEventListener('input', () => {
        document.getElementById('cfgSunsVal').textContent = cfgSuns.value;
        gameState.config.sunCount = parseInt(cfgSuns.value);
    });
    cfgPlayers.addEventListener('input', () => {
        document.getElementById('cfgPlayersVal').textContent = cfgPlayers.value;
        gameState.config.playerCount = parseInt(cfgPlayers.value);
    });
    const cfgIA = document.getElementById('cfgIA');
    const cfgDifficulty = document.getElementById('cfgDifficulty');
    cfgIA.addEventListener('change', () => {
        gameState.config.useIA = cfgIA.value === 'on';
        cfgDifficulty.disabled = !gameState.config.useIA;
        cfgDifficulty.style.opacity = gameState.config.useIA ? '1' : '0.3';
    });
    const cfgCleaners = document.getElementById('cfgCleaners');
    cfgCleaners.addEventListener('input', () => {
        document.getElementById('cfgCleanersVal').textContent = cfgCleaners.value;
        gameState.config.cleanerCount = parseInt(cfgCleaners.value);
    });
    const cfgAsteroids = document.getElementById('cfgAsteroids');
    cfgAsteroids.addEventListener('change', () => {
        gameState.config.useAsteroids = cfgAsteroids.value === 'on';
    });

    // ‚îÄ‚îÄ Sliders stats (total = 10) ‚îÄ‚îÄ
    const sliders = ['statGrowth', 'statVelocity', 'statDensity'];
    const keys = ['growth', 'velocity', 'density'];
    // Synchroniser les sliders avec les valeurs par d√©faut
    sliders.forEach((id, idx) => {
        document.getElementById(id).value = gameState.playerStats[keys[idx]];
        document.getElementById(id + 'Val').textContent = gameState.playerStats[keys[idx]];
        document.getElementById(id).addEventListener('input', () => {
            enforceStatPoints(idx);
        });
    });
    document.getElementById('cfgSunsVal').textContent = gameState.config.sunCount;
    document.getElementById('cfgSuns').value = gameState.config.sunCount;
    document.getElementById('cfgPlayersVal').textContent = gameState.config.playerCount;
    document.getElementById('cfgPlayers').value = gameState.config.playerCount;
    document.getElementById('cfgCleanersVal').textContent = gameState.config.cleanerCount;
    document.getElementById('cfgCleaners').value = gameState.config.cleanerCount;
    enforceStatPoints(0);

    // ‚îÄ‚îÄ Boutons navigation ‚îÄ‚îÄ
    document.getElementById('btnNewGame').addEventListener('click', () => { ensureAudio(); playClickSound(); fadeTransition(() => setPhase('config')); });
    document.getElementById('btnBack').addEventListener('click', () => { playClickSound(); fadeTransition(() => setPhase('title')); });
    document.getElementById('btnStart').addEventListener('click', () => { playClickSound(); fadeTransition(() => startGame()); });
    document.getElementById('btnResume').addEventListener('click', () => {
        playClickSound();
        if (gameState.isMulti) {
            document.getElementById('pauseOverlay').classList.remove('active');
        } else {
            togglePause();
        }
    });
    document.getElementById('btnQuit').addEventListener('click', () => {
        playClickSound();
        document.getElementById('pauseOverlay').classList.remove('active');
        if (gameState.isMulti && currentRoom) {
            const slot = localSlot();
            const player = gameState.players[slot];
            if (player && player.alive) {
                player.isHuman = false;
                player.isLocal = false;
                player.aiTimer = 0;
                player.aiCooldown = gameState.config.difficulty === 'easy' ? 3 : gameState.config.difficulty === 'normal' ? 1.5 : 0.5;
                player.name = 'IA-' + player.name;
                sendAction('playerLeft', { slot: slot });
                addEvent('neutral', 'üö™', player.name + ' a quitt√© (remplac√© par IA)', null, player.color);
            }
            _leftRoom = { roomId: currentRoom.id, slot: slot, gameStateBackup: gameState };
            if (gameChannel) { _supa.removeChannel(gameChannel); gameChannel = null; }
        }
        gameState.running = false;
        stopAmbiance();
        setPhase('title');
    });
    document.getElementById('codexClose').addEventListener('click', closeCodex);
    document.getElementById('btnReplay').addEventListener('click', () => { hideEndScreen(); startGame(); });
    setupMinimap();
    setupVolumeControl();
    document.getElementById('btnEndQuit').addEventListener('click', () => { hideEndScreen(); setPhase('title'); });

    // ‚îÄ‚îÄ Touche √âchap pour pause ‚îÄ‚îÄ
    window.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
            if (gameState.phase === 'game') togglePause();
            else if (gameState.phase === 'paused') togglePause();
        }
        if (e.key === 'F1') {
            e.preventDefault();
            let panel = document.getElementById('debugF1');
            if (panel) { panel.style.display = panel.style.display === 'none' ? 'flex' : 'none'; return; }
            panel = document.createElement('div');
            panel.id = 'debugF1';
            panel.style.cssText = 'position:fixed;top:10px;left:10px;z-index:9999;background:rgba(0,10,30,0.92);border:1px solid #3af;color:#cde;font:12px monospace;padding:12px 16px;display:flex;flex-direction:column;gap:6px;border-radius:8px;max-height:90vh;overflow-y:auto;pointer-events:auto;min-width:340px;';
            const _P = window._debugCfg || {};
            const defs = [
                ['sunOrbitBase', 'Soleils: orbite base', 200, 100, 3000, 50],
                ['sunOrbitSpacing', 'Soleils: espacement', 100, 50, 2000, 50],
                ['sunRadMin', 'Soleils: rayon min', 80, 5, 120, 1],
                ['sunRadVar', 'Soleils: rayon var (+)', 24, 0, 60, 1],
                ['pOrbitBase', 'Plan√®tes: orbite base (√óR+)', 30, 5, 150, 5],
                ['pOrbitSpacing', 'Plan√®tes: espacement', 95, 10, 150, 5],
                ['pOrbitSpacingVar', 'Plan√®tes: esp. var (+)', 15, 0, 60, 5],
                ['pRadMin', 'Plan√®tes: rayon min', 20, 2, 40, 1],
                ['pRadVar', 'Plan√®tes: rayon var (+)', 12, 0, 30, 1],
                ['mOrbitBase', 'Lunes: orbite base (√óR+)', 12, 2, 40, 1],
                ['mOrbitSpacing', 'Lunes: espacement', 14, 4, 40, 1],
                ['mRadMin', 'Lunes: rayon min', 10, 1, 20, 1],
                ['mRadVar', 'Lunes: rayon var (+)', 2, 0, 12, 1],
            ];
            if (!window._debugCfg) {
                window._debugCfg = {};
                defs.forEach(d => window._debugCfg[d[0]] = d[2]);
            }
            const title = document.createElement('div');
            title.textContent = '‚öô DEBUG UNIVERS (F1)';
            title.style.cssText = 'font-size:13px;font-weight:bold;color:#3af;margin-bottom:4px;';
            panel.appendChild(title);
            defs.forEach(d => {
                const row = document.createElement('div');
                row.style.cssText = 'display:flex;align-items:center;gap:8px;';
                const lbl = document.createElement('span');
                lbl.textContent = d[1];
                lbl.style.cssText = 'flex:1;font-size:11px;';
                const sl = document.createElement('input');
                sl.type = 'range'; sl.min = d[3]; sl.max = d[4]; sl.step = d[5];
                sl.value = window._debugCfg[d[0]];
                sl.style.cssText = 'width:100px;';
                const val = document.createElement('span');
                val.textContent = sl.value;
                val.style.cssText = 'width:36px;text-align:right;color:#fff;font-size:11px;';
                sl.addEventListener('input', () => { window._debugCfg[d[0]] = parseFloat(sl.value); val.textContent = sl.value; });
                row.appendChild(lbl); row.appendChild(sl); row.appendChild(val);
                panel.appendChild(row);
            });
            const btnRow = document.createElement('div');
            btnRow.style.cssText = 'display:flex;gap:8px;margin-top:6px;';
            const btnRegen = document.createElement('button');
            btnRegen.textContent = 'üîÑ R√©g√©n√©rer univers';
            btnRegen.style.cssText = 'flex:1;padding:6px;background:#1a3a5c;color:#fff;border:1px solid #3af;border-radius:4px;cursor:pointer;font-size:12px;';
            btnRegen.addEventListener('click', () => {
                gameState.multiSeed = null;
                generateUniverse();
                gameState.suns.forEach(s => createSunTexture(s));
                gameState.planets.forEach(p => createPlanetTexture(p));
                gameState.moons.forEach(m => createMoonTexture(m));
                rebuildAllBodies();
                buildSunHaloCache();
            });
            const btnCopy = document.createElement('button');
            btnCopy.textContent = 'üìã Copier valeurs';
            btnCopy.style.cssText = 'flex:1;padding:6px;background:#1a3a5c;color:#fff;border:1px solid #3af;border-radius:4px;cursor:pointer;font-size:12px;';
            btnCopy.addEventListener('click', () => {
                const txt = JSON.stringify(window._debugCfg, null, 2);
                navigator.clipboard.writeText(txt).then(() => btnCopy.textContent = '‚úÖ Copi√© !');
                setTimeout(() => btnCopy.textContent = 'üìã Copier valeurs', 1500);
            });
            btnRow.appendChild(btnRegen); btnRow.appendChild(btnCopy);
            panel.appendChild(btnRow);
            document.body.appendChild(panel);
        }
    });
}

function enforceStatPoints(changedIdx) {
    const ids = ['statGrowth', 'statVelocity', 'statDensity'];
    const keys = ['growth', 'velocity', 'density'];
    const vals = ids.map(id => parseInt(document.getElementById(id).value));
    const total = vals.reduce((a, b) => a + b, 0);

    if (total > 10) {
        // R√©duire les autres proportionnellement
        const excess = total - 10;
        const others = [0, 1, 2].filter(i => i !== changedIdx);
        let remaining = excess;
        for (const oi of others) {
            const reduce = Math.min(vals[oi], Math.ceil(remaining / (others.length - others.indexOf(oi))));
            vals[oi] -= reduce;
            remaining -= reduce;
            if (remaining <= 0) break;
        }
        ids.forEach((id, i) => document.getElementById(id).value = vals[i]);
    }

    ids.forEach((id, i) => {
        gameState.playerStats[keys[i]] = vals[i];
        document.getElementById(id + 'Val').textContent = vals[i];
    });
    const used = vals.reduce((a, b) => a + b, 0);
    document.getElementById('pointsLeft').textContent = 10 - used;
}

function setPhase(phase) {
    gameState.phase = phase;
    if (spawnCountdownInterval) { clearInterval(spawnCountdownInterval); spawnCountdownInterval = null; }
    if (_roomPollTimer) { clearInterval(_roomPollTimer); _roomPollTimer = null; }

    // Cacher tous les √©crans
    document.getElementById('authScreen').classList.add('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('leaderboardScreen').classList.add('hidden');
    document.getElementById('helpScreen').classList.add('hidden');
    document.getElementById('eventLog').style.display = 'none';
    document.getElementById('configScreen').classList.add('hidden');
    document.getElementById('lobbyScreen').classList.add('hidden');
    document.getElementById('roomScreen').classList.add('hidden');
    document.getElementById('spawnBanner').classList.add('hidden');
    document.getElementById('gameHud').style.display = 'none';
    document.getElementById('pauseOverlay').classList.remove('active');
    document.getElementById('endScreen').classList.remove('active');
    document.getElementById('gameCanvas').style.display = 'none';

    document.getElementById('myPlanets').style.display = 'none';
    document.getElementById('minimap').style.display = 'none';
    document.getElementById('uiZoomControl').style.display = 'none';
    document.getElementById('sporeCounter').style.display = 'none';
    document.getElementById('evoPanel').style.display = 'none';
    document.getElementById('scoreBoard').style.display = 'none';
    document.getElementById('codex').classList.remove('open');
    document.getElementById('volumeControl').style.display = 'none';

    switch (phase) {
        case 'title':
            document.getElementById('titleScreen').classList.remove('hidden');
            if (_titleAnimPlayed) document.getElementById('titleScreen').classList.add('no-intro');
            gameState.running = false;
            const _pEl = document.getElementById('titlePseudo');
            if (_pEl) _pEl.textContent = currentProfile ? '‚¨° ' + currentProfile.pseudo : '';
            if (currentProfile) updateQuickMatchPanel();
            gameState.isMulti = false;
            gameState.multiSeed = null;
            if (gameChannel) { _supa.removeChannel(gameChannel); gameChannel = null; }
            if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); currentRoomChannel = null; }
            currentRoom = null; isHost = false;
            stopAmbiance();
            animateTitleScreen();
            break;
        case 'createMulti':
            document.getElementById('lobbyScreen').classList.remove('hidden');
            document.getElementById('titleScreen').classList.add('hidden');
            break;
        case 'room':
            document.getElementById('roomScreen').classList.remove('hidden');
            document.getElementById('lobbyScreen').classList.add('hidden');
            document.getElementById('titleScreen').classList.add('hidden');
            break;
        case 'config':
            document.getElementById('configScreen').classList.remove('hidden');
            break;
        case 'spawn':
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('spawnBanner').classList.remove('hidden');
            break;
        case 'game':
            document.getElementById('spawnPopup').style.display = 'none';
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('spawnBanner').classList.add('hidden');
            document.getElementById('gameHud').style.display = 'block';
            document.getElementById('minimap').style.display = 'block';
            document.getElementById('uiZoomControl').style.display = 'block';
            document.getElementById('eventLog').style.display = 'block';
            document.getElementById('sporeCounter').style.display = 'block';
            document.getElementById('evoPanel').style.display = 'block';
            document.getElementById('scoreBoard').style.display = 'block';
            document.getElementById('volumeControl').style.display = 'flex';
            initPanels();
            break;
        case 'paused':
            document.getElementById('gameCanvas').style.display = 'block';
            document.getElementById('gameHud').style.display = 'block';
            document.getElementById('pauseTitle').textContent = 'PAUSE';
            document.getElementById('pauseOverlay').classList.add('active');
            break;
    }
}

function togglePause() {
    if (gameState.isMulti) {
        if (gameState.phase === 'game') {
            document.getElementById('pauseTitle').textContent = 'MENU';
            document.getElementById('pauseOverlay').classList.add('active');
        } else {
            document.getElementById('pauseOverlay').classList.remove('active');
        }
        return;
    }
    if (gameState.phase === 'game') {
        gameState.phase = 'paused';
        setPhase('paused');
    } else if (gameState.phase === 'paused') {
        gameState.phase = 'game';
        setPhase('game');
    }
}

let _leftRoom = null;

function startGame() {
    _leftRoom = null;
    // Afficher le loading
    document.getElementById('loadingScreen').classList.remove('hidden');
    updateLoadingBar(0, 'G√©n√©ration de l\'espace...');

    // Lire la config (solo seulement, en multi c'est d√©j√† d√©fini par onMultiGameStart)
    if (!gameState.isMulti) {
        gameState.config.difficulty = document.getElementById('cfgDifficulty').value;
        gameState.config.useIA = document.getElementById('cfgIA').value === 'on';
        gameState.config.cleanerCount = parseInt(document.getElementById('cfgCleaners').value);
        gameState.config.useAsteroids = document.getElementById('cfgAsteroids').value === 'on';
    }

    // G√©n√©rer l'univers avec progression
    setTimeout(() => {
        updateLoadingBar(15, 'N√©buleuses et √©toiles...');
        generateBackground();
        generateForegroundDebris();

        setTimeout(() => {
            updateLoadingBar(35, 'Syst√®mes solaires...');
            generateUniverse();

            setTimeout(() => {
                updateLoadingBar(55, 'Textures des soleils...');
                gameState.suns.forEach(s => createSunTexture(s));

                setTimeout(() => {
                    updateLoadingBar(70, 'Textures des plan√®tes...');
                    gameState.planets.forEach(p => createPlanetTexture(p));

                    setTimeout(() => {
                        updateLoadingBar(85, 'Textures des lunes...');
                        gameState.moons.forEach(m => createMoonTexture(m));

                        setTimeout(() => {
                            updateLoadingBar(92, 'Caches performances...');
                            buildSunHaloCache();
                            setTimeout(() => {
                                updateLoadingBar(100, 'Pr√™t !');
                                setTimeout(() => {
                                    document.getElementById('loadingScreen').classList.add('hidden');
                                    finishStartGame();
                                }, 300);
                            }, 50);
                        }, 50);
                    }, 50);
                }, 50);
            }, 50);
        }, 50);
    }, 50);
}

function finishStartGame() {

    // Reset stats
    gameState.gameStats = {
        jetsLaunched: 0, jetsNeutralized: 0,
        bodiesConquered: 0, sporesProduced: 0, timeElapsed: 0
    };
    gameState.jets = [];
    gameState.conquestEffects = [];
    gameState.bloomEffects = [];
    gameState.impactEffects = [];
    gameState.comets = [];
    gameState.cometTimer = 0;
    gameState.time = 0;
    _lastScoreHash = '';
    const _logBody = document.querySelector('#eventLog .log-body');
    if (_logBody) _logBody.innerHTML = '';
    _gameRng = mulberry32((gameState.multiSeed || 42) + 5555);

    // Cr√©er les joueurs
    createPlayers();

    // Calculer le rayon max de l'univers
    let maxR = 0;
    for (const p of gameState.planets) {
        const d = Math.sqrt(p.x*p.x + p.y*p.y) + p.radius;
        if (d > maxR) maxR = d;
    }
    for (const m of gameState.moons) {
        const d = Math.sqrt(m.x*m.x + m.y*m.y) + m.radius;
        if (d > maxR) maxR = d;
    }
    gameState.universeRadius = maxR + 200;
    rebuildAllBodies();
    // Ajuster le d√©zoom min pour voir tout l'univers
    const screenMin = Math.min(gameState.width, gameState.height);
    gameState.camera.minZoom = Math.max(0.02, screenMin / (gameState.universeRadius * 2.2));

    // Centrer la cam√©ra et zoom adapt√©
    gameState.camera.x = 0;
    gameState.camera.y = 0;
    gameState.camera.zoom = 0.3;

    // Lancer la boucle si pas encore active
    if (!gameState.running) {
        gameState.running = true;
        gameState.lastTime = performance.now();
        gameState.fpsLastCheck = performance.now();
        requestAnimationFrame(gameLoop);
    }

    // Audio
    ensureAudio();
    startAmbiance();

    // Phase spawn
    setPhase('spawn');
    if (gameState.isMulti) startSpawnCountdown();
}

let spawnCountdownInterval = null;

function startSpawnCountdown() {
    let remaining = 10;
    const banner = document.getElementById('spawnBanner');
    if (banner) banner.textContent = 'CHOISISSEZ VOTRE PLAN√àTE ‚Äî ' + remaining + 's';
    spawnCountdownInterval = setInterval(() => {
        remaining--;
        if (banner) banner.textContent = 'CHOISISSEZ VOTRE PLAN√àTE ‚Äî ' + remaining + 's';
        if (remaining <= 0) {
            clearInterval(spawnCountdownInterval);
            spawnCountdownInterval = null;
            finishMultiSpawn();
        }
    }, 1000);
}

function finishMultiSpawn() {
    const slot = localSlot();
    const human = gameState.players[slot];
    // Seed d√©terministe pour le spawn auto (identique sur tous les clients)
    const spawnRng = mulberry32((gameState.multiSeed || 42) + 9999);
    // Si le joueur n'a pas choisi, placer au hasard
    if (!human.spawnPlanet) {
        const free = gameState.planets.filter(p => p.owner === null);
        if (free.length > 0) {
            const pick = free[Math.floor(spawnRng() * free.length)];
            pick.owner = slot;
            pick.spores = pick.maxSpores * 0.5;
            human.bodies = [pick];
            human.spawnPlanet = pick;
            sendAction('spawn', { bodyName: pick.name });
        }
    }
    // Placer les joueurs distants non spawn (d√©terministe)
    for (const player of gameState.players) {
        if (!player.spawnPlanet) {
            const free = gameState.planets.filter(p => p.owner === null);
            if (free.length > 0) {
                const pick = free[Math.floor(spawnRng() * free.length)];
                pick.owner = player.id;
                pick.spores = pick.maxSpores * 0.5;
                player.bodies = [pick];
                player.spawnPlanet = pick;
            }
        }
    }
    setPhase('game');
}

function createPlayers() {
    gameState.players = [];
    const colors = [...gameState.teamColors];

    if (gameState.isMulti && currentRoom) {
        // Mode multi : cr√©er les joueurs depuis les slots de la room
        const roomPlayers = gameState._roomPlayers || [];
        for (let i = 0; i < roomPlayers.length; i++) {
            const rp = roomPlayers[i];
            const isMe = (rp.slot_number === mySlot);
            gameState.players.push({
                id: rp.slot_number,
                name: rp.pseudo,
                color: rp.color,
                isHuman: true,
                isLocal: isMe,
                stats: isMe ? { ...gameState.playerStats } : (rp.stats || { growth: 3, velocity: 4, density: 3 }),
                bodies: [],
                totalSpores: 0,
                alive: true,
                spawnPlanet: null,
                multiTier: 0,
                multiProgress: 0,
                multiSacrifice: 0,
                nidification: {},
                tech: { homing:0, tenacity:0, mimicry:0, _branchOrder:[] }
            });
        }
        // Ajouter les IAs multi (si aiCount > 0 dans les settings)
        const s = currentRoom.settings || {};
        const aiCount = s.aiCount || 0;
        if (aiCount > 0 && s.useIA) {
            const usedColors = roomPlayers.map(rp => rp.color);
            const aiColors = colors.filter(c => !usedColors.includes(c));
            const aiRng = mulberry32((gameState.multiSeed || 42) + 7777);
            for (let a = 0; a < aiCount; a++) {
                const aiId = roomPlayers.length + a;
                const aiColor = aiColors[a % aiColors.length] || colors[a % colors.length];
                const s1 = Math.floor(aiRng() * 5) + 1;
                const s2 = Math.floor(aiRng() * (10 - s1)) + 1;
                const s3 = 10 - s1 - s2;
                gameState.players.push({
                    id: aiId,
                    name: 'IA-' + (a + 1),
                    color: aiColor,
                    isHuman: false,
                    stats: { growth: s1, velocity: s2, density: s3 },
                    bodies: [],
                    totalSpores: 0,
                    alive: true,
                    spawnPlanet: null,
                    aiTimer: 0,
                    aiCooldown: gameState.config.difficulty === 'easy' ? 3 : gameState.config.difficulty === 'normal' ? 1.5 : 0.5,
                    multiTier: 0,
                    multiProgress: 0,
                    multiSacrifice: 0,
                    nidification: {},
                    tech: { homing:0, tenacity:0, mimicry:0, _branchOrder:[] }
                });
            }
        }
        return;
    }

    // Mode solo
    gameState.players.push({
        id: 0,
        name: (currentProfile && currentProfile.pseudo) ? currentProfile.pseudo : 'Commandant',
        color: gameState.playerColor,
        isHuman: true,
        isLocal: true,
        stats: { ...gameState.playerStats },
        bodies: [],
        totalSpores: 0,
        alive: true,
        spawnPlanet: null,
        multiTier: 0,
        multiProgress: 0,
        multiSacrifice: 0,
        nidification: {},
        tech: { homing:0, tenacity:0, mimicry:0, _branchOrder:[] }
    });

    const usedIdx = colors.indexOf(gameState.playerColor);
    if (usedIdx >= 0) colors.splice(usedIdx, 1);

    for (let i = 1; i < gameState.config.playerCount; i++) {
        const aiColor = colors[(i - 1) % colors.length];
        // Stats al√©atoires pour les IAs (total = 10)
        const s1 = Math.floor(gameRandom() * 5) + 1;
        const s2 = Math.floor(gameRandom() * (10 - s1)) + 1;
        const s3 = 10 - s1 - s2;
        gameState.players.push({
            id: i,
            name: 'IA-' + i,
            color: aiColor,
            isHuman: false,
            stats: { growth: s1, velocity: s2, density: s3 },
            bodies: [],
            totalSpores: 0,
            alive: true,
            spawnPlanet: null,
            aiTimer: 0,
            aiCooldown: gameState.config.difficulty === 'easy' ? 3 : gameState.config.difficulty === 'normal' ? 1.5 : 0.5,
            multiTier: 0,
            multiProgress: 0,
            multiSacrifice: 0,
            nidification: {},
            tech: { homing:0, tenacity:0, mimicry:0, _branchOrder:[] }
        });
    }
}// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MULTIPLICIT√â ‚Äî Fonctions
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function getMultiTierCost(currentTier) {
    return Math.floor(500 * Math.pow(1.8, currentTier));
}

function aiChooseMultiStat(player) {
    // IA : boost le stat le plus faible
    const s = player.stats;
    const min = Math.min(s.growth, s.velocity, s.density);
    if (s.growth === min) s.growth++;
    else if (s.density === min) s.density++;
    else s.velocity++;
    player.multiTier++;
}

function applyMultiChoice(player, stat) {
    player.stats[stat]++;
    player.multiTier++;
    player._multiPending = false;
    if (player === gameState.players[localSlot()]) {
        addEvent('build', '‚ú¶', `Multiplicit√© palier ${player.multiTier} ‚Äî ${stat} +1`, null, player.color);
    }
}

function updateMultiPanel() {
    const panel = document.getElementById('evoPanel');
    if (!panel || gameState.phase !== 'game') return;

    const human = gameState.players[localSlot()];
    if (!human || !human.alive) return;

    // Pips
    const pipsEl = document.getElementById('evoTierPips');
    let pipsHtml = '';
    for (let i = 0; i < 10; i++) {
        const filled = i < human.multiTier ? 'filled' : '';
        const current = i === human.multiTier && human.multiTier < 10 ? 'current' : '';
        const label = i < human.multiTier ? (i + 1) : '';
        pipsHtml += `<div class="tier-pip ${filled} ${current}">${label}</div>`;
    }
    pipsEl.innerHTML = pipsHtml;

    // Barre de progression
    const cost = getMultiTierCost(human.multiTier);
    const pct = human.multiTier >= 10 ? 100 : Math.min(100, (human.multiProgress / cost) * 100);
    document.getElementById('evoBar').style.width = pct + '%';

    // Info
    const info = human.multiTier >= 10
        ? '√âVOLUTION MAXIMALE'
        : `Palier ${human.multiTier}/10 ‚Äî ${Math.floor(human.multiProgress)} / ${cost} spores`;
    document.getElementById('evoInfo').textContent = info;

    // Slider
    document.getElementById('evoSacVal').textContent = human.multiSacrifice + '%';

    // Choix de stat en attente ?
    const chooseEl = document.getElementById('evoChoose');
    if (human._multiPending) {
        chooseEl.style.display = 'block';
        document.getElementById('evoGrowthCur').textContent = `(${human.stats.growth})`;
        document.getElementById('evoVelocityCur').textContent = `(${human.stats.velocity})`;
        document.getElementById('evoDensityCur').textContent = `(${human.stats.density})`;
    } else {
        chooseEl.style.display = 'none';
    }

    // Mise √† jour panneau stats + effets
    const s = human.stats;
    const base = gameState.playerStats || { growth: 3, velocity: 4, density: 3 };
    document.getElementById('evoStatGrowth').textContent = s.growth;
    document.getElementById('evoStatVelocity').textContent = s.velocity;
    document.getElementById('evoStatDensity').textContent = s.density;
    const gB = s.growth - base.growth;
    const vB = s.velocity - base.velocity;
    const dB = s.density - base.density;
    document.getElementById('evoStatGrowthBonus').textContent = gB > 0 ? `+${gB}` : '';
    document.getElementById('evoStatVelocityBonus').textContent = vB > 0 ? `+${vB}` : '';
    document.getElementById('evoStatDensityBonus').textContent = dB > 0 ? `+${dB}` : '';
    // Effets concrets
    const velSpeed = 20 + s.velocity * 6;
    const densPct = Math.round(s.density * 5);
    document.getElementById('evoStatGrowthFx').textContent = `√ó${(1 + s.growth * 0.3).toFixed(1)} prod`;
    document.getElementById('evoStatVelocityFx').textContent = `${velSpeed} vitesse`;
    document.getElementById('evoStatDensityFx').textContent = `+${densPct}% impact`;
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ARBRE TECHNOLOGIQUE ‚Äî Spores
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TECH_BRANCHES = {
    homing: { icon:'üéØ', name:'T√™te chercheuse', levels:['Instinct','Attraction','Magn√©tisme','Radar','Sonar spatial','Traque','Poursuite','Pr√©dation','Guidage total','≈íil omniscient'] },
    tenacity: { icon:'üí™', name:'T√©nacit√©', levels:['R√©sistance','Endurance','Persistance','R√©silience','Insubmersible','R√©g√©n√©ration','Duplication','Essaim','Prolif√©ration','Hydre cosmique'] },
    mimicry: { icon:'ü¶é', name:'Mim√©tisme', levels:['√âcho','R√©sonance','Fragmentation','Propagation','Ramification','Cascade','Nu√©e','Pand√©mie','Assimilation','Fl√©au lunaire'] }
};
function getTechCost(player, branch) {
    const tech = player.tech; const lvl = tech[branch];
    if (lvl >= 10) return Infinity;
    let order = tech._branchOrder.indexOf(branch);
    if (order === -1) order = tech._branchOrder.length;
    const baseCost = [1000,2000,3000][Math.min(order,2)];
    const increment = [100,200,300][Math.min(order,2)];
    return baseCost + lvl * increment;
}
function buyTech(player, branch) {
    const cost = getTechCost(player, branch);
    if (player.totalSpores < cost || player.tech[branch] >= 10) return false;
    let toDeduct = cost;
    const bodies = player.bodies.slice().sort((a,b) => b.spores - a.spores);
    for (const body of bodies) { const take = Math.min(body.spores, toDeduct); body.spores -= take; toDeduct -= take; if (toDeduct <= 0) break; }
    if (toDeduct > 0) return false;
    if (player.tech[branch] === 0 && !player.tech._branchOrder.includes(branch)) player.tech._branchOrder.push(branch);
    player.tech[branch]++;
    const info = TECH_BRANCHES[branch];
    addEvent('build', info.icon, `${info.name} niv.${player.tech[branch]} ‚Äî ${info.levels[player.tech[branch]-1]}`, null, player.color);
    return true;
}
function updateTechPanel() {
    const slot = localSlot(); const player = gameState.players?.[slot];
    if (!player) return;
    for (const branch of ['homing','tenacity','mimicry']) {
        const lvl = player.tech[branch]; const info = TECH_BRANCHES[branch];
        const cap = branch.charAt(0).toUpperCase() + branch.slice(1);
        const pipsEl = document.getElementById('tech'+cap+'Pips');
        if (pipsEl && pipsEl.children.length === 0) { for (let i=0;i<10;i++) { const p=document.createElement('div'); p.className='tech-pip'; pipsEl.appendChild(p); } }
        if (pipsEl) { for (let i=0;i<10;i++) pipsEl.children[i].className = 'tech-pip' + (i<lvl?' filled':''); }
        const lvlEl = document.getElementById('tech'+cap+'Lvl');
        if (lvlEl) lvlEl.textContent = lvl+'/10';
        const nameEl = document.getElementById('tech'+cap+'Name');
        if (nameEl) nameEl.textContent = lvl > 0 ? info.levels[lvl-1] : '‚Äî';
        const buyEl = document.getElementById('tech'+cap+'Buy');
        if (buyEl) { if (lvl>=10) { buyEl.disabled=true; buyEl.innerHTML='‚ú¶ MAX ‚ú¶'; } else { const cost=getTechCost(player,branch); buyEl.disabled=player.totalSpores<cost; buyEl.innerHTML='Niv.'+(lvl+1)+' ‚Üí '+info.levels[lvl]+' <span class="tech-cost">('+cost+')</span>'; } }
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// JETS DE SPORES ‚Äî Physique
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// CODEX ‚Äî Panneau lat√©ral
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function openCodex(body) {
    gameState.selectedBody = body;
    gameState.codexOpen = true;
    document.getElementById('codexName').textContent = body.name;

    // Aper√ßu texture
    const previewEl = document.getElementById('codexPreview');
    previewEl.innerHTML = '';
    if (body._texture) {
        const preview = document.createElement('canvas');
        const size = 80;
        preview.width = size;
        preview.height = size;
        preview.style.cssText = 'border-radius:50%;border:2px solid rgba(100,70,180,0.3);';
        const pctx = preview.getContext('2d');
        pctx.drawImage(body._texture, 0, 0, size, size);
        previewEl.appendChild(preview);
    }

    document.getElementById('codexType').textContent = body.type === 'sun' ? 'Soleil' : body.type === 'planet' ? 'Plan√®te' : 'Lune';
    document.getElementById('codexRadius').textContent = Math.round(body.radius);
    document.getElementById('codexFlore').textContent = body.flore !== undefined ? body.flore : '‚Äî';
    document.getElementById('codexFaune').textContent = body.faune !== undefined ? body.faune : '‚Äî';
    const owner = body.owner !== null && body.owner !== undefined
        ? gameState.players[body.owner]?.name || 'Inconnu'
        : 'Neutre';
    document.getElementById('codexOwner').textContent = owner;
    document.getElementById('codexSpores').textContent = body.spores !== undefined ? Math.floor(body.spores) : '‚Äî';

    // Symbiose
    const symEl = document.getElementById('codexSymbiose');
    if (body.owner !== null && body.symbiosis !== undefined) {
        symEl.style.display = 'block';
        const pct = Math.floor(body.symbiosis);
        document.getElementById('codexSymVal').textContent = pct + '%';
        document.getElementById('codexSymBar').style.width = pct + '%';
        const bonusMax = body.type === 'planet' ? 20 : 10;
        const bonusCurrent = (pct / 100 * bonusMax).toFixed(1);
        document.getElementById('codexSymBonus').textContent = '+' + bonusCurrent + '% production';
    } else {
        symEl.style.display = 'none';
    }

    // Nids & Biomes
    const buildEl = document.getElementById('codexBuild');
    if (body.owner === 0 && body.type !== 'sun') {
        buildEl.style.display = 'block';
        // S√©lectionner le bon radio
        document.querySelectorAll('input[name="buildMode"]').forEach(r => {
            r.checked = (r.value === (body.buildMode || 'off'));
        });
        updateCodexBuild(body);
    } else if (body.owner !== null && body.type !== 'sun') {
        // Afficher en lecture seule pour les autres joueurs
        buildEl.style.display = 'block';
        document.querySelectorAll('input[name="buildMode"]').forEach(r => {
            r.checked = (r.value === (body.buildMode || 'off'));
            r.disabled = true;
        });
        updateCodexBuild(body);
    } else {
        buildEl.style.display = 'none';
    }

    document.getElementById('codex').classList.add('open');
}

function updateCodexBuild(body) {
    const countEl = document.getElementById('codexBuildCount');
    const infoEl = document.getElementById('codexBuildInfo');
    const barEl = document.getElementById('codexBuildBar');

    const nids = body.nids || 0;
    const biomes = body.biomes || 0;
    const nidBonus = (nids * 0.2).toFixed(1);
    const biomeBonus = (biomes * 0.2).toFixed(1);

    let countText = '';
    if (nids > 0) countText += `ü™∫ ${nids} nid${nids>1?'s':''} (+${nidBonus}% prod)`;
    if (biomes > 0) countText += `${nids>0?' | ':''}üõ° ${biomes} biome${biomes>1?'s':''} (+${biomeBonus}% d√©f)`;
    if (!countText) countText = 'Aucune construction';
    countEl.textContent = countText;

    if (body.buildMode === 'nid' || body.buildMode === 'biome') {
        const pct = Math.floor((body.buildProgress / body.maxSpores) * 100);
        infoEl.textContent = `Max spores: ${Math.floor(body.maxSpores / 3)} | Co√ªt: ${body.maxSpores} | Progression: ${pct}%`;
        barEl.style.width = pct + '%';
        barEl.className = 'build-progress ' + body.buildMode;
    } else {
        infoEl.textContent = `Max spores: ${body.maxSpores}`;
        barEl.style.width = '0%';
    }
}

function closeCodex() {
    gameState.codexOpen = false;
    gameState.selectedBody = null;
    document.getElementById('codex').classList.remove('open');
    // R√©activer les radios
    document.querySelectorAll('input[name="buildMode"]').forEach(r => r.disabled = false);
}

// Listener changement mode nid/biome
document.querySelectorAll('input[name="buildMode"]').forEach(radio => {
    radio.addEventListener('change', (e) => {
        const body = gameState.selectedBody;
        if (!body || body.owner !== 0) return;
        body.buildMode = e.target.value;
        if (body.buildMode === 'off') body.buildProgress = 0;
        updateCodexBuild(body);
    });
});


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// HUD ‚Äî Mise √† jour
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateHUD() {
    if (gameState.phase !== 'game') return;

    // Recalculer totalSpores pour chaque joueur
    for (const player of gameState.players) {
        let total = 0;
        for (const body of player.bodies) {
            total += body.spores;
        }
        player.totalSpores = total;
    }

    // Compteur spores joueur humain
    const human = gameState.players[localSlot()];
    if (human && DOM.sporeCount) {
        DOM.sporeCount.textContent = Math.floor(human.totalSpores);
    }

    // Tableau des scores
    updateScoreBoard();

    // Timer
    updateGameTimer();

    // Minimap (throttle toutes les 15 frames)
    if (gameState._hudCounter % 15 === 0) drawMinimap();

    // Codex si ouvert
    if (gameState.codexOpen && gameState.selectedBody) {
        openCodex(gameState.selectedBody);
    }
}

let _lastScoreHash = '';
function updateScoreBoard() {
    const board = DOM.scoreBoard;
    if (!board) return;
    const totalBodies = gameState.planets.length + gameState.moons.length;

    // Calculer un hash rapide pour √©viter innerHTML inutile
    let hash = '';
    let html = '';
    for (const player of gameState.players) {
        if (!player.alive) continue;
        const owned = player.bodies ? player.bodies.length : 0;
        const pct = totalBodies > 0 ? Math.round((owned / totalBodies) * 100) : 0;
        hash += player.id + ':' + pct + ',';
        html += `<div class="score-row">
            <div class="score-color" style="background:${player.color}"></div>
            <span class="score-name">${player.name}</span>
            <div class="score-bar-bg"><div class="score-bar" style="width:${pct}%;background:${player.color}"></div></div>
            <span class="score-pct">${pct}%</span>
        </div>`;
    }

    if (hash !== _lastScoreHash) {
        _lastScoreHash = hash;
        const handle = board.querySelector('.panel-drag-handle');
        board.innerHTML = html;
        if (handle) board.insertBefore(handle, board.firstChild);
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SPAWN ‚Äî S√©lection de plan√®te de d√©part
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _spawnTarget = null;

function handleSpawnClick(worldX, worldY) {
    let closest = null;
    let closestDist = Infinity;
    for (const p of gameState.planets) {
        if (p.owner !== null) continue;
        const dx = p.x - worldX;
        const dy = p.y - worldY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < Math.max(p.radius + 14, 20) && dist < closestDist) {
            closest = p;
            closestDist = dist;
        }
    }
    if (!closest) return;

    const slot = localSlot();
    const human = gameState.players[slot];
    if (human.spawnPlanet) return;

    // Centrer la cam√©ra sur la plan√®te
    gameState.camera.x = closest.x;
    gameState.camera.y = closest.y;
    gameState.camera.zoom = Math.max(gameState.camera.zoom, 1.2);

    // Afficher la popup d'info
    _spawnTarget = closest;
    const popup = document.getElementById('spawnPopup');
    popup.style.display = 'block';
    document.getElementById('spawnPopupName').textContent = closest.name;
    document.getElementById('spawnPopupFlore').textContent = closest.flore;
    document.getElementById('spawnPopupFaune').textContent = closest.faune;
    document.getElementById('spawnPopupRadius').textContent = Math.floor(closest.radius);
    document.getElementById('spawnPopupMax').textContent = closest.maxSpores;

    // Image preview
    const previewEl = document.getElementById('spawnPopupPreview');
    previewEl.innerHTML = '';
    if (closest._texture) {
        const cvs = document.createElement('canvas');
        cvs.width = 64; cvs.height = 64;
        cvs.getContext('2d').drawImage(closest._texture, 0, 0, 64, 64);
        cvs.style.borderRadius = '50%';
        previewEl.appendChild(cvs);
    }
}

function confirmSpawn() {
    if (!_spawnTarget) return;
    const slot = localSlot();
    const human = gameState.players[slot];
    if (human.spawnPlanet) return;
    if (_spawnTarget.owner !== null) { _spawnTarget = null; document.getElementById('spawnPopup').style.display = 'none'; return; }

    _spawnTarget.owner = slot;
    _spawnTarget.spores = _spawnTarget.maxSpores * 0.5;
    human.bodies = [_spawnTarget];
    human.spawnPlanet = _spawnTarget;
    document.getElementById('spawnPopup').style.display = 'none';

    if (gameState.isMulti) {
        sendAction('spawn', { bodyName: _spawnTarget.name });
        _spawnTarget = null;
        return;
    }
    _spawnTarget = null;
    autoSpawnAIs();
    setPhase('game');
}

function autoSpawnAIs() {
    const available = gameState.planets.filter(p => p.owner === null);
    for (let i = 1; i < gameState.players.length; i++) {
        if (available.length === 0) break;
        // Choisir une plan√®te √©loign√©e des autres joueurs
        let bestPlanet = null;
        let bestScore = -1;
        for (const p of available) {
            let minDist = Infinity;
            for (const other of gameState.players) {
                if (other.id >= i || !other.spawnPlanet) continue;
                const dx = p.x - other.spawnPlanet.x;
                const dy = p.y - other.spawnPlanet.y;
                minDist = Math.min(minDist, Math.sqrt(dx*dx + dy*dy));
            }
            const score = minDist + p.flore * 2;
            if (score > bestScore) {
                bestScore = score;
                bestPlanet = p;
            }
        }
        if (bestPlanet) {
            bestPlanet.owner = i;
            bestPlanet.spores = bestPlanet.maxSpores * 0.5;
            gameState.players[i].bodies = [bestPlanet];
            gameState.players[i].spawnPlanet = bestPlanet;
            available.splice(available.indexOf(bestPlanet), 1);
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// EFFETS COSMIQUES ‚Äî Particules & √©toiles filantes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateCosmicEffects(dt) {
    const t = gameState.time;

    // Particules ambiantes
    for (const p of gameState.cosmicDust) {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        // L√©g√®re oscillation
        p.x += Math.sin(t * 0.5 + p.phase) * 0.3 * dt;
        p.y += Math.cos(t * 0.4 + p.phase) * 0.3 * dt;
    }

    // √âtoiles filantes
    gameState.shootingStarTimer -= dt;
    if (gameState.shootingStarTimer <= 0) {
        gameState.shootingStarTimer = 0.5 + Math.random() * 1.0;
        // Spawner dans la zone visible √©largie
        const cam = gameState.camera;
        const range = 5000 / cam.zoom;
        const angle = -0.8 + Math.random() * 0.4;
        const speed = 800 + Math.random() * 1200;
        gameState.shootingStars.push({
            x: cam.x + (Math.random() - 0.5) * range,
            y: cam.y - range * 0.4 + Math.random() * range * 0.2,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.8 + Math.random() * 1.5,
            age: 0,
            length: 60 + Math.random() * 120,
            brightness: 0.5 + Math.random() * 0.5
        });
    }

    for (let i = gameState.shootingStars.length - 1; i >= 0; i--) {
        const s = gameState.shootingStars[i];
        s.age += dt;
        s.x += s.vx * dt;
        s.y += s.vy * dt;
        if (s.age >= s.life) gameState.shootingStars.splice(i, 1);
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// COM√àTES DESTRUCTRICES
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateComets(dt) {
    gameState.cometTimer -= dt;
    if (gameState.cometTimer <= 0) {
        gameState.cometTimer = COMET_CFG.freq * (0.7 + gameRandom() * 0.6);
        const cam = gameState.camera;
        const range = (gameState.universeRadius || 6000) * 2;
        const angle = Math.random() * Math.PI * 2;
        const startDist = range * 0.8;
        const cx = Math.cos(angle) * startDist;
        const cy = Math.sin(angle) * startDist;
        // Viser un point al√©atoire dans l'univers
        const targetAngle = angle + Math.PI + (Math.random() - 0.5) * 1.2;
        const spd = COMET_CFG.speed + gameRandom() * COMET_CFG.speed * 0.5;
        gameState.comets.push({
            x: cx, y: cy,
            vx: Math.cos(targetAngle) * spd,
            vy: Math.sin(targetAngle) * spd,
            size: COMET_CFG.size * (0.6 + gameRandom() * 0.8),
            tail: COMET_CFG.tail * (0.7 + gameRandom() * 0.6),
            life: range * 2 / spd,
            age: 0,
            color: ['#88DDFF','#AAEEFF','#FFCC66','#FF9966'][Math.floor(Math.random()*4)]
        });
    }

    for (let i = gameState.comets.length - 1; i >= 0; i--) {
        const c = gameState.comets[i];
        c.age += dt;
        c.x += c.vx * dt;
        c.y += c.vy * dt;

        if (c.age >= c.life) { gameState.comets.splice(i, 1); continue; }

        // Collision avec plan√®tes et lunes ‚Üí d√©truire les spores
        const bodies = gameState.allBodies;
        for (const body of bodies) {
            const dx = body.x - c.x;
            const dy = body.y - c.y;
            if (Math.sqrt(dx*dx + dy*dy) < body.radius + c.size) {
                if (!body.invincible) body.spores = 0;
                spawnImpact(c.x, c.y, c.color);
                gameState.comets.splice(i, 1);
                break;
            }
        }
    }
}

function drawComets(ctx) {
    for (const c of gameState.comets) {
        const spd = Math.sqrt(c.vx*c.vx + c.vy*c.vy);
        const dx = -c.vx / spd;
        const dy = -c.vy / spd;

        // Tra√Æne
        const g = ctx.createLinearGradient(c.x, c.y, c.x + dx * c.tail, c.y + dy * c.tail);
        g.addColorStop(0, c.color);
        g.addColorStop(0.3, c.color + '80');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.strokeStyle = g;
        ctx.lineWidth = c.size * 0.6;
        ctx.beginPath();
        ctx.moveTo(c.x, c.y);
        ctx.lineTo(c.x + dx * c.tail, c.y + dy * c.tail);
        ctx.stroke();

        // T√™te
        ctx.fillStyle = c.color;
        ctx.shadowColor = c.color;
        ctx.shadowBlur = c.size * 2;
        ctx.beginPath();
        ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// D√âBRIS PREMIER PLAN
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function generateForegroundDebris() {
    gameState.foregroundDebris = [];
    const count = COMET_CFG.fgDebris;
    for (let i = 0; i < count; i++) {
        gameState.foregroundDebris.push({
            offX: (Math.random() - 0.5) * 2,
            offY: (Math.random() - 0.5) * 2,
            size: 2 + Math.random() * 8,
            speed: 0.3 + Math.random() * 0.7,
            angle: Math.random() * Math.PI * 2,
            rotSpeed: (Math.random() - 0.5) * 2,
            type: ['rock','dust','ice'][Math.floor(Math.random()*3)],
            alpha: 0.15 + Math.random() * 0.25,
            parallax: 1.5 + Math.random() * 1.5
        });
    }
}

function drawForegroundDebris(ctx) {
    const cam = gameState.camera;
    const t = gameState.time;
    const w = gameState.width;
    const h = gameState.height;

    for (const d of gameState.foregroundDebris) {
        // Position relative √† la cam√©ra avec forte parallaxe (premier plan)
        const px = ((d.offX * 5000 - cam.x * d.parallax + t * d.speed * 100) % (w / cam.zoom * 2));
        const py = ((d.offY * 5000 - cam.y * d.parallax + t * d.speed * 50) % (h / cam.zoom * 2));
        // Convertir en screen coords
        const sx = w / 2 + px * cam.zoom;
        const sy = h / 2 + py * cam.zoom;

        ctx.save();
        ctx.translate(sx, sy);
        ctx.rotate(t * d.rotSpeed);
        ctx.globalAlpha = d.alpha;

        if (d.type === 'rock') {
            ctx.fillStyle = '#665544';
            ctx.beginPath();
            const s = d.size * cam.zoom * 0.5;
            ctx.moveTo(-s, -s*0.6);
            ctx.lineTo(s*0.8, -s);
            ctx.lineTo(s, s*0.5);
            ctx.lineTo(-s*0.3, s);
            ctx.closePath();
            ctx.fill();
        } else if (d.type === 'dust') {
            ctx.fillStyle = 'rgba(180,160,200,0.5)';
            const s = d.size * cam.zoom * 0.4;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.fillStyle = 'rgba(200,230,255,0.6)';
            const s = d.size * cam.zoom * 0.3;
            ctx.beginPath();
            ctx.arc(0, 0, s, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(s*0.3, -s*0.3, s*0.4, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.restore();
    }
}

function drawCosmicEffects(ctx) {
    const t = gameState.time;
    const z = gameState.camera.zoom;

    // Particules ambiantes
    for (const p of gameState.cosmicDust) {
        const flicker = p.alpha * (0.7 + Math.sin(t * 2 + p.phase) * 0.3);
        ctx.fillStyle = `rgba(180, 200, 240, ${flicker})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
    }

    // √âtoiles filantes
    for (const s of gameState.shootingStars) {
        const progress = s.age / s.life;
        const alpha = s.brightness * (progress < 0.2 ? progress / 0.2 : 1 - (progress - 0.2) / 0.8);
        const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
        const dirX = s.vx / speed;
        const dirY = s.vy / speed;
        const tailX = s.x - dirX * s.length;
        const tailY = s.y - dirY * s.length;

        // Tra√Æne d√©grad√©e
        const g = ctx.createLinearGradient(tailX, tailY, s.x, s.y);
        g.addColorStop(0, 'rgba(0,0,0,0)');
        g.addColorStop(0.7, `rgba(200, 220, 255, ${alpha * 0.3})`);
        g.addColorStop(1, `rgba(255, 255, 255, ${alpha})`);
        ctx.strokeStyle = g;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(tailX, tailY);
        ctx.lineTo(s.x, s.y);
        ctx.stroke();

        // Point lumineux en t√™te
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(s.x, s.y, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// SPORES ‚Äî G√©n√©ration passive
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateSporeGeneration(dt) {
    const bodies = gameState.allBodies;
    for (const body of bodies) {
        // R√©g√©n√©ration de Faune sur astres neutres non conquis
        if (body.owner === null && body._baseFaune !== undefined && body.faune < body._baseFaune) {
            body.faune += 2 * dt; // r√©g√©n√©ration lente
            if (body.faune > body._baseFaune) body.faune = body._baseFaune;
        }

        if (body.owner === null) continue;

        // Mise √† jour symbiose
        body.symOwnerTime += dt;
        const symMaxTime = body.type === 'planet' ? 600 : 300; // 10min plan√®tes, 5min lunes
        body.symbiosis = Math.min(100, (body.symOwnerTime / symMaxTime) * 100);

        if (body.flore <= 0) continue;
        const player = gameState.players[body.owner];
        if (!player) continue;

        // Bonus symbiose : +20% plan√®tes, +10% lunes √† 100%
        const symBonusMax = body.type === 'planet' ? 0.20 : 0.10;
        const symBonus = 1 + (body.symbiosis / 100) * symBonusMax;

        // Bonus nids : +0.2% production locale par nid
        const nidBonus = 1 + (body.nids || 0) * 0.002;

        // Bonus syst√®me complet : +3% si toutes plan√®tes+lunes du soleil au m√™me owner
        let sysBonus = 1;
        const bodySun = body.type === 'planet' ? body.parent : (body.parent.parent || null);
        if (bodySun && isSystemComplete(bodySun, body.owner)) sysBonus = 1.03;

        const rate = (body.flore / 100) * (1 + player.stats.growth * 0.3) * 2 * symBonus * nidBonus * sysBonus;

        // Mode construction : production allou√©e au compteur
        if (body.buildMode === 'nid' || body.buildMode === 'biome') {
            // Nidification continue m√™me en construction
            const _nidPct = (player._nidSacrifice || 0) / 100;
            if (_nidPct > 0 && body.parent) {
                const _sunR = body.type === 'planet' ? body.parent : (body.parent.parent || null);
                if (_sunR && player.nidification[_sunR.name]) {
                    const _nid = player.nidification[_sunR.name];
                    if (!_nid.motherPlanet && _nid.progress < 2500) {
                        _nid.progress += rate * _nidPct * dt;
                    }
                }
            }
            body.buildProgress += rate * (1 - _nidPct) * dt;
            // V√©rifier si construction termin√©e
            if (body.buildProgress >= body.maxSpores) {
                body.buildProgress -= body.maxSpores;
                if (body.buildMode === 'nid') {
                    body.nids = (body.nids || 0) + 1;
                    if (body.owner === localSlot()) addEvent('build', 'üèóÔ∏è', `Nid construit sur ${body.name} (${body.nids})`, body, gameState.players[localSlot()]?.color);
                } else {
                    body.biomes = (body.biomes || 0) + 1;
                    if (body.owner === localSlot()) addEvent('build', 'üõ°Ô∏è', `Biome construit sur ${body.name} (${body.biomes})`, body, gameState.players[localSlot()]?.color);
                }
            }
            // Max spores r√©duit √† 1/3
            const reducedMax = Math.floor(body.maxSpores / 3);
            if (body.spores > reducedMax) {
                body.spores -= (body.spores - reducedMax) * 0.5 * dt;
            }
        } else {
            // R√©partir la production entre : jeu, multiplicit√©, nidification
            const multiPct = (player.multiSacrifice || 0) / 100;
            const nidRawPct = (player._nidSacrifice || 0) / 100;
            // Plafonner le total √† 80% max
            const totalSac = Math.min(multiPct + nidRawPct, 0.8);
            const multiSac = totalSac > 0 ? multiPct / (multiPct + nidRawPct) * totalSac : 0;
            const nidSac = totalSac > 0 ? nidRawPct / (multiPct + nidRawPct) * totalSac : 0;
            const prodPct = 1 - totalSac;

            const produced = rate * prodPct * dt;
            body.spores += produced;
            gameState.gameStats.sporesProduced += produced;

            // Accumuler multiplicit√©
            if (multiSac > 0 && player.multiTier < 10) {
                player.multiProgress += rate * multiSac * dt;
                const tierCost = getMultiTierCost(player.multiTier);
                if (player.multiProgress >= tierCost) {
                    player.multiProgress -= tierCost;
                    if (player.isHuman) {
                        player._multiPending = true;
                    } else {
                        aiChooseMultiStat(player);
                    }
                }
            }

            // Accumuler nidification
            if (nidSac > 0 && body.parent) {
                const sunRef = body.type === 'planet' ? body.parent : (body.parent.parent || null);
                if (sunRef && player.nidification[sunRef.name]) {
                    const nid = player.nidification[sunRef.name];
                    if (!nid.motherPlanet && nid.progress < 2500) {
                        nid.progress += rate * nidSac * dt;
                    }
                }
            }

            // D√©croissance si au-dessus du max
            if (body.spores > body.maxSpores) {
                body.spores -= (body.spores - body.maxSpores) * 0.5 * dt;
            }
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// JETS DE SPORES ‚Äî Physique
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function computeTrajectory(startX, startY, dirX, dirY, speed, steps) {
    const bh = gameState.blackHole;
    const points = [];
    let x = startX, y = startY;
    let vx = dirX * speed, vy = dirY * speed;
    const dt = 0.4;

    for (let i = 0; i < steps; i++) {
        // Gravit√© du trou noir (tr√®s l√©g√®re)
        const dx = bh.x - x;
        const dy = bh.y - y;
        const distSq = dx * dx + dy * dy;
        const dist = Math.sqrt(distSq);

        if (dist < bh.dangerZone * 0.4) break;

        // Gravit√© du trou noir : 1/dist pour courbes visibles
        const gRange = bh.gravityRange || 1500;
        if (dist < gRange) {
            const G = bh.gravityStrength || 500;
            // Falloff progressif vers le bord de port√©e
            const edgeFade = 1 - Math.pow(dist / gRange, 2);
            const gravity = G / (dist + 50) * edgeFade;
            const factor = gravity * dt;
            vx += (dx / dist) * factor;
            vy += (dy / dist) * factor;
        }

        x += vx * dt;
        y += vy * dt;
        points.push({ x, y });
    }
    return points;
}

function launchJet(source, dirX, dirY) {
    const player = gameState.players[source.owner];
    if (!player) return;

    const sporeCount = Math.floor(source.spores * gameState.jetRatio);
    if (sporeCount < 5) return;
    source.spores -= sporeCount;

    const speed = 20 + player.stats.velocity * 6;
    const traj = computeTrajectory(source.x, source.y, dirX, dirY, speed, 400);

    // G√©n√©rer des particules scintillantes autour du jet
    const sparkles = [];
    for (let i = 0; i < 12; i++) {
        sparkles.push({
            offX: 0, offY: 0,
            angle: Math.random() * Math.PI * 2,
            speed: 0.3 + Math.random() * 0.8,
            radius: 1 + Math.random() * 2,
            phase: Math.random() * Math.PI * 2
        });
    }

    gameState.gameStats.jetsLaunched++;
    playLaunchSound();
    gameState.jets.push({
        owner: source.owner,
        color: player.color,
        spores: sporeCount,
        trajectory: traj,
        posIndex: 0,
        x: source.x,
        y: source.y,
        speed: speed,
        alive: true,
        trail: [],
        sparkles: sparkles,
        age: 0,
        selected: false,
        source: source
    });
}

function updateJets(dt) {
    const bh = gameState.blackHole;
    const jets = gameState.jets;

    for (let i = jets.length - 1; i >= 0; i--) {
        const jet = jets[i];
        if (!jet.alive) { jets.splice(i, 1); continue; }

        jet.age += dt;

        // Jets renvoy√©s : guidage vers la cible
        if (jet._targetBody) {
            const tb = jet._targetBody;
            const tdx = tb.x - jet.x;
            const tdy = tb.y - jet.y;
            const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
            jet.trail.push({ x: jet.x, y: jet.y, t: jet.age });
            if (jet.trail.length > 30) jet.trail.shift();
            if (tDist < tb.radius + 8) {
                // Arriv√© sur la cible
                jet.x = tb.x;
                jet.y = tb.y;
            } else {
                const moveSpeed = jet.speed * 0.70 * dt;
                jet.x += (tdx / tDist) * moveSpeed;
                jet.y += (tdy / tDist) * moveSpeed;
            }
        } else {
        // Avancer le long de la trajectoire
        jet.posIndex += jet.speed * dt * 0.70;
        const idx = Math.floor(jet.posIndex);

        if (idx >= jet.trajectory.length - 1) {
            jet.alive = false;
            continue;
        }

        const pt = jet.trajectory[idx];

        // Tra√Æne : stocker les positions pass√©es
        jet.trail.push({ x: jet.x, y: jet.y, t: jet.age });
        if (jet.trail.length > 30) jet.trail.shift();

        jet.x = pt.x;
        jet.y = pt.y;
        }

        // Animer les particules scintillantes
        for (const sp of jet.sparkles) {
            sp.angle += sp.speed * dt * 3;
            sp.offX = Math.cos(sp.angle) * (5 + Math.sin(jet.age * 4 + sp.phase) * 3);
            sp.offY = Math.sin(sp.angle) * (5 + Math.cos(jet.age * 4 + sp.phase) * 3);
        }

        // ‚îÄ‚îÄ T√™te chercheuse ‚îÄ‚îÄ
        const _hp = gameState.players[jet.owner];
        const _hl = _hp?.tech?.homing || 0;
        if (_hl > 0 && !jet._targetBody) {
            const hRange = 80 + _hl * 30;
            const hForce = 0.02 + _hl * 0.01;
            let hBest = null, hDist = hRange;
            for (const b of gameState.allBodies) {
                if (b.owner === jet.owner || b === jet.source) continue;
                const hdx = b.x-jet.x, hdy = b.y-jet.y;
                const hd = Math.sqrt(hdx*hdx+hdy*hdy);
                if (hd < hDist) { hDist = hd; hBest = b; }
            }
            if (hBest) {
                const i2 = Math.floor(jet.posIndex);
                for (let ti=i2; ti<jet.trajectory.length; ti++) {
                    const tp = jet.trajectory[ti];
                    const tx=hBest.x-tp.x, ty=hBest.y-tp.y, td=Math.sqrt(tx*tx+ty*ty);
                    if (td>1) { const f=Math.max(0,1-(ti-i2)/60); tp.x+=tx/td*hForce*f*jet.speed*0.3; tp.y+=ty/td*hForce*f*jet.speed*0.3; }
                }
            }
        }

        // Travers√©e amas de m√©t√©orites
        if (!jet._hitBelt) jet._hitBelt = {};
        for (let bi = 0; bi < gameState.asteroidBelts.length; bi++) {
            if (jet._hitBelt[bi]) continue;
            const belt = gameState.asteroidBelts[bi];
            const sun = belt.sun;
            // V√©rifier proximit√© r√©elle avec un amas (pas juste l'anneau)
            let closestType = null;
            let closestDist = Infinity;
            for (const rock of belt.rocks) {
                const ra = rock.angle;
                const rr = belt.radius + rock.radiusOff;
                const rcx = sun.x + Math.cos(ra) * rr;
                const rcy = sun.y + Math.sin(ra) * rr;
                const rd = (jet.x - rcx) * (jet.x - rcx) + (jet.y - rcy) * (jet.y - rcy);
                if (rd < closestDist) { closestDist = rd; closestType = rock.type; }
            }
            // Seulement si le jet est √† moins de 40px d'un amas r√©el
            if (closestDist > 1600) continue; // 40 * 40
            jet._hitBelt[bi] = true;
            if (closestType === 'dark') {
                // Noir : divise les spores (T√©nacit√© r√©duit la perte)
                const _tl1 = gameState.players[jet.owner]?.tech?.tenacity || 0;
                const _dk = 0.5 + _tl1 * 0.05;
                jet.spores = Math.max(1, Math.floor(jet.spores * _dk));
                spawnImpact(jet.x, jet.y, '#555555');
            } else if (closestType === 'red') {
                // Rouge : d√©vie le jet de 5¬∞ √† 15¬∞
                const devAngle = (5 + gameRandom() * 10) * Math.PI / 180;
                const sign = gameRandom() < 0.5 ? 1 : -1;
                const cosA = Math.cos(devAngle * sign);
                const sinA = Math.sin(devAngle * sign);
                for (let ti = Math.floor(jet.posIndex); ti < jet.trajectory.length; ti++) {
                    const p = jet.trajectory[ti];
                    const relX = p.x - jet.x;
                    const relY = p.y - jet.y;
                    p.x = jet.x + relX * cosA - relY * sinA;
                    p.y = jet.y + relX * sinA + relY * cosA;
                }
                spawnImpact(jet.x, jet.y, '#FF4444');
            } else if (closestType === 'green') {
                // Vert : √©clate en 5 mini-jets (T√©nacit√© am√©liore conservation + direction)
                const _tl2 = gameState.players[jet.owner]?.tech?.tenacity || 0;
                const _kr = (1/5) + _tl2 * (4/5) / 10;
                const sporesEach = Math.max(1, Math.floor(jet.spores * _kr));
                for (let si = 0; si < 5; si++) {
                    let sDirX, sDirY;
                    if (_tl2 > 0) {
                        const _ts = gameState.suns[si % gameState.suns.length];
                        const _tp = _ts.planets[Math.floor(gameRandom()*_ts.planets.length)] || _ts;
                        const _tx=_tp.x-jet.x, _ty=_tp.y-jet.y, _td=Math.sqrt(_tx*_tx+_ty*_ty);
                        const _sc = (1-_tl2*0.08)*Math.PI*0.5;
                        const _sa = Math.atan2(_ty,_tx)+(gameRandom()-0.5)*_sc;
                        sDirX = Math.cos(_sa); sDirY = Math.sin(_sa);
                    } else { const sAngle=gameRandom()*Math.PI*2; sDirX=Math.cos(sAngle); sDirY=Math.sin(sAngle); }
                    const speed = jet.speed * (0.6 + gameRandom() * 0.4);
                    const traj = computeTrajectory(jet.x, jet.y, sDirX, sDirY, speed, 200);
                    gameState.jets.push({
                        owner: jet.owner,
                        color: jet.color,
                        spores: sporesEach,
                        trajectory: traj,
                        posIndex: 0,
                        x: jet.x,
                        y: jet.y,
                        speed: speed,
                        alive: true,
                        trail: [],
                        sparkles: [],
                        age: 0,
                        selected: false,
                        source: jet.source,
                        _hitBelt: Object.assign({}, jet._hitBelt)
                    });
                }
                spawnImpact(jet.x, jet.y, '#44FF44');
                jet.alive = false;
                break;
            }
        }

        // Destruction par trou noir
        const bhDx = bh.x - jet.x;
        const bhDy = bh.y - jet.y;
        if (Math.sqrt(bhDx*bhDx + bhDy*bhDy) < bh.dangerZone * 0.4) {
            spawnImpact(jet.x, jet.y, '#9933FF');
            jet.alive = false;
            continue;
        }

        // Collision avec astres
        checkJetCollision(jet);
    }

    checkJetNeutralization();
}

function checkJetCollision(jet) {
    // Destruction par les soleils
    for (const sun of gameState.suns) {
        const dx = sun.x - jet.x;
        const dy = sun.y - jet.y;
        if (Math.sqrt(dx*dx + dy*dy) < sun.radius + 5) {
            spawnImpact(jet.x, jet.y, sun.color || '#FFE44D');
            jet.alive = false;
            return;
        }
    }

    const bodies = gameState.allBodies;
    for (const body of bodies) {
        if (body === jet.source) continue;
        const dx = body.x - jet.x;
        const dy = body.y - jet.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < body.radius + 8) {
            spawnImpact(jet.x, jet.y, jet.color);
            // Jets renvoy√©s par vaisseau noir : ciblent une plan√®te sp√©cifique
            if (jet.owner === -1) {
                if (body === jet._targetBody || !jet._targetBody) {
                    const oldOwner = body.owner;
                    body.spores -= jet.spores;
                    if (body.spores < 0) {
                        body.spores = Math.abs(body.spores);
                        body.owner = null;
                        body.symOwnerTime = 0;
                        body.symbiosis = 0;
                        if (oldOwner !== null) {
                            const p = gameState.players[oldOwner];
                            if (p) p.bodies = p.bodies.filter(b => b !== body);
                        }
                        gameState.conquestEffects.push({
                            x: body.x, y: body.y - 15, baseX: body.x,
                            text: 'CHASS√â !', color: '#888888', age: 0, maxAge: 2
                        });
                        const bT = body.type === 'planet' ? 'Plan√®te' : 'Lune';
                        const chColor = oldOwner !== null ? (gameState.players[oldOwner]?.color || '#888') : '#888';
                        if (oldOwner === localSlot()) addEvent('mine', '‚Ü©', `${bT} ${body.name} chass√© par vaisseau !`, body, chColor);
                        else addEvent('war', '‚Ü©', `${bT} ${body.name} chass√© (${gameState.players[oldOwner]?.name || 'IA-'+oldOwner})`, body, chColor);
                    }
                    jet.alive = false;
                    return;
                }
                continue;
            }
            if (body.owner === jet.owner) {
                // Density bonus : +5% spores livr√©es par point
                const densityBonus = 1 + (gameState.players[jet.owner]?.stats.density || 0) * 0.05;
                body.spores += jet.spores * densityBonus;
                playFusionSound();
            } else {
                const _ml = gameState.players[jet.owner]?.tech?.mimicry || 0;
                const oldOwner = body.owner;
                if (_ml > 0 && body.type === 'planet' && body.moons && body.moons.length > 0) {
                    const _skip = _ml >= 10;
                    if (!_skip) { applyConquest(body, jet); if (body.owner !== oldOwner) playConquestSound(); }
                    const _mr = 0.2 + _ml * 0.08;
                    const _mc = Math.min(body.moons.length, Math.max(1, Math.ceil(body.moons.length * _ml / 10)));
                    const _ms = Math.max(1, Math.floor(jet.spores * _mr));
                    for (let mi=0; mi<_mc; mi++) {
                        const mn = body.moons[mi]; if (mn.owner === jet.owner) continue;
                        const mdx=mn.x-body.x, mdy=mn.y-body.y, mdd=Math.sqrt(mdx*mdx+mdy*mdy);
                        if (mdd<1) continue;
                        const mSpd=jet.speed*0.8, mTr=computeTrajectory(body.x,body.y,mdx/mdd,mdy/mdd,mSpd,200);
                        gameState.jets.push({ owner:jet.owner, color:jet.color, spores:_ms, trajectory:mTr, posIndex:0, x:body.x, y:body.y, speed:mSpd, alive:true, trail:[], sparkles:[], age:0, selected:false, source:body, _hitBelt:{} });
                    }
                } else {
                    applyConquest(body, jet);
                    if (body.owner !== oldOwner) playConquestSound();
                }
            }
            jet.alive = false;
            return;
        }
    }
}

function applyConquest(body, jet) {
    // Invincibilit√© plan√®te m√®re
    if (body.invincible) return;

    // Density bonus : +5% puissance d'impact par point
    const densityBonus = 1 + (gameState.players[jet.owner]?.stats.density || 0) * 0.05;
    let attacking = jet.spores * densityBonus;
    const attackerColor = gameState.players[jet.owner]?.color || '#FFF';

    // √âpuiser la faune
    if (body.faune > 0) {
        const fauneDmg = Math.min(body.faune, attacking);
        body.faune -= fauneDmg;
        attacking -= fauneDmg;
        // Effet visuel : faune restante
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: '-' + Math.floor(fauneDmg) + ' Faune',
            color: '#FF6B6B', age: 0, maxAge: 4
        });
    }

    // Bonus d√©fense biomes : +0.2% par biome = il faut plus de spores pour conqu√©rir
    const biomeDefense = 1 + (body.biomes || 0) * 0.002;
    attacking = attacking / biomeDefense;

    // Combattre les spores d√©fensives
    if (attacking > 0 && body.owner !== null && body.spores > 0) {
        const defenseDmg = Math.min(body.spores, attacking);
        body.spores -= defenseDmg;
        attacking -= defenseDmg;
    }

    // Conqu√™te r√©ussie ?
    if (attacking > 0 && body.spores <= 0) {
        const oldOwner = body.owner;
        if (oldOwner !== null && gameState.players[oldOwner]) {
            const arr = gameState.players[oldOwner].bodies;
            const idx = arr.indexOf(body);
            if (idx >= 0) arr.splice(idx, 1);
        }

        body.owner = jet.owner;
        body.spores = attacking;
        body.faune = 0; // Faune d√©truite apr√®s conqu√™te
        body.symbiosis = 0; // Reset symbiose
        body.symOwnerTime = 0;
        body.buildMode = 'off';
        body.buildProgress = 0;
        body.nids = 0;
        body.biomes = 0;

        // V√©rifier nidification : annuler si < 50% du syst√®me
        if (oldOwner !== null && gameState.players[oldOwner]) {
            const sunRef = body.type === 'planet' ? body.parent : (body.parent?.parent || null);
            if (sunRef) {
                const nid = gameState.players[oldOwner].nidification[sunRef.name];
                if (nid && nid.motherPlanet) {
                    // Compter le % de possession du syst√®me
                    let total = 0, owned = 0;
                    for (const p of sunRef.planets) {
                        total++; if (p.owner === oldOwner) owned++;
                        for (const m of p.moons) { total++; if (m.owner === oldOwner) owned++; }
                    }
                    const pct = total > 0 ? owned / total : 0;
                    if (pct < 0.5) {
                        // Moins de 50% ‚Üí annuler la nidification
                        const mother = gameState.allBodies.find(b => b.name === nid.motherPlanet);
                        if (mother) { mother.isMotherPlanet = false; mother.invincible = false; }
                        for (const p of sunRef.planets) {
                            for (const m of p.moons) { m.invincible = false; }
                        }
                        delete gameState.players[oldOwner].nidification[sunRef.name];
                        if (oldOwner === localSlot()) addEvent('mine', 'üíî', 'Nidification perdue (<50%) : syst√®me ' + sunRef.name, body, gameState.players[oldOwner]?.color);
                    }
                }
            }
        }

        if (gameState.players[jet.owner]) {
            gameState.players[jet.owner].bodies.push(body);
        }

        gameState.gameStats.bodiesConquered++;

        // Log √©v√©nement
        const attackerName = gameState.players[jet.owner]?.name || 'IA-' + jet.owner;
        const bType = body.type === 'planet' ? 'Plan√®te' : 'Lune';
        const aColor = gameState.players[jet.owner]?.color || '#AAA';
        const oColor = oldOwner !== null ? (gameState.players[oldOwner]?.color || '#AAA') : '#AAA';
        if (oldOwner === null) {
            addEvent('neutral', 'üè≥Ô∏è', `${bType} ${body.name} colonis√©e par ${attackerName}`, body, aColor);
        } else if (jet.owner === localSlot()) {
            addEvent('mine', '‚öîÔ∏è', `${bType} ${body.name} conquise !`, body, aColor);
        } else if (oldOwner === localSlot()) {
            addEvent('mine', 'üíÄ', `${bType} ${body.name} perdue ! (${attackerName})`, body, aColor);
        } else {
            addEvent('war', '‚öîÔ∏è', `${bType} ${body.name} : ${attackerName} prend √† ${gameState.players[oldOwner]?.name || 'IA-'+oldOwner}`, body, aColor);
        }

        // Effet d'√©closion
        gameState.bloomEffects.push({
            body: body, age: 0, maxAge: 1.5, color: attackerColor
        });

        // Effet texte
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: 'CONQUIS !',
            color: attackerColor, age: 0, maxAge: 5
        });
    } else if (attacking <= 0 && body.faune <= 0 && body.spores > 0) {
        // Attaque repouss√©e
        gameState.conquestEffects.push({
            x: body.x, y: body.y - body.radius - 15,
            baseX: body.x,
            text: 'Repouss√©',
            color: '#888', age: 0, maxAge: 3.5
        });
    }
}

function checkJetNeutralization() {
    const jets = gameState.jets;
    for (let i = 0; i < jets.length; i++) {
        if (!jets[i].alive) continue;
        for (let j = i + 1; j < jets.length; j++) {
            if (!jets[j].alive) continue;
            if (jets[i].owner === jets[j].owner) continue;

            const dx = jets[i].x - jets[j].x;
            const dy = jets[i].y - jets[j].y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < 15) {
                playNeutralizationSound();
                gameState.gameStats.jetsNeutralized++;
                const min = Math.min(jets[i].spores, jets[j].spores);
                jets[i].spores -= min;
                jets[j].spores -= min;
                if (jets[i].spores <= 0) jets[i].alive = false;
                if (jets[j].spores <= 0) jets[j].alive = false;
            }
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// JETS DE SPORES ‚Äî Rendu (style gerbe magique)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawJets(ctx) {
    const t = gameState.time;
    const jLod = gameState.lod;

    for (const jet of gameState.jets) {
        if (!jet.alive) continue;

        // ‚îÄ‚îÄ Tra√Æne diffuse (brume color√©e) ‚îÄ‚îÄ
        const trail = jet.trail;
        if (trail.length > 1) {
            // LOD low : skip radial gradients, juste la ligne
            if (jLod >= 1) {
              const step = jLod >= 2 ? 1 : 2; // LOD mid: 1 sur 2
              for (let i = 1; i < trail.length; i += step) {
                const progress = i / trail.length;
                const alpha = progress * 0.35;
                const zs = Math.max(1, 1.2 / gameState.camera.zoom);
                const spread = (8 + (1 - progress) * 6) * zs;

                const g = ctx.createRadialGradient(
                    trail[i].x, trail[i].y, 0,
                    trail[i].x, trail[i].y, spread
                );
                g.addColorStop(0, jet.color + hexAlpha(alpha));
                g.addColorStop(0.6, jet.color + hexAlpha(alpha * 0.4));
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(trail[i].x, trail[i].y, spread, 0, Math.PI * 2);
                ctx.fill();
              }
            }

            // Ligne de tra√Æne lumineuse
            ctx.beginPath();
            ctx.moveTo(trail[0].x, trail[0].y);
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            ctx.lineTo(jet.x, jet.y);
            const zl = Math.max(1, 1.2 / gameState.camera.zoom);
            ctx.strokeStyle = jet.color + '40';
            ctx.lineWidth = 4 * zl;
            ctx.stroke();
            ctx.strokeStyle = '#FFFFFF20';
            ctx.lineWidth = 2 * zl;
            ctx.stroke();
        }

        // Taille adapt√©e au zoom (toujours bien visible)
        const z = gameState.camera.zoom;
        const scale = Math.max(1, 1.2 / z);
        const haloR = 30 * scale;
        const coreR = 8 * scale;
        const sparkScale = scale;

        // ‚îÄ‚îÄ Halo externe large (lueur magique) ‚îÄ‚îÄ
        const gOuter = ctx.createRadialGradient(jet.x, jet.y, 0, jet.x, jet.y, haloR);
        gOuter.addColorStop(0, jet.color + '50');
        gOuter.addColorStop(0.3, jet.color + '25');
        gOuter.addColorStop(0.7, jet.color + '10');
        gOuter.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gOuter;
        ctx.beginPath();
        ctx.arc(jet.x, jet.y, haloR, 0, Math.PI * 2);
        ctx.fill();

        // ‚îÄ‚îÄ Noyau lumineux ‚îÄ‚îÄ
        const gCore = ctx.createRadialGradient(jet.x, jet.y, 0, jet.x, jet.y, coreR);
        gCore.addColorStop(0, '#FFFFFFEE');
        gCore.addColorStop(0.3, jet.color + 'DD');
        gCore.addColorStop(0.6, jet.color + '88');
        gCore.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gCore;
        ctx.beginPath();
        ctx.arc(jet.x, jet.y, coreR, 0, Math.PI * 2);
        ctx.fill();

        // ‚îÄ‚îÄ Particules scintillantes (LOD high uniquement) ‚îÄ‚îÄ
        if (jLod < 2) { /* skip sparkles */ }
        else for (const sp of jet.sparkles) {
            const sx = jet.x + sp.offX * sparkScale;
            const sy = jet.y + sp.offY * sparkScale;
            const flicker = 0.4 + Math.sin(t * 8 + sp.phase) * 0.4;
            const sr = (sp.radius + 1) * flicker * sparkScale;

            ctx.fillStyle = '#FFFFFF' + hexAlpha(flicker * 0.8);
            ctx.beginPath();
            ctx.arc(sx, sy, sr, 0, Math.PI * 2);
            ctx.fill();

            // Petite lueur color√©e autour
            ctx.fillStyle = jet.color + hexAlpha(flicker * 0.4);
            ctx.beginPath();
            ctx.arc(sx, sy, sr + 3 * sparkScale, 0, Math.PI * 2);
            ctx.fill();
        }

        // ‚îÄ‚îÄ Afficher le nombre de spores si s√©lectionn√© (clic) ‚îÄ‚îÄ
        if (jet.selected) {
            ctx.font = '10px Orbitron';
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.fillText(Math.floor(jet.spores), jet.x, jet.y - 18);
        }
    }
}

// Helper : escape HTML (anti-XSS)
function esc(s) { const d = document.createElement('div'); d.textContent = s; return d.innerHTML; }

// Helper : alpha (0-1) ‚Üí hex string 2 chars
function hexAlpha(a) {
    return Math.floor(Math.min(1, Math.max(0, a)) * 255).toString(16).padStart(2, '0');
}

function drawLaunchPreview(ctx) {
    if (!gameState.launching || !gameState.launchSource) return;
    const src = gameState.launchSource;
    const preview = gameState.launchPreview;

    if (preview.length < 2) return;

    // Nombre de points √† afficher (70%)
    const count = Math.floor(preview.length * 0.7);

    ctx.save();
    ctx.setLineDash([4, 6]);
    const player = gameState.players[src.owner];
    const col = player ? player.color : '#C8A0FF';

    for (let i = 0; i < count - 1; i++) {
        const alpha = 0.5 * (1 - i / count);
        ctx.strokeStyle = col + Math.floor(alpha * 255).toString(16).padStart(2, '0');
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(preview[i].x, preview[i].y);
        ctx.lineTo(preview[i+1].x, preview[i+1].y);
        ctx.stroke();
    }
    ctx.restore();
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INPUT ‚Äî Zoom & Panoramique
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function setupInput() {
    const canvas = gameState.canvas;
    const cam = gameState.camera;
    const inp = gameState.input;

    // ‚îÄ‚îÄ Molette : Zoom ‚îÄ‚îÄ
    canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const direction = e.deltaY > 0 ? -1 : 1;
        const factor = 1 + cam.zoomSpeed;
        const oldZoom = cam.zoom;
        const newZoom = direction > 0
            ? Math.min(cam.zoom * factor, cam.maxZoom)
            : Math.max(cam.zoom / factor, cam.minZoom);

        // Zoom vers le curseur
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        // Position monde sous le curseur avant zoom
        const worldX = (mx - gameState.width / 2) / oldZoom + cam.x;
        const worldY = (my - gameState.height / 2) / oldZoom + cam.y;

        cam.zoom = newZoom;

        // Ajuster la cam√©ra pour que le point monde reste sous le curseur
        cam.x = worldX - (mx - gameState.width / 2) / newZoom;
        cam.y = worldY - (my - gameState.height / 2) / newZoom;
    }, { passive: false });

    // ‚îÄ‚îÄ Clic gauche maintenu : Lancement de jet ‚îÄ‚îÄ
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 0 && gameState.phase === 'game') {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;
            const wx = (mx - gameState.width / 2) / cam.zoom + cam.x;
            const wy = (my - gameState.height / 2) / cam.zoom + cam.y;

            // Chercher un astre poss√©d√© par le joueur humain
            const bodies = gameState.allBodies;
            for (const body of bodies) {
                if (body.owner !== localSlot()) continue;
                const dx = body.x - wx;
                const dy = body.y - wy;
                if (Math.sqrt(dx*dx + dy*dy) < body.radius + 8) {
                    gameState.launching = true;
                    gameState.launchSource = body;
                    gameState.launchPreview = [];
                    gameState.launchStartTime = performance.now();
                    gameState.launchCameraLock = false;
                    break;
                }
            }
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (e.button === 0 && gameState.launching && gameState.launchSource) {
            const elapsed = performance.now() - (gameState.launchStartTime || 0);
            const src = gameState.launchSource;

            // Clic court = ouvrir le codex au lieu de lancer
            if (elapsed < 150) {
                gameState.launching = false;
                gameState.launchSource = null;
                gameState.launchPreview = [];
                gameState.launchCameraLock = false;
                openCodex(src);
                followingBody = src;
                justLaunched = true;
                return;
            }

            const dx = gameState.mouseWorldX - src.x;
            const dy = gameState.mouseWorldY - src.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 10) {
                launchJet(src, dx/len, dy/len);
                if (gameState.isMulti) sendAction('jet', { srcName: src.name, dirX: dx/len, dirY: dy/len });
                justLaunched = true;
                
            }
            gameState.launching = false;
            gameState.launchSource = null;
            gameState.launchPreview = [];
            gameState.launchCameraLock = false;
        }
    });

    // ‚îÄ‚îÄ Clic droit : Panoramique ‚îÄ‚îÄ
    canvas.addEventListener('mousedown', (e) => {
        if (e.button === 2 || e.button === 1) { // clic droit ou molette
            e.preventDefault();
            inp.isDragging = true;
            inp.dragStartX = e.clientX;
            inp.dragStartY = e.clientY;
            inp.cameraStartX = cam.x;
            // Arr√™ter le suivi de plan√®te
            if (typeof followingBody !== 'undefined') { followingBody = null; document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active')); }
            inp.cameraStartY = cam.y;
            canvas.classList.add('grabbing');
        }
    });

    window.addEventListener('mousemove', (e) => {
        inp.mouseX = e.clientX;
        inp.mouseY = e.clientY;

        // Position monde sous la souris
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        gameState.mouseWorldX = (mx - gameState.width / 2) / cam.zoom + cam.x;
        gameState.mouseWorldY = (my - gameState.height / 2) / cam.zoom + cam.y;

        // Pr√©visualisation de lancement
        if (gameState.launching && gameState.launchSource && performance.now() - (gameState.launchStartTime||0) > 150) {
            if (!gameState.launchCameraLock) gameState.launchCameraLock = true;
            const src = gameState.launchSource;
            const dx = gameState.mouseWorldX - src.x;
            const dy = gameState.mouseWorldY - src.y;
            const len = Math.sqrt(dx*dx + dy*dy);
            if (len > 1) {
                const player = gameState.players[src.owner];
                const speed = 20 + (player ? player.stats.velocity * 6 : 0);
                gameState.launchPreview = computeTrajectory(src.x, src.y, dx/len, dy/len, speed, 400);
            }
        }

        if (inp.isDragging && !gameState.launchCameraLock) {
            const dx = e.clientX - inp.dragStartX;
            const dy = e.clientY - inp.dragStartY;
            cam.x = inp.cameraStartX - dx / cam.zoom;
            cam.y = inp.cameraStartY - dy / cam.zoom;
        }
    });

    window.addEventListener('mouseup', (e) => {
        if (e.button === 2 || e.button === 1) {
            inp.isDragging = false;
            canvas.classList.remove('grabbing');
        }
    }, true);

    // ‚îÄ‚îÄ Clic gauche : spawn / codex ‚îÄ‚îÄ
    let justLaunched = false;
    canvas.addEventListener('click', (e) => {
        if (e.button !== 0) return;
        if (justLaunched) { justLaunched = false; return; }
        const rect = canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const worldX = (mx - gameState.width / 2) / cam.zoom + cam.x;
        const worldY = (my - gameState.height / 2) / cam.zoom + cam.y;

        if (gameState.phase === 'spawn') {
            handleSpawnClick(worldX, worldY);
        } else if (gameState.phase === 'game') {
            // Chercher un jet sous le clic
            let clickedJet = false;
            for (const jet of gameState.jets) {
                jet.selected = false;
                const dx = jet.x - worldX, dy = jet.y - worldY;
                if (Math.sqrt(dx*dx+dy*dy) < 20) {
                    jet.selected = true;
                    clickedJet = true;
                }
            }
            if (!clickedJet) {
                // Chercher un astre sous le clic
                const body = findBodyAt(worldX, worldY);
                if (body) {
                    openCodex(body);
                    followingBody = body;
                    cam.x = body.x;
                    cam.y = body.y;
                }
                else closeCodex();
            }
        }
    });

    // Emp√™cher le menu contextuel
    canvas.addEventListener('contextmenu', (e) => e.preventDefault());

    // ‚îÄ‚îÄ Touch : zoom pinch, pan, jet ‚îÄ‚îÄ
    let _touches = {};
    let _pinchDist = 0;
    let _touchPan = false;
    let _touchJet = false;
    let _touchStart = 0;

    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        if (e.touches.length === 2) {
            _touchPan = false; _touchJet = false;
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            _pinchDist = Math.sqrt(dx*dx + dy*dy);
        } else if (e.touches.length === 1) {
            const t = e.touches[0];
            const mx = t.clientX - rect.left;
            const my = t.clientY - rect.top;
            const wx = (mx - gameState.width / 2) / cam.zoom + cam.x;
            const wy = (my - gameState.height / 2) / cam.zoom + cam.y;
            _touchStart = performance.now();
            _touchJet = false; _touchPan = false;
            _touches = { sx: t.clientX, sy: t.clientY, wx, wy };
            if (gameState.phase === 'game') {
                for (const body of gameState.allBodies) {
                    if (body.owner !== localSlot()) continue;
                    if (Math.sqrt((body.x-wx)**2 + (body.y-wy)**2) < body.radius + 12) {
                        _touchJet = true;
                        gameState.launching = true;
                        gameState.launchSource = body;
                        gameState.launchPreview = [];
                        gameState.launchStartTime = performance.now();
                        gameState.launchCameraLock = false;
                        break;
                    }
                }
            }
            if (!_touchJet) _touchPan = true;
        }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (e.touches.length === 2 && _pinchDist > 0) {
            const dx = e.touches[0].clientX - e.touches[1].clientX;
            const dy = e.touches[0].clientY - e.touches[1].clientY;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const scale = dist / _pinchDist;
            cam.zoom = Math.max(cam.minZoom, Math.min(cam.maxZoom, cam.zoom * scale));
            _pinchDist = dist;
        } else if (e.touches.length === 1) {
            const t = e.touches[0];
            if (_touchPan) {
                cam.x -= (t.clientX - _touches.sx) / cam.zoom;
                cam.y -= (t.clientY - _touches.sy) / cam.zoom;
                _touches.sx = t.clientX; _touches.sy = t.clientY;
            }
            if (_touchJet && gameState.launching) {
                const rect = canvas.getBoundingClientRect();
                gameState.mouseWorldX = (t.clientX - rect.left - gameState.width / 2) / cam.zoom + cam.x;
                gameState.mouseWorldY = (t.clientY - rect.top - gameState.height / 2) / cam.zoom + cam.y;
            }
        }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
        if (_touchJet && gameState.launching && gameState.launchSource) {
            const elapsed = performance.now() - _touchStart;
            const src = gameState.launchSource;
            if (elapsed < 200) {
                openCodex(src); followingBody = src;
            } else {
                const dx = gameState.mouseWorldX - src.x;
                const dy = gameState.mouseWorldY - src.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                if (len > 10) {
                    launchJet(src, dx/len, dy/len);
                    if (gameState.isMulti) sendAction('jet', { srcName: src.name, dirX: dx/len, dirY: dy/len });
                }
            }
            gameState.launching = false;
            gameState.launchSource = null;
            gameState.launchPreview = [];
            gameState.launchCameraLock = false;
        }
        _touchJet = false; _touchPan = false; _pinchDist = 0;
    });
}

function findBodyAt(wx, wy) {
    // Chercher lunes, puis plan√®tes, puis soleils (plus petit d'abord)
    for (const m of gameState.moons) {
        const dx = m.x - wx, dy = m.y - wy;
        const hr = Math.max(m.radius + 18, 22);
        if (dx*dx + dy*dy < hr * hr) return m;
    }
    for (const p of gameState.planets) {
        const dx = p.x - wx, dy = p.y - wy;
        const hr = Math.max(p.radius + 14, 20);
        if (dx*dx + dy*dy < hr * hr) return p;
    }
    for (const s of gameState.suns) {
        const dx = s.x - wx, dy = s.y - wy;
        if (dx*dx + dy*dy < (s.radius + 10) * (s.radius + 10)) return s;
    }
    return null;
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// BOUCLE DE JEU
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function gameLoop(timestamp) {
    if (!gameState.running) return;

    // Delta time (en secondes)
    gameState.deltaTime = (timestamp - gameState.lastTime) / 1000;
    gameState.lastTime = timestamp;

    // Cap delta pour √©viter les sauts apr√®s un onglet en arri√®re-plan
    if (gameState.deltaTime > 0.1) gameState.deltaTime = 0.016;

    // FPS
    gameState.fpsFrames++;
    if (timestamp - gameState.fpsLastCheck >= 500) {
        gameState.fps = Math.round(gameState.fpsFrames / ((timestamp - gameState.fpsLastCheck) / 1000));
        gameState.fpsFrames = 0;
        gameState.fpsLastCheck = timestamp;
        if (DOM.fps) DOM.fps.textContent = gameState.fps + ' FPS';
    }

    // Update
    update(gameState.deltaTime);

    // Render
    render();

    requestAnimationFrame(gameLoop);
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// UPDATE (logique de jeu)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function update(dt) {
    gameState.time += dt;
    if (gameState.phase === 'paused') return;
    updateLOD(dt);
    updateOrbits(dt);
    updateCosmicEffects(dt);
    updateSporeGeneration(dt);
    updateComets(dt);
    updateAI(dt);
    updateCleaners(dt);
    updateJets(dt);
    updateImpacts(dt);
    updateConquestEffects(dt);
    updateCameraFollow();
    // Mise √† jour HUD toutes les 5 frames (perf)
    gameState._hudCounter = (gameState._hudCounter || 0) + 1;
    if (gameState._hudCounter % 5 === 0) {
        updateMyPlanets();
        updateHUD();
        updateMultiPanel();
        updateTechPanel();
        updateNidPanel();
        checkVictoryAndElimination();
    }
    gameState.gameStats.timeElapsed += dt;
    updateAudioTension();
    updateOrbitHum();
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// RENDER (dessin)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function render() {
    const ctx = gameState.ctx;
    const cam = gameState.camera;
    const w = gameState.width;
    const h = gameState.height;

    // ‚îÄ‚îÄ Effacer ‚îÄ‚îÄ
    ctx.fillStyle = SKY_CFG._hex || '#16264E';
    ctx.fillRect(0, 0, w, h);

    // ‚îÄ‚îÄ Appliquer la transformation cam√©ra ‚îÄ‚îÄ
    ctx.save();
    ctx.translate(w / 2, h / 2);
    ctx.scale(cam.zoom, cam.zoom);
    ctx.translate(-cam.x, -cam.y);

    // ‚îÄ‚îÄ Fond spatial ‚îÄ‚îÄ
    drawBackground(ctx);

    // ‚îÄ‚îÄ Particules & √©toiles filantes (LOD mid+) ‚îÄ‚îÄ
    if (gameState.lod >= 1) drawCosmicEffects(ctx);

    // ‚îÄ‚îÄ Com√®tes ‚îÄ‚îÄ
    drawComets(ctx);

    // ‚îÄ‚îÄ Trou noir ‚îÄ‚îÄ
    drawBlackHole(ctx);

    // ‚îÄ‚îÄ Soleils ‚îÄ‚îÄ
    drawSuns(ctx);

    // ‚îÄ‚îÄ Amas de m√©t√©orites ‚îÄ‚îÄ
    drawAsteroidBelts(ctx);

    // ‚îÄ‚îÄ Plan√®tes & Lunes ‚îÄ‚îÄ
    drawPlanets(ctx);

    // ‚îÄ‚îÄ Vaisseaux nettoyeurs ‚îÄ‚îÄ
    drawCleaners(ctx);

    // ‚îÄ‚îÄ Jets de spores ‚îÄ‚îÄ
    drawJets(ctx);

    // ‚îÄ‚îÄ Pr√©visualisation de lancement ‚îÄ‚îÄ
    // Recalculer la preview √† chaque frame (la plan√®te orbite m√™me si la souris ne bouge pas)
    if (gameState.launching && gameState.launchSource && performance.now() - (gameState.launchStartTime||0) > 150) {
        const src = gameState.launchSource;
        const dx = gameState.mouseWorldX - src.x;
        const dy = gameState.mouseWorldY - src.y;
        const len = Math.sqrt(dx*dx + dy*dy);
        if (len > 1) {
            const player = gameState.players[src.owner];
            const speed = 20 + (player ? player.stats.velocity * 6 : 0);
            gameState.launchPreview = computeTrajectory(src.x, src.y, dx/len, dy/len, speed, 400);
        }
    }
    drawLaunchPreview(ctx);

    // ‚îÄ‚îÄ Impacts (LOD mid+) ‚îÄ‚îÄ
    if (gameState.lod >= 1) drawImpacts(ctx);

    // ‚îÄ‚îÄ Effets de conqu√™te ‚îÄ‚îÄ
    drawConquestEffects(ctx);

    // ‚îÄ‚îÄ Compteurs de spores sur les astres ‚îÄ‚îÄ
    drawSporeCountOnBodies(ctx);

    ctx.restore();

    // ‚îÄ‚îÄ D√©bris premier plan (LOD mid+) ‚îÄ‚îÄ
    if (gameState.lod >= 1) drawForegroundDebris(ctx);

    // ‚îÄ‚îÄ Indicateurs hors-√©cran (hors transformation cam√©ra) ‚îÄ‚îÄ
    drawOffscreenIndicators();
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DESSIN ‚Äî Fond spatial (tuil√©)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawBackground(ctx) {
    const cam = gameState.camera;
    // Fond bleu d√©grad√© (parallaxe tr√®s lente, couvre tout)
    if (gameState._bgCanvas) {
        const bgS = 60000;
        const px = -bgS / 2 + cam.x * 0.02;
        const py = -bgS / 2 + cam.y * 0.02;
        ctx.drawImage(gameState._bgCanvas, px, py, bgS, bgS);
    }
    // √âtoiles (tuil√©es, parallaxe moyenne)
    if (gameState._starsCanvas) {
        const tileS = 8000;
        const prlx = 0.15;
        const offX = cam.x * (1 - prlx);
        const offY = cam.y * (1 - prlx);
        const startX = Math.floor((cam.x - 5000 / cam.zoom - offX) / tileS) * tileS;
        const startY = Math.floor((cam.y - 5000 / cam.zoom - offY) / tileS) * tileS;
        const endX = cam.x + 5000 / cam.zoom - offX;
        const endY = cam.y + 5000 / cam.zoom - offY;
        for (let tx = startX; tx <= endX; tx += tileS) {
            for (let ty = startY; ty <= endY; ty += tileS) {
                ctx.drawImage(gameState._starsCanvas, tx + offX, ty + offY, tileS, tileS);
            }
        }
    }
}



// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DESSIN ‚Äî Trou noir
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawBlackHole(ctx) {
    const bh = gameState.blackHole;
    if (!bh) return;
    const t = gameState.time;
    const bhLod = gameState.lod;

    // Zone de danger (halo externe) ‚Äî gradient cach√©
    if (!bh._gDanger) {
        bh._gDanger = ctx.createRadialGradient(0, 0, bh.radius, 0, 0, bh.dangerZone);
        bh._gDanger.addColorStop(0, 'rgba(100, 40, 180, 0.25)');
        bh._gDanger.addColorStop(0.5, 'rgba(60, 20, 120, 0.1)');
        bh._gDanger.addColorStop(1, 'rgba(0, 0, 0, 0)');
    }
    const gDanger = bh._gDanger;
    ctx.fillStyle = gDanger;
    ctx.beginPath();
    ctx.arc(0, 0, bh.dangerZone, 0, Math.PI * 2);
    ctx.fill();

    // Disque d'accr√©tion rotatif (LOD mid+)
    if (bhLod >= 1) { ctx.save();
    ctx.rotate(t * 0.3);
    for (let i = 0; i < 3; i++) {
        const discR = bh.radius * (2 + i * 0.6);
        const alpha = 0.12 - i * 0.03;
        ctx.strokeStyle = `rgba(160, 80, 255, ${alpha})`;
        ctx.lineWidth = 3 - i * 0.8;
        ctx.beginPath();
        ctx.ellipse(0, 0, discR, discR * 0.35, i * 0.4, 0, Math.PI * 2);
        ctx.stroke();
    }
    ctx.restore();
    }

    // Lueur pulsante (LOD mid+)
    if (bhLod >= 1) { const pulse = 1 + Math.sin(t * 2) * 0.08;
    const gGlow = ctx.createRadialGradient(0, 0, bh.radius * 0.5, 0, 0, bh.radius * 2 * pulse);
    gGlow.addColorStop(0, 'rgba(120, 50, 200, 0.08)');
    gGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gGlow;
    ctx.beginPath();
    ctx.arc(0, 0, bh.radius * 2 * pulse, 0, Math.PI * 2);
    ctx.fill();

    }

    // Anneau de danger pulsant (LOD high)
    if (bhLod >= 2) { const dangerPulse = 0.5 + Math.sin(t * 1.5) * 0.3;
    ctx.strokeStyle = `rgba(255, 50, 50, ${0.08 * dangerPulse})`;
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 10]);
    ctx.beginPath();
    ctx.arc(0, 0, bh.dangerZone * 0.4, 0, Math.PI * 2);
    ctx.stroke();
    ctx.setLineDash([]);
    }

    // Trou noir (noyau) ‚Äî gradient cach√©
    if (!bh._gCore) {
        bh._gCore = ctx.createRadialGradient(0, 0, 0, 0, 0, bh.radius);
        bh._gCore.addColorStop(0, '#000000');
        bh._gCore.addColorStop(0.7, '#000000');
        bh._gCore.addColorStop(1, 'rgba(80, 30, 140, 0.5)');
    }
    const gCore = bh._gCore;
    ctx.fillStyle = gCore;
    ctx.beginPath();
    ctx.arc(0, 0, bh.radius, 0, Math.PI * 2);
    ctx.fill();
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DESSIN ‚Äî Soleils
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawAsteroidBelts(ctx) {
    const t = gameState.time;
    for (const belt of gameState.asteroidBelts) {
        const sun = belt.sun;

        // Tra√Æn√©e orbitale (LOD mid+)
        if (gameState.lod >= 1) {
            ctx.strokeStyle = 'rgba(80,70,60,0.06)';
            ctx.lineWidth = 14;
            ctx.beginPath();
            ctx.arc(sun.x, sun.y, belt.radius, 0, Math.PI * 2);
            ctx.stroke();
        }

        for (const rock of belt.rocks) {
            const a = rock.angle;
            const r = belt.radius + rock.radiusOff;
            const cx = sun.x + Math.cos(a) * r;
            const cy = sun.y + Math.sin(a) * r;

            for (let si = 0; si < rock.subRocks.length; si++) {
                const sr = rock.subRocks[si];
                const rx = cx + sr.offX;
                const ry = cy + sr.offY;
                const rot = t * 0.3 + si * 1.7 + rock.angle * 5;
                const sz = sr.size;

                // Polygone irr√©gulier (5-7 c√¥t√©s)
                const sides = sr._sides || (sr._sides = 5 + Math.floor(worldRandom() * 3));
                const verts = sr._verts || (sr._verts = Array.from({length: sides}, (_, i) => 0.7 + worldRandom() * 0.6));

                ctx.save();
                ctx.translate(rx, ry);
                ctx.rotate(rot);

                // Ombre (c√¥t√© sombre)
                ctx.fillStyle = sr.color;
                ctx.beginPath();
                for (let v = 0; v < sides; v++) {
                    const va = (v / sides) * Math.PI * 2;
                    const vr = sz * verts[v];
                    if (v === 0) ctx.moveTo(Math.cos(va) * vr, Math.sin(va) * vr);
                    else ctx.lineTo(Math.cos(va) * vr, Math.sin(va) * vr);
                }
                ctx.closePath();
                ctx.fill();

                // Reflet (demi-lune √©clair√©e)
                ctx.globalAlpha = 0.25;
                ctx.fillStyle = '#FFF';
                ctx.beginPath();
                ctx.arc(sz * -0.2, sz * -0.2, sz * 0.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;

                ctx.restore();
            }

            // Lueur de groupe (LOD high)
            if (gameState.lod >= 2) {
                let haloColor;
                if (rock.type === 'dark') haloColor = 'rgba(60,55,50,0.06)';
                else if (rock.type === 'red') haloColor = 'rgba(120,50,40,0.06)';
                else haloColor = 'rgba(50,100,50,0.06)';
                ctx.fillStyle = haloColor;
                ctx.beginPath();
                ctx.arc(cx, cy, 20, 0, Math.PI * 2);
                ctx.fill();
            }
        }
    }
}

function drawSuns(ctx) {
    const t = gameState.time;
    const cam = gameState.camera;
    const halfW = gameState.width / 2 / cam.zoom;
    const halfH = gameState.height / 2 / cam.zoom;

    for (let i = 0; i < gameState.suns.length; i++) {
        const sun = gameState.suns[i];

        // Culling
        const margin = sun.radius * 4;
        if (sun.x < cam.x - halfW - margin || sun.x > cam.x + halfW + margin ||
            sun.y < cam.y - halfH - margin || sun.y > cam.y + halfH + margin) continue;

        const pulse = 1 + Math.sin(t * 1.5 + i * 2) * 0.04;

        // Halo pulsant (depuis cache)
        if (sun._haloCache) {
            const drawR = sun._haloR * pulse;
            ctx.drawImage(sun._haloCache, sun.x - drawR, sun.y - drawR, drawR * 2, drawR * 2);
        }

        // Texture cach√©e
        if (sun._texture) {
            const texSize = sun._texture.width;
            const drawR = sun.radius * pulse;
            ctx.drawImage(sun._texture, sun.x - drawR, sun.y - drawR, drawR * 2, drawR * 2);
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DESSIN ‚Äî Plan√®tes & Lunes
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawPlanets(ctx) {
    const cam = gameState.camera;
    const halfW = gameState.width / 2 / cam.zoom;
    const halfH = gameState.height / 2 / cam.zoom;

    for (let i = 0; i < gameState.planets.length; i++) {
        const p = gameState.planets[i];

        // Culling plan√®te + orbite
        const margin = p.orbitRadius + p.radius + 50;
        if (p.parent.x < cam.x - halfW - margin && p.parent.x > cam.x + halfW + margin &&
            p.parent.y < cam.y - halfH - margin && p.parent.y > cam.y + halfH + margin) continue;

        // Orbite (trait fin) ‚Äî LOD mid+
        if (gameState.lod >= 1) {
            ctx.strokeStyle = 'rgba(255,255,255,0.04)';
            ctx.lineWidth = 0.5;
            ctx.beginPath();
            ctx.arc(p.parent.x, p.parent.y, p.orbitRadius, 0, Math.PI * 2);
            ctx.stroke();
        }

        // Plan√®te (texture cach√©e)
        if (p._texture) {
            ctx.drawImage(p._texture, p.x - p.radius, p.y - p.radius, p.radius * 2, p.radius * 2);
        }

        // Anneaux (gazeuses) ‚Äî LOD mid+
        if (p._hasRings && gameState.lod >= 1) {
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.scale(1, p._ringTilt);
            ctx.strokeStyle = p._ringColor1;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 1.6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = p._ringColor2;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 1.9, 0, Math.PI * 2);
            ctx.stroke();
            ctx.strokeStyle = p._ringColor1;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, p.radius * 2.15, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
        }

        // Atmosph√®re (LOD mid+ uniquement)
        if (p._hasAtmosphere && gameState.lod >= 1) {
            const gAtmo = ctx.createRadialGradient(p.x, p.y, p.radius * 0.85, p.x, p.y, p.radius * 1.3);
            gAtmo.addColorStop(0, 'rgba(0,0,0,0)');
            gAtmo.addColorStop(0.5, p._atmoColor);
            gAtmo.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gAtmo;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius * 1.3, 0, Math.PI * 2);
            ctx.fill();
        }

        // √âclairage directionnel (LOD high uniquement)
        if (p.parent && gameState.lod >= 2) {
            const ldx = p.parent.x - p.x;
            const ldy = p.parent.y - p.y;
            const ldist = Math.sqrt(ldx*ldx + ldy*ldy);
            if (ldist > 0) {
                const lnx = ldx / ldist;
                const lny = ldy / ldist;
                const lightX = p.x + lnx * p.radius * 0.4;
                const lightY = p.y + lny * p.radius * 0.4;
                const gLight = ctx.createRadialGradient(lightX, lightY, 0, p.x, p.y, p.radius);
                gLight.addColorStop(0, 'rgba(255,255,200,0.35)');
                gLight.addColorStop(0.5, 'rgba(0,0,0,0)');
                gLight.addColorStop(1, 'rgba(0,0,20,0.30)');
                ctx.fillStyle = gLight;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Halo de propri√©taire
        if (p.owner !== null && p.owner !== undefined) {
            const ownerColor = gameState.players[p.owner]?.color || '#FFF';
            ctx.strokeStyle = ownerColor;
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.5 + Math.sin(gameState.time * 2) * 0.15;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius + 3, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;

            // Couronne plan√®te m√®re
            if (p.isMotherPlanet) {
                ctx.save();
                ctx.font = (p.radius * 1.2) + 'px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('üëë', p.x, p.y - p.radius - 5);
                ctx.restore();
            }
        }

        // Lunes
        for (let j = 0; j < p.moons.length; j++) {
            const m = p.moons[j];

            // Culling lune
            if (m.x < cam.x - halfW - 20 || m.x > cam.x + halfW + 20 ||
                m.y < cam.y - halfH - 20 || m.y > cam.y + halfH + 20) continue;

            // Orbite de lune ‚Äî LOD high
            if (gameState.lod >= 2) {
                ctx.strokeStyle = 'rgba(255,255,255,0.03)';
                ctx.lineWidth = 0.3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, m.orbitRadius, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Lune (texture cach√©e)
            if (m._texture) {
                ctx.drawImage(m._texture, m.x - m.radius, m.y - m.radius, m.radius * 2, m.radius * 2);
            } else {
                ctx.fillStyle = 'rgba(180, 180, 200, 0.7)';
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            // Halo propri√©taire lune
            if (m.owner !== null && m.owner !== undefined) {
                const ownerColor = gameState.players[m.owner]?.color || '#FFF';
                ctx.strokeStyle = ownerColor;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.5 + Math.sin(gameState.time * 2) * 0.15;
                ctx.beginPath();
                ctx.arc(m.x, m.y, m.radius + 2, 0, Math.PI * 2);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// LANCEMENT
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// VAISSEAUX NETTOYEURS
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateCleaners(dt) {
    const bh = gameState.blackHole;

    for (const cl of gameState.cleaners) {
        // Mouvement : naviguer vers une plan√®te cible
        cl.turnTimer -= dt;
        if (cl.turnTimer <= 0) {
            cl.turnTimer = CLN_CFG.turnInterval + gameRandom() * 5;
            const speed = CLN_CFG.speedMin + gameRandom() * (CLN_CFG.speedMax - CLN_CFG.speedMin);
            // 70% chance de viser une plan√®te, 30% errance locale
            if (gameRandom() < 0.7 && gameState.planets.length > 0) {
                const target = gameState.planets[Math.floor(gameRandom() * gameState.planets.length)];
                cl._target = target;
                const tdx = target.x - cl.x;
                const tdy = target.y - cl.y;
                const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
                if (tDist > 0) {
                    cl.vx = (tdx / tDist) * speed;
                    cl.vy = (tdy / tDist) * speed;
                }
            } else {
                cl._target = null;
                const wanderAngle = Math.atan2(cl.y, cl.x) + (gameRandom() - 0.5) * 1.5;
                cl.vx = Math.cos(wanderAngle) * speed * 0.5;
                cl.vy = Math.sin(wanderAngle) * speed * 0.5;
            }
        }

        // Si on a une cible, ajuster la direction en temps r√©el (la plan√®te bouge)
        if (cl._target) {
            const tdx = cl._target.x - cl.x;
            const tdy = cl._target.y - cl.y;
            const tDist = Math.sqrt(tdx * tdx + tdy * tdy);
            if (tDist < 80) {
                cl.turnTimer = 0;
            } else if (tDist > 0) {
                const currentSpeed = Math.sqrt(cl.vx * cl.vx + cl.vy * cl.vy);
                cl.vx += (tdx / tDist) * 15 * dt;
                cl.vy += (tdy / tDist) * 15 * dt;
                const newSpeed = Math.sqrt(cl.vx * cl.vx + cl.vy * cl.vy);
                if (newSpeed > currentSpeed * 1.2) {
                    cl.vx = (cl.vx / newSpeed) * currentSpeed;
                    cl.vy = (cl.vy / newSpeed) * currentSpeed;
                }
            }
        }

        cl.x += cl.vx * dt;
        cl.y += cl.vy * dt;

        // Repousser du trou noir
        const bhDx = cl.x - bh.x;
        const bhDy = cl.y - bh.y;
        const bhDist = Math.sqrt(bhDx * bhDx + bhDy * bhDy);
        if (bhDist < bh.dangerZone * 2) {
            cl.vx += (bhDx / bhDist) * 30 * dt;
            cl.vy += (bhDy / bhDist) * 30 * dt;
        }

        // Garder dans la zone de jeu (orbite du soleil le plus √©loign√© + marge)
        let maxRange = 500;
        for (const sun of gameState.suns) {
            const lastP = sun.planets[sun.planets.length - 1];
            const total = sun.orbitRadius + (lastP ? lastP.orbitRadius : 0) + 100;
            if (total > maxRange) maxRange = total;
        }
        const distFromCenter = Math.sqrt(cl.x * cl.x + cl.y * cl.y);
        if (distFromCenter > maxRange) {
            cl.vx -= cl.x * 0.02;
            cl.vy -= cl.y * 0.02;
        }

        // Tirer sur les jets √† port√©e
        cl.fireTimer -= dt;
        if (cl.fireTimer <= 0) {
            cl.fireTimer = CLN_CFG.fireRate;
            for (const jet of gameState.jets) {
                if (!jet.alive) continue;
                const dx = jet.x - cl.x;
                const dy = jet.y - cl.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < CLN_CFG.detectRange) {
                    playCleanerSound(cl.x, cl.y);

                    if (cl.type === 'red') {
                        // Rouge : attaque classique, r√©duit les spores
                        const damage = CLN_CFG.dmgMin + gameRandom() * (CLN_CFG.dmgMax - CLN_CFG.dmgMin);
                        jet.spores -= damage;
                        if (jet.spores <= 0) jet.alive = false;
                        gameState.conquestEffects.push({
                            x: jet.x, y: jet.y - 10, baseX: jet.x,
                            text: '-' + Math.floor(damage),
                            color: '#FF4444', age: 0, maxAge: 1.5
                        });
                    } else if (cl.type === 'green') {
                        // Vert : multiplie les spores par 2 (une seule fois)
                        if (!jet._boosted) {
                            jet.spores = Math.floor(jet.spores * 2);
                            jet._boosted = true;
                            gameState.conquestEffects.push({
                                x: jet.x, y: jet.y - 10, baseX: jet.x,
                                text: 'x2',
                                color: '#44FF44', age: 0, maxAge: 1.5
                            });
                        }
                    } else if (cl.type === 'dark') {
                        // Noir : renvoie les spores vers la plan√®te d'origine
                        if (jet.source && jet.source.owner !== null) {
                            const src = jet.source;
                            const returnSpores = jet.spores;
                            // Cr√©er un jet retour hostile (owner = -1, neutre hostile)
                            const rdx = src.x - jet.x;
                            const rdy = src.y - jet.y;
                            const rDist = Math.sqrt(rdx * rdx + rdy * rdy);
                            if (rDist > 0) {
                                const traj = computeTrajectory(jet.x, jet.y, rdx / rDist, rdy / rDist, jet.speed * 1.2, 400);
                                gameState.jets.push({
                                    owner: -1,
                                    color: '#333333',
                                    spores: returnSpores,
                                    trajectory: traj,
                                    posIndex: 0,
                                    x: jet.x, y: jet.y,
                                    speed: jet.speed * 1.2,
                                    alive: true,
                                    trail: [],
                                    sparkles: [],
                                    age: 0,
                                    selected: false,
                                    source: null,
                                    _targetBody: src
                                });
                            }
                            jet.alive = false;
                            gameState.conquestEffects.push({
                                x: jet.x, y: jet.y - 10, baseX: jet.x,
                                text: '‚Ü© RENVOI',
                                color: '#888888', age: 0, maxAge: 1.5
                            });
                        }
                    }
                    break; // un tir par cycle
                }
            }
        }
    }
}

function drawCleaners(ctx) {
    const t = gameState.time;
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    for (const cl of gameState.cleaners) {
        // Direction de mouvement
        const moveAngle = Math.atan2(cl.vy, cl.vx);

        ctx.save();
        ctx.translate(cl.x, cl.y);
        ctx.rotate(moveAngle);

        // Couleurs selon type
        const s = cl.size * scale;
        let fillColor, strokeColor, reactorC1, reactorC2, detectColor, accentColor;
        if (cl.type === 'green') {
            fillColor = 'rgba(70, 75, 65, 0.8)';
            strokeColor = 'rgba(100, 110, 90, 0.5)';
            accentColor = 'rgba(80, 220, 80, 0.7)';
            reactorC1 = 'rgba(60, 180, 80, 0.4)';
            reactorC2 = 'rgba(40, 120, 50, 0.15)';
            detectColor = 'rgba(60, 180, 60, 0.06)';
        } else if (cl.type === 'dark') {
            fillColor = 'rgba(55, 55, 65, 0.8)';
            strokeColor = 'rgba(80, 80, 100, 0.5)';
            accentColor = 'rgba(140, 140, 170, 0.7)';
            reactorC1 = 'rgba(90, 90, 130, 0.4)';
            reactorC2 = 'rgba(50, 50, 80, 0.15)';
            detectColor = 'rgba(100, 100, 130, 0.06)';
        } else {
            fillColor = 'rgba(85, 60, 55, 0.8)';
            strokeColor = 'rgba(120, 80, 70, 0.5)';
            accentColor = 'rgba(220, 70, 60, 0.7)';
            reactorC1 = 'rgba(200, 80, 50, 0.4)';
            reactorC2 = 'rgba(150, 40, 30, 0.15)';
            detectColor = 'rgba(200, 60, 50, 0.06)';
        }

        // Corps du vaisseau (d√©taill√©)
        ctx.fillStyle = fillColor;
        ctx.beginPath();
        ctx.moveTo(s * 1.8, 0);           // Nez
        ctx.lineTo(s * 0.6, -s * 0.3);    // Avant haut
        ctx.lineTo(-s * 0.2, -s * 0.9);   // Aile haute
        ctx.lineTo(-s * 0.8, -s * 0.7);   // Arri√®re aile haute
        ctx.lineTo(-s * 0.6, -s * 0.2);   // Jonction haute
        ctx.lineTo(-s, 0);                 // Arri√®re centre
        ctx.lineTo(-s * 0.6, s * 0.2);    // Jonction basse
        ctx.lineTo(-s * 0.8, s * 0.7);    // Arri√®re aile basse
        ctx.lineTo(-s * 0.2, s * 0.9);    // Aile basse
        ctx.lineTo(s * 0.6, s * 0.3);     // Avant bas
        ctx.closePath();
        ctx.fill();

        // Contour lumineux
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 1 * scale;
        ctx.stroke();

        // Cockpit (bulle centrale avec touche de couleur)
        ctx.fillStyle = 'rgba(200,220,255,0.2)';
        ctx.beginPath();
        ctx.ellipse(s * 0.5, 0, s * 0.4, s * 0.2, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = accentColor;
        ctx.beginPath();
        ctx.ellipse(s * 0.5, 0, s * 0.25, s * 0.12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bandes de couleur sur les ailes
        ctx.strokeStyle = accentColor;
        ctx.lineWidth = 1.5 * scale;
        ctx.beginPath();
        ctx.moveTo(-s * 0.1, -s * 0.6);
        ctx.lineTo(-s * 0.5, -s * 0.65);
        ctx.moveTo(-s * 0.1, s * 0.6);
        ctx.lineTo(-s * 0.5, s * 0.65);
        ctx.stroke();

        // Lumi√®res d'aile clignotantes
        const blink = Math.sin(t * 5 + cl.angle * 10) > 0.3 ? 1 : 0.2;
        ctx.fillStyle = accentColor.replace(/[\d.]+\)$/, (blink * 0.8) + ')');
        ctx.beginPath();
        ctx.arc(-s * 0.2, -s * 0.7, s * 0.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(-s * 0.2, s * 0.7, s * 0.15, 0, Math.PI * 2);
        ctx.fill();

        // R√©acteur (lueur arri√®re avec tra√Æn√©e)
        const gReactor = ctx.createRadialGradient(-s, 0, 0, -s, 0, s * 2);
        gReactor.addColorStop(0, reactorC1);
        gReactor.addColorStop(0.4, reactorC2);
        gReactor.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gReactor;
        ctx.beginPath();
        ctx.arc(-s, 0, s * 2, 0, Math.PI * 2);
        ctx.fill();

        // Tra√Æn√©e de propulsion
        ctx.globalAlpha = 0.15;
        ctx.fillStyle = reactorC1;
        for (let ti = 1; ti <= 3; ti++) {
            const trailS = s * (0.3 / ti);
            ctx.beginPath();
            ctx.arc(-s * (1 + ti * 0.8), 0, trailS, 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        ctx.restore();

        // Cercle de d√©tection ‚Äî LOD mid+ (pulsant)
        if (gameState.lod >= 1) {
            const dPulse = 0.5 + Math.sin(t * 2 + cl.angle) * 0.5;
            ctx.strokeStyle = detectColor;
            ctx.lineWidth = 0.5 + dPulse * 0.5;
            ctx.setLineDash([4 + dPulse * 2, 8 - dPulse * 2]);
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);

            // Remplissage subtil
            ctx.fillStyle = detectColor.replace('0.06', '0.02');
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange, 0, Math.PI * 2);
            ctx.fill();
        }

        // Pulsation d'alerte ‚Äî LOD high
        if (gameState.lod >= 2) {
            const pulse = Math.sin(t * 3) * 0.5 + 0.5;
            const pulseColor = cl.type === 'green' ? `rgba(50,255,50,${0.03*pulse})` :
                               cl.type === 'dark' ? `rgba(120,120,150,${0.03*pulse})` :
                               `rgba(255,50,50,${0.03*pulse})`;
            ctx.fillStyle = pulseColor;
            ctx.beginPath();
            ctx.arc(cl.x, cl.y, cl.detectionRange * 0.3, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INTELLIGENCE ARTIFICIELLE
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateAI(dt) {
    const difficulty = gameState.config.difficulty;

    for (const player of gameState.players) {
        if (player.isHuman || !player.alive) continue;
        if (player.bodies.length === 0) continue;

        // IA sacrifice pour multiplicit√©
        if (player.multiSacrifice === 0 && player.multiTier < 10) {
            player.multiSacrifice = 15 + Math.floor(gameRandom() * 20);
        }
        // IA : achat tech
        if (player.totalSpores > 2000 && gameRandom() < 0.03) {
            const _br = ['homing','tenacity','mimicry'][Math.floor(gameRandom()*3)];
            if (player.tech[_br] < 10) buyTech(player, _br);
        }

        // IA : gestion nids/biomes (v√©rifier √† chaque frame, pas seulement au timer)
        for (const body of player.bodies) {
            if (body.buildMode === 'off' && body.spores > body.maxSpores * 0.7) {
                // Activer un mode selon la strat√©gie : plus de nids si peu de plan√®tes, biomes sinon
                body.buildMode = player.bodies.length < 4 ? 'nid' : (gameRandom() > 0.5 ? 'nid' : 'biome');
            }
        }

        player.aiTimer -= dt;
        if (player.aiTimer > 0) continue;

        // Reset timer
        player.aiTimer = player.aiCooldown + gameRandom() * player.aiCooldown * 0.5;

        // D√©cider d'une action
        if (difficulty === 'easy') aiActionEasy(player);
        else if (difficulty === 'normal') aiActionNormal(player);
        else aiActionBrutal(player);
    }
}

// ‚îÄ‚îÄ IA Facile : cible al√©atoire, pas d'anticipation ‚îÄ‚îÄ
function aiActionEasy(player) {
    // Choisir un astre source avec des spores
    const sources = player.bodies.filter(b => b.spores > 20);
    if (sources.length === 0) return;
    const source = sources[Math.floor(gameRandom() * sources.length)];

    // Choisir une cible al√©atoire (neutre ou ennemie)
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;
    const target = targets[Math.floor(gameRandom() * targets.length)];

    aiLaunchAt(source, target, player);
}

// ‚îÄ‚îÄ IA Normale : √©value les cibles, interception basique ‚îÄ‚îÄ
function aiActionNormal(player) {
    const sources = player.bodies.filter(b => b.spores > 30);
    if (sources.length === 0) return;

    // √âvaluer les cibles
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;

    let bestTarget = null;
    let bestScore = -Infinity;

    for (const target of targets) {
        // Trouver la source la plus proche
        let minDist = Infinity;
        let closestSource = null;
        for (const src of sources) {
            const dx = target.x - src.x;
            const dy = target.y - src.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < minDist) { minDist = dist; closestSource = src; }
        }

        // Score : Flore haute + Faune faible + proximit√©
        const score = (target.flore || 0) * 2
            - (target.faune || 0) * 1
            - minDist * 0.05
            + (target.owner === null ? 50 : 0); // pr√©f√©rer les neutres

        if (score > bestScore) {
            bestScore = score;
            bestTarget = target;
        }
    }

    if (!bestTarget) return;

    // Trouver la meilleure source pour cette cible
    let bestSource = sources[0];
    let bestDist = Infinity;
    for (const src of sources) {
        const dx = bestTarget.x - src.x;
        const dy = bestTarget.y - src.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < bestDist) { bestDist = dist; bestSource = src; }
    }

    aiLaunchAt(bestSource, bestTarget, player);
}

// ‚îÄ‚îÄ IA Brutale : interception parfaite, coordination, micro-gestion ‚îÄ‚îÄ
function aiActionBrutal(player) {
    const sources = player.bodies.filter(b => b.spores > 25);
    if (sources.length === 0) return;

    // √âvaluer les cibles avec anticipation orbitale
    const targets = gameState.allBodies.filter(b =>
        b.owner !== player.id && b.type !== 'sun'
    );
    if (targets.length === 0) return;

    let bestTarget = null;
    let bestScore = -Infinity;

    for (const target of targets) {
        let minDist = Infinity;
        for (const src of sources) {
            const dx = target.x - src.x;
            const dy = target.y - src.y;
            minDist = Math.min(minDist, Math.sqrt(dx * dx + dy * dy));
        }

        // Score avanc√©
        const floreFactor = (target.flore || 0) * 3;
        const faunePenalty = (target.faune || 0) * 0.5;
        const distPenalty = minDist * 0.03;
        const ownerBonus = target.owner === null ? 40 : 20;
        const sporePenalty = (target.spores || 0) * 0.3;

        // Bonus si c'est un astre du joueur humain (agressif)
        const humanBonus = (target.owner !== null && target.owner !== player.id && gameState.players[target.owner]?.isHuman) ? 60 : 0;

        const score = floreFactor - faunePenalty - distPenalty + ownerBonus - sporePenalty + humanBonus;

        if (score > bestScore) {
            bestScore = score;
            bestTarget = target;
        }
    }

    if (!bestTarget) return;

    // Coordination : lancer depuis plusieurs sources si possible
    const attackSources = [];
    for (const src of sources) {
        const dx = bestTarget.x - src.x;
        const dy = bestTarget.y - src.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < 1500) attackSources.push({ src, dist });
    }

    // Trier par distance
    attackSources.sort((a, b) => a.dist - b.dist);

    // Lancer depuis les 1 √† 3 sources les plus proches
    const count = Math.min(attackSources.length, 1 + Math.floor(gameRandom() * 3));
    for (let i = 0; i < count; i++) {
        const src = attackSources[i].src;
        // Garder une r√©serve d√©fensive (30% des spores)
        if (src.spores < 40) continue;
        aiLaunchAt(src, bestTarget, player);
    }
}

// ‚îÄ‚îÄ Lancement IA avec anticipation d'orbite ‚îÄ‚îÄ
function aiLaunchAt(source, target, player) {
    // Pr√©dire la position future de la cible
    const dx = target.x - source.x;
    const dy = target.y - source.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    const speed = 20 + player.stats.velocity * 6;
    const travelTime = dist / speed * 0.4; // estimation grossi√®re

    // Anticiper l'orbite (seulement IA normale et brutale)
    let futureX = target.x;
    let futureY = target.y;

    if (gameState.config.difficulty !== 'easy' && target.parent) {
        const futureAngle = target.angle + target.orbitSpeed * travelTime;
        futureX = target.parent.x + Math.cos(futureAngle) * target.orbitRadius;
        futureY = target.parent.y + Math.sin(futureAngle) * target.orbitRadius;

        // IA Brutale : anticiper aussi l'orbite du parent (soleil)
        if (gameState.config.difficulty === 'brutal' && target.parent.parent) {
            // Le parent est une plan√®te, son parent est un soleil
            const parentFutureAngle = target.parent.angle + target.parent.orbitSpeed * travelTime;
            const parentFutureX = target.parent.parent.x + Math.cos(parentFutureAngle) * target.parent.orbitRadius;
            const parentFutureY = target.parent.parent.y + Math.sin(parentFutureAngle) * target.parent.orbitRadius;
            futureX = parentFutureX + Math.cos(futureAngle) * target.orbitRadius;
            futureY = parentFutureY + Math.sin(futureAngle) * target.orbitRadius;
        } else if (gameState.config.difficulty === 'brutal' && target.parent.orbitRadius) {
            // Le parent est un soleil qui orbite le trou noir
            const sunFutureAngle = target.parent.angle + target.parent.orbitSpeed * travelTime;
            const sunFutureX = Math.cos(sunFutureAngle) * target.parent.orbitRadius;
            const sunFutureY = Math.sin(sunFutureAngle) * target.parent.orbitRadius;
            futureX = sunFutureX + Math.cos(futureAngle) * target.orbitRadius;
            futureY = sunFutureY + Math.sin(futureAngle) * target.orbitRadius;
        }
    }

    const aimDx = futureX - source.x;
    const aimDy = futureY - source.y;
    const aimLen = Math.sqrt(aimDx * aimDx + aimDy * aimDy);
    if (aimLen < 5) return;

    launchJet(source, aimDx / aimLen, aimDy / aimLen);
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// EFFETS VISUELS ‚Äî Impacts
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function spawnImpact(x, y, color) {
    const particles = [];
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
        const speed = 30 + Math.random() * 50;
        particles.push({
            x: x, y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.5 + Math.random() * 0.5,
            age: 0,
            size: 1 + Math.random() * 2
        });
    }
    gameState.impactEffects.push({
        x: x, y: y, color: color,
        shockwave: 0,
        particles: particles,
        age: 0, maxAge: 1.2
    });
}

function updateImpacts(dt) {
    for (let i = gameState.impactEffects.length - 1; i >= 0; i--) {
        const imp = gameState.impactEffects[i];
        imp.age += dt;
        imp.shockwave += dt * 80;

        for (const p of imp.particles) {
            p.age += dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.95;
            p.vy *= 0.95;
        }

        if (imp.age >= imp.maxAge) gameState.impactEffects.splice(i, 1);
    }
}

function drawImpacts(ctx) {
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    for (const imp of gameState.impactEffects) {
        const progress = imp.age / imp.maxAge;
        const alpha = 1 - progress;

        // Onde de choc
        ctx.strokeStyle = imp.color + hexAlpha(alpha * 0.5);
        ctx.lineWidth = 2 * scale * (1 - progress);
        ctx.beginPath();
        ctx.arc(imp.x, imp.y, imp.shockwave, 0, Math.PI * 2);
        ctx.stroke();

        // Flash central
        if (progress < 0.2) {
            const flashA = (1 - progress / 0.2) * 0.5;
            const gFlash = ctx.createRadialGradient(imp.x, imp.y, 0, imp.x, imp.y, 15 * scale);
            gFlash.addColorStop(0, '#FFFFFF' + hexAlpha(flashA));
            gFlash.addColorStop(0.5, imp.color + hexAlpha(flashA * 0.5));
            gFlash.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gFlash;
            ctx.beginPath();
            ctx.arc(imp.x, imp.y, 15 * scale, 0, Math.PI * 2);
            ctx.fill();
        }

        // Particules √©clats
        for (const p of imp.particles) {
            if (p.age >= p.life) continue;
            const pAlpha = (1 - p.age / p.life) * 0.8;
            const pSize = p.size * scale * (1 - p.age / p.life);

            ctx.fillStyle = '#FFFFFF' + hexAlpha(pAlpha);
            ctx.beginPath();
            ctx.arc(p.x, p.y, pSize, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = imp.color + hexAlpha(pAlpha * 0.5);
            ctx.beginPath();
            ctx.arc(p.x, p.y, pSize + 1.5 * scale, 0, Math.PI * 2);
            ctx.fill();
        }
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// EFFETS VISUELS ‚Äî Conqu√™te & √âclosion
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateConquestEffects(dt) {
    // Textes flottants (style MMO : empilement sans superposition)
    for (let i = gameState.conquestEffects.length - 1; i >= 0; i--) {
        const e = gameState.conquestEffects[i];
        e.age += dt;

        // Vitesse de mont√©e : rapide au d√©but, puis ralentit
        if (e.age < 0.3) {
            e.y -= 80 * dt; // burst initial rapide
        } else {
            e.y -= 12 * dt; // lent ensuite
        }

        if (e.age >= e.maxAge) gameState.conquestEffects.splice(i, 1);
    }

    // Pousser les anciens vers le haut quand un nouveau appara√Æt au m√™me endroit
    const effects = gameState.conquestEffects;
    const spacing = 18;
    for (let i = effects.length - 1; i >= 0; i--) {
        for (let j = i - 1; j >= 0; j--) {
            // M√™me zone horizontale ?
            if (Math.abs(effects[i].baseX - effects[j].baseX) < 30) {
                const gap = effects[i].y - effects[j].y;
                if (gap > -spacing) {
                    effects[j].y = effects[i].y - spacing;
                }
            }
        }
    }
    // √âclosions
    for (let i = gameState.bloomEffects.length - 1; i >= 0; i--) {
        const e = gameState.bloomEffects[i];
        e.age += dt;
        if (e.age >= e.maxAge) gameState.bloomEffects.splice(i, 1);
    }
}

function drawConquestEffects(ctx) {
    const z = gameState.camera.zoom;
    const scale = Math.max(1, 1 / z);

    // √âclosions (cercle expansif)
    for (const e of gameState.bloomEffects) {
        const progress = e.age / e.maxAge;
        const r = e.body.radius * (1 + progress * 3);
        const alpha = (1 - progress) * 0.4;
        ctx.strokeStyle = e.color + hexAlpha(alpha);
        ctx.lineWidth = 2 * scale;
        ctx.beginPath();
        ctx.arc(e.body.x, e.body.y, r, 0, Math.PI * 2);
        ctx.stroke();

        // Flash interne
        if (progress < 0.3) {
            const flashAlpha = (1 - progress / 0.3) * 0.3;
            const gFlash = ctx.createRadialGradient(e.body.x, e.body.y, 0, e.body.x, e.body.y, e.body.radius);
            gFlash.addColorStop(0, e.color + hexAlpha(flashAlpha));
            gFlash.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = gFlash;
            ctx.beginPath();
            ctx.arc(e.body.x, e.body.y, e.body.radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    // Textes flottants
    for (const e of gameState.conquestEffects) {
        const alpha = 1 - (e.age / e.maxAge);
        ctx.font = (11 * scale) + 'px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillStyle = e.color + hexAlpha(alpha);
        ctx.fillText(e.text, e.x, e.y);
    }
}

function drawSporeCountOnBodies(ctx) {
    const z = gameState.camera.zoom;
    if (z < 0.4) return; // trop d√©zoom√©, pas lisible
    const scale = Math.max(1, 0.8 / z);

    const bodies = gameState.allBodies;
    for (const body of bodies) {
        if (body.owner === null) continue;
        if (body.spores < 1) continue;
        const col = gameState.players[body.owner]?.color || '#FFF';
        ctx.font = (8 * scale) + 'px Orbitron';
        ctx.textAlign = 'center';
        ctx.fillStyle = col + 'BB';
        ctx.fillText(Math.floor(body.spores), body.x, body.y + body.radius + 10 * scale);
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// VICTOIRE / √âLIMINATION
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function checkVictoryAndElimination() {
    if (gameState.phase !== 'game') return;

    const totalBodies = gameState.planets.length + gameState.moons.length;

    for (const player of gameState.players) {
        if (!player.alive) continue;

        // Compter les astres
        const ownedCount = player.bodies.length;

        // V√©rifier √©limination
        if (ownedCount === 0) {
            const hasJets = gameState.jets.some(j => j.alive && j.owner === player.id);
            if (!hasJets) {
                player.alive = false;
                if (player.isLocal) {
                    showEndScreen(false);
                    return;
                }
            }
        }

        // V√©rifier victoire (80% de la masse)
        const pct = totalBodies > 0 ? ownedCount / totalBodies : 0;
        if (pct >= 0.8) {
            if (player.isLocal) {
                showEndScreen(true);
            } else {
                showEndScreen(false);
            }
            return;
        }
    }
}

function showEndScreen(isVictory) {
    gameState.phase = 'end';

    const title = document.getElementById('endTitle');
    title.textContent = isVictory ? 'VICTOIRE' : 'D√âFAITE';
    title.className = isVictory ? 'victory' : 'defeat';

    const sub = document.getElementById('endSubtitle');
    const human = gameState.players[localSlot()];
    const totalBodies = gameState.planets.length + gameState.moons.length;
    const ownedPct = Math.round((human.bodies.length / totalBodies) * 100);
    sub.textContent = isVictory
        ? 'Vous contr√¥lez ' + ownedPct + '% de l\'univers !'
        : 'Votre empire s\'est effondr√©...';

    const stats = gameState.gameStats;
    stats.timeElapsed = gameState.time;
    const minutes = Math.floor(stats.timeElapsed / 60);
    const seconds = Math.floor(stats.timeElapsed % 60);

    document.getElementById('endStats').innerHTML = `
        <div class="end-stat-row"><span>Astres conquis</span><span class="end-stat-val">${stats.bodiesConquered}</span></div>
        <div class="end-stat-row"><span>Jets lanc√©s</span><span class="end-stat-val">${stats.jetsLaunched}</span></div>
        <div class="end-stat-row"><span>Jets neutralis√©s</span><span class="end-stat-val">${stats.jetsNeutralized}</span></div>
        <div class="end-stat-row"><span>Spores produites</span><span class="end-stat-val">${Math.floor(stats.sporesProduced)}</span></div>
        <div class="end-stat-row"><span>Astres poss√©d√©s</span><span class="end-stat-val">${human.bodies.length} / ${totalBodies}</span></div>
        <div class="end-stat-row"><span>Dur√©e</span><span class="end-stat-val">${minutes}m ${seconds}s</span></div>
    `;

    document.getElementById('endScreen').classList.add('active');
    stopAmbiance();
    if (isVictory) playVictorySound();
    else playDefeatSound();

    // Sauvegarder la partie dans Supabase
    saveGame(isVictory, stats, human, totalBodies);
}

async function saveGame(isVictory, stats, human, totalBodies) {
    if (!currentUser) return;
    try {
        await _supa.from('games').insert({
            player_id: currentUser.id,
            won: isVictory,
            score: human.bodies.length,
            planets_captured: stats.bodiesConquered,
            duration_seconds: Math.floor(stats.timeElapsed),
            players_count: gameState.players.length,
            suns_count: gameState.suns.length
        });
    } catch (e) {
        console.warn('Erreur sauvegarde partie:', e);
    }
}

function hideEndScreen() {
    document.getElementById('endScreen').classList.remove('active');
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MES PLAN√àTES ‚Äî Liste lat√©rale + suivi cam√©ra
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let followingBody = null;

function selectMotherPlanet(sun, planet) {
    const slot = localSlot();
    const human = gameState.players[slot];
    if (!human) return;

    const nid = human.nidification[sun.name];
    if (!nid || nid.progress < 2500) return;

    // Marquer la plan√®te m√®re
    nid.motherPlanet = planet.name;
    planet.isMotherPlanet = true;

    // Rendre invincible : plan√®te m√®re + ses lunes
    planet.invincible = true;
    for (const moon of planet.moons) {
        if (moon.owner === slot) moon.invincible = true;
    }

    // Aspirer tous les spores du syst√®me vers la plan√®te m√®re
    performNidification(sun, planet, slot);

    // √âv√©nement journal
    addEvent('build', 'üëë', 'Plan√®te m√®re : ' + planet.name + ' (syst√®me ' + sun.name + ')', planet, human.color);

    // Cacher le choix
    document.getElementById('nidChoose').style.display = 'none';
    document.getElementById('nidPlanetList').dataset.sunName = '';
}

function performNidification(sun, motherPlanet, ownerSlot) {
    let totalSpores = 0;
    for (const planet of sun.planets) {
        if (planet.owner !== ownerSlot) continue;
        if (planet !== motherPlanet) {
            totalSpores += planet.spores;
            planet.spores = 0;
        }
        for (const moon of planet.moons) {
            if (moon.owner !== ownerSlot) continue;
            totalSpores += moon.spores;
            moon.spores = 0;
        }
    }
    motherPlanet.spores += totalSpores;

    addEvent('build', 'üè∞', 'Nidification ' + sun.name + ' : ' + Math.floor(totalSpores) + ' spores rassembl√©es', motherPlanet, gameState.players[ownerSlot]?.color);
}

function updateNidPanel() {
    const panel = document.getElementById('nidPanel');
    const slot = localSlot();
    const human = gameState.players[slot];
    if (!human || !human.alive) { panel.style.display = 'none'; return; }

    // Chercher le premier syst√®me complet sans plan√®te m√®re
    let targetSun = null;
    for (const sun of gameState.suns) {
        if (!isSystemComplete(sun, slot)) continue;
        const nid = human.nidification[sun.name];
        if (nid && nid.motherPlanet) continue;
        targetSun = sun;
        break;
    }

    if (!targetSun) { panel.style.display = 'none'; return; }

    panel.style.display = 'block';
    document.getElementById('nidSystemName').textContent = '‚òÄ ' + targetSun.name;

    // Init nid data si besoin
    if (!human.nidification[targetSun.name]) {
        human.nidification[targetSun.name] = { progress: 0, sacrifice: 0, sunName: targetSun.name };
    }
    const nid = human.nidification[targetSun.name];
    const cost = 2500;

    // Barre de progression
    const pct = Math.min(100, (nid.progress / cost) * 100);
    document.getElementById('nidBar').style.width = pct + '%';
    document.getElementById('nidInfo').textContent = Math.floor(nid.progress) + ' / ' + cost + ' spores';

    // Choix plan√®te m√®re quand jauge pleine
    const chooseEl = document.getElementById('nidChoose');
    if (nid.progress >= cost) {
        chooseEl.style.display = 'block';
        const listEl = document.getElementById('nidPlanetList');
        const planets = targetSun.planets.filter(p => p.owner === slot);
        if (listEl.dataset.sunName !== targetSun.name) {
            listEl.dataset.sunName = targetSun.name;
            listEl.innerHTML = '';
            for (const p of planets) {
                const btn = document.createElement('span');
                btn.className = 'nid-planet-btn';
                btn.textContent = p.name;
                btn.addEventListener('click', () => selectMotherPlanet(targetSun, p));
                listEl.appendChild(btn);
            }
        }
    } else {
        chooseEl.style.display = 'none';
    }
}

function isSystemComplete(sun, ownerID) {
    for (const planet of sun.planets) {
        if (planet.owner !== ownerID) return false;
        for (const moon of planet.moons) {
            if (moon.owner !== ownerID) return false;
        }
    }
    return sun.planets.length > 0;
}

function updateMyPlanets() {
    if (gameState.phase !== 'game') return;
    const human = gameState.players[localSlot()];
    if (!human) return;

    const container = document.getElementById('myPlanetsList');
    const panel = document.getElementById('myPlanets');
    panel.style.display = 'block';

    // R√©cup√©rer les astres poss√©d√©s
    const slot = localSlot();
    const myBodies = gameState.allBodies.filter(b => b.owner === slot);

    // Grouper par syst√®me solaire
    const groups = {};
    const groupSuns = {};
    for (const body of myBodies) {
        let sunRef, sunName;
        if (body.type === 'planet') {
            sunRef = body.parent;
            sunName = body.parent.name;
        } else {
            sunRef = body.parent.parent || null;
            sunName = sunRef ? sunRef.name : 'Inconnu';
        }
        if (!groups[sunName]) { groups[sunName] = []; groupSuns[sunName] = sunRef; }
        groups[sunName].push(body);
    }

    // Ne reconstruire que si la liste a chang√©
    const _hash = myBodies.map(b => b.name).join(',');
    if (container.dataset.hash !== _hash) {
        container.dataset.hash = _hash;
        container.innerHTML = '';

        for (const sunName of Object.keys(groups)) {
            const bodies = groups[sunName];

            const groupEl = document.createElement('div');
            groupEl.className = 'mp-sun-group';

            const sunLabel = document.createElement('div');
            sunLabel.className = 'mp-sun-label';
            const sunRef = groupSuns[sunName];
            const complete = sunRef && isSystemComplete(sunRef, slot);
            sunLabel.title = complete ? 'Syst√®me complet ! Bonus +3% de production actif' : 'Colonisez toutes les plan√®tes et lunes de ce syst√®me pour un bonus +3% de production';
            sunLabel.innerHTML = '\u2600 ' + sunName + (complete ? '<span class="sys-complete" title="Syst√®me complet : +3% de vitesse de production de spores sur toutes les plan√®tes et lunes"> ‚òÖ +3%</span>' : '');
            groupEl.appendChild(sunLabel);

            // S√©lecteur Nid/Biome/Off pour tout le syst√®me
            const buildRow = document.createElement('div');
            buildRow.style.cssText = 'display:flex; gap:4px; padding:2px 4px 4px; align-items:center;';
            ['off','nid','biome'].forEach(mode => {
                const btn = document.createElement('span');
                btn.textContent = mode === 'off' ? 'Off' : mode === 'nid' ? 'Nid' : 'Biome';
                btn.style.cssText = 'font-size:8px; padding:1px 5px; border-radius:3px; cursor:pointer; border:1px solid rgba(100,70,180,0.3); color:rgba(200,200,220,0.6); background:rgba(100,70,180,0.1); font-family:Exo 2,sans-serif; transition:all 0.2s;';
                btn.dataset.mode = mode;
                btn.addEventListener('click', () => {
                    for (const b of bodies) {
                        b.buildMode = mode;
                        if (mode === 'off') b.buildProgress = 0;
                    }
                    buildRow.querySelectorAll('span').forEach(s => {
                        s.style.background = 'rgba(100,70,180,0.1)';
                        s.style.color = 'rgba(200,200,220,0.6)';
                        s.style.borderColor = 'rgba(100,70,180,0.3)';
                    });
                    if (mode === 'nid') { btn.style.background = 'rgba(34,197,94,0.3)'; btn.style.color = '#4ADE80'; btn.style.borderColor = 'rgba(34,197,94,0.6)'; }
                    else if (mode === 'biome') { btn.style.background = 'rgba(59,130,246,0.3)'; btn.style.color = '#60A5FA'; btn.style.borderColor = 'rgba(59,130,246,0.6)'; }
                    else { btn.style.background = 'rgba(100,70,180,0.25)'; btn.style.color = '#C8A0FF'; btn.style.borderColor = 'rgba(100,70,180,0.5)'; }
                });
                buildRow.appendChild(btn);
            });
            groupEl.appendChild(buildRow);

            const rowEl = document.createElement('div');
            rowEl.className = 'mp-row';

            // Trier : plan√®te m√®re en premier
            const nidData = human.nidification[sunName];
            bodies.sort((a, b) => {
                if (a.isMotherPlanet) return -1;
                if (b.isMotherPlanet) return 1;
                return 0;
            });

            for (const body of bodies) {
                const item = document.createElement('div');
                item.className = 'mp-item';
                item.dataset.bodyName = body.name;

                // Bouton Nidification si plan√®te m√®re
                if (body.isMotherPlanet && nidData && nidData.motherPlanet === body.name) {
                    const nidBtn = document.createElement('div');
                    nidBtn.className = 'mp-mother-badge';
                    nidBtn.textContent = 'üëë NIDIFIER';
                    nidBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const sunRef = groupSuns[sunName];
                        if (sunRef) performNidification(sunRef, body, slot);
                    });
                    item.appendChild(nidBtn);
                }

                // Nom au-dessus
                const nameEl = document.createElement('div');
                nameEl.className = 'mp-name';
                nameEl.textContent = (body.isMotherPlanet ? 'üëë ' : '') + body.name;
                item.appendChild(nameEl);

                // Badge type
                const badge = document.createElement('div');
                badge.className = 'mp-type-badge ' + (body.type === 'planet' ? 'planet-badge' : 'moon-badge');
                badge.textContent = body.type === 'planet' ? 'PLAN\u00c8TE' : 'LUNE';
                item.appendChild(badge);

                // Mini-aper√ßu
                if (body._texture) {
                    const preview = document.createElement('canvas');
                    const size = 38;
                    preview.width = size;
                    preview.height = size;
                    const pctx = preview.getContext('2d');
                    pctx.drawImage(body._texture, 0, 0, size, size);
                    item.appendChild(preview);
                } else {
                    const dot = document.createElement('div');
                    dot.style.cssText = 'width:30px;height:30px;border-radius:50%;background:' + human.color;
                    item.appendChild(dot);
                }

                // Compteur spores
                const sporesEl = document.createElement('div');
                sporesEl.className = 'mp-spores';
                sporesEl.textContent = Math.floor(body.spores);
                item.appendChild(sporesEl);

                // Clic ‚Üí centrer la cam√©ra
                item.addEventListener('click', () => {
                    document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active'));
                    item.classList.add('active');
                    followingBody = body;
                    gameState.camera.x = body.x;
                    gameState.camera.y = body.y;
                    gameState.camera.zoom = Math.max(gameState.camera.zoom, 0.8);
                    openCodex(body);
                });

                rowEl.appendChild(item);
            }

            groupEl.appendChild(rowEl);
            container.appendChild(groupEl);
        }
    } else {
        // Mettre √† jour badges syst√®me complet
        const sunLabels = container.querySelectorAll('.mp-sun-label');
        let gIdx = 0;
        for (const sunName of Object.keys(groups)) {
            if (gIdx < sunLabels.length) {
                const sunRef = groupSuns[sunName];
                const complete = sunRef && isSystemComplete(sunRef, 0);
                const hasSpan = sunLabels[gIdx].querySelector('.sys-complete');
                if (complete && !hasSpan) {
                    sunLabels[gIdx].innerHTML = '\u2600 ' + sunName + '<span class="sys-complete" title="Syst√®me complet : +3% de vitesse de production de spores sur toutes les plan√®tes et lunes"> \u2605 +3%</span>';
                } else if (!complete && hasSpan) {
                    sunLabels[gIdx].innerHTML = '\u2600 ' + sunName;
                }
            }
            gIdx++;
        }
        // Mettre √† jour juste les spores et l'√©tat actif
        const items = container.querySelectorAll('.mp-item');
        let idx = 0;
        for (const sunName of Object.keys(groups)) {
            for (const body of groups[sunName]) {
                if (idx < items.length) {
                    const spEl = items[idx].querySelector('.mp-spores');
                    if (spEl) spEl.textContent = Math.floor(body.spores);
                    if (followingBody === body) items[idx].classList.add('active');
                    else items[idx].classList.remove('active');
                }
                idx++;
            }
        }
    }
}

function updateCameraFollow() {
    // Verrouillage cam√©ra pendant le tir
    if (gameState.launchCameraLock && gameState.launchSource) {
        const cam = gameState.camera;
        cam.x += (gameState.launchSource.x - cam.x) * 0.5;
        cam.y += (gameState.launchSource.y - cam.y) * 0.5;
        return;
    }
    if (!followingBody) return;
    // Arr√™ter le suivi uniquement si le body n'existe plus
    if (!followingBody) return;
    // Suivre en douceur
    const cam = gameState.camera;
    const lerp = 0.15;
    cam.x += (followingBody.x - cam.x) * lerp;
    cam.y += (followingBody.y - cam.y) * lerp;
}

// Arr√™ter le suivi si le joueur fait un panoramique
const _origSetupInput = setupInput;
const stopFollow = () => { followingBody = null; document.querySelectorAll('.mp-item.active').forEach(el => el.classList.remove('active')); };

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// AUDIO G√âN√âRATIF ‚Äî Web Audio API
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function initAudio() {
    if (gameState.audio.initialized) return;
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    gameState.audio.ctx = ac;

    // Master gain
    const master = ac.createGain();
    master.gain.value = gameState.audio.volume;
    master.connect(ac.destination);
    gameState.audio.masterGain = master;

    gameState.audio.initialized = true;
}

function ensureAudio() {
    if (!gameState.audio.initialized) initAudio();
    if (gameState.audio.ctx.state === 'suspended') {
        gameState.audio.ctx.resume();
    }
}

// ‚îÄ‚îÄ Ambiance spatiale (drone) ‚îÄ‚îÄ
function startAmbiance() {
    ensureAudio();
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;

    if (gameState.audio.ambDrone) return;

    // Drone basse (calme)
    const osc1 = ac.createOscillator();
    osc1.type = 'sine';
    osc1.frequency.value = 40;
    const gain1 = ac.createGain();
    gain1.gain.value = 0.06;

    // Sub harmonique
    const osc2 = ac.createOscillator();
    osc2.type = 'sine';
    osc2.frequency.value = 60;
    const gain2 = ac.createGain();
    gain2.gain.value = 0.03;

    // Drone tension (d√©sactiv√© au d√©part)
    const oscTension = ac.createOscillator();
    oscTension.type = 'sawtooth';
    oscTension.frequency.value = 55;
    const gainTension = ac.createGain();
    gainTension.gain.value = 0;
    const filterTension = ac.createBiquadFilter();
    filterTension.type = 'lowpass';
    filterTension.frequency.value = 200;
    filterTension.Q.value = 3;

    // LFO pour modulation
    const lfo = ac.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.15;
    const lfoGain = ac.createGain();
    lfoGain.gain.value = 5;
    lfo.connect(lfoGain);
    lfoGain.connect(osc1.frequency);

    // LFO tension (plus rapide)
    const lfoT = ac.createOscillator();
    lfoT.type = 'sine';
    lfoT.frequency.value = 0.4;
    const lfoTGain = ac.createGain();
    lfoTGain.gain.value = 8;
    lfoT.connect(lfoTGain);
    lfoTGain.connect(oscTension.frequency);

    // Filtre passe-bas
    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 120;
    filter.Q.value = 1;

    osc1.connect(gain1);
    osc2.connect(gain2);
    gain1.connect(filter);
    gain2.connect(filter);
    filter.connect(master);

    oscTension.connect(filterTension);
    filterTension.connect(gainTension);
    gainTension.connect(master);

    osc1.start();
    osc2.start();
    lfo.start();
    oscTension.start();
    lfoT.start();

    gameState.audio.ambDrone = { osc1, osc2, lfo, gain1, gain2, filter, oscTension, gainTension, filterTension, lfoT };
}

function stopAmbiance() {
    const drone = gameState.audio.ambDrone;
    if (!drone) return;
    try {
        drone.osc1.stop();
        drone.osc2.stop();
        drone.lfo.stop();
    } catch(e) {}
    gameState.audio.ambDrone = null;
}

// ‚îÄ‚îÄ Son de lancement de jet ‚îÄ‚îÄ
function playLaunchSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;
    const pitchVar = 0.85 + Math.random() * 0.3;

    const osc = ac.createOscillator();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(200 * pitchVar, t);
    osc.frequency.exponentialRampToValueAtTime(80 * pitchVar, t + 0.3);

    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.4);

    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.setValueAtTime(800, t);
    filter.frequency.exponentialRampToValueAtTime(200, t + 0.3);

    // Bruit granulaire
    const noise = ac.createBufferSource();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.3, ac.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * 0.5;
    noise.buffer = buf;
    const noiseGain = ac.createGain();
    noiseGain.gain.setValueAtTime(0.04, t);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.3);
    const noiseFilter = ac.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 400;
    noiseFilter.Q.value = 2;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(master);

    osc.start(t);
    osc.stop(t + 0.4);
    noise.start(t);
    noise.stop(t + 0.3);
}

// ‚îÄ‚îÄ Son de fusion (jet arrive sur astre ami) ‚îÄ‚îÄ
function playFusionSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    [260, 330, 390].forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t);
        gain.gain.linearRampToValueAtTime(0.05, t + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.02);
        osc.stop(t + 0.6);
    });
}

// ‚îÄ‚îÄ Son de conqu√™te (√©closion) ‚îÄ‚îÄ
function playConquestSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    // Accord ascendant
    [220, 277, 330, 440].forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.08);
        gain.gain.linearRampToValueAtTime(0.07, t + i * 0.08 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + 0.8);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.08);
        osc.stop(t + 0.9);
    });

    // Burst harmonique
    const noise = ac.createBufferSource();
    const buf = ac.createBuffer(1, ac.sampleRate * 0.2, ac.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1);
    noise.buffer = buf;
    const nGain = ac.createGain();
    nGain.gain.setValueAtTime(0.06, t);
    nGain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    const nFilter = ac.createBiquadFilter();
    nFilter.type = 'highpass';
    nFilter.frequency.value = 2000;
    noise.connect(nFilter);
    nFilter.connect(nGain);
    nGain.connect(master);
    noise.start(t);
    noise.stop(t + 0.2);
}

// ‚îÄ‚îÄ Son de neutralisation (collision de jets) ‚îÄ‚îÄ
function playNeutralizationSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;
    const pitchVar = 0.8 + Math.random() * 0.4;

    const osc = ac.createOscillator();
    osc.type = 'square';
    osc.frequency.setValueAtTime(100 * pitchVar, t);
    osc.frequency.exponentialRampToValueAtTime(40 * pitchVar, t + 0.15);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.08, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    const filter = ac.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 300;
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    osc.start(t);
    osc.stop(t + 0.2);
}

// ‚îÄ‚îÄ Son de vaisseau nettoyeur (ping) ‚îÄ‚îÄ
function playCleanerSound(cleanerX, cleanerY) {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    // Spatialisation simple (panoramique gauche/droite)
    const pan = ac.createStereoPanner ? ac.createStereoPanner() : null;
    if (pan) {
        const screenX = (cleanerX - gameState.camera.x) / (gameState.width / 2 / gameState.camera.zoom);
        pan.pan.value = Math.max(-1, Math.min(1, screenX * 0.8));
    }

    const osc = ac.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(1200, t);
    osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.04, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);

    osc.connect(gain);
    if (pan) { gain.connect(pan); pan.connect(master); }
    else { gain.connect(master); }
    osc.start(t);
    osc.stop(t + 0.15);
}

// ‚îÄ‚îÄ S√©quence victoire ‚îÄ‚îÄ
function playVictorySound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const notes = [262, 330, 392, 523, 659, 784];
    notes.forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.15);
        gain.gain.linearRampToValueAtTime(0.08, t + i * 0.15 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.15 + 0.5);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.15);
        osc.stop(t + i * 0.15 + 0.5);
    });
}

// ‚îÄ‚îÄ S√©quence d√©faite ‚îÄ‚îÄ
function playDefeatSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const notes = [392, 349, 330, 262, 220, 196];
    notes.forEach((freq, i) => {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        const gain = ac.createGain();
        gain.gain.setValueAtTime(0, t + i * 0.2);
        gain.gain.linearRampToValueAtTime(0.06, t + i * 0.2 + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, t + i * 0.2 + 0.6);
        osc.connect(gain);
        gain.connect(master);
        osc.start(t + i * 0.2);
        osc.stop(t + i * 0.2 + 0.6);
    });
}

// ‚îÄ‚îÄ Contr√¥le volume ‚îÄ‚îÄ
function setupVolumeControl() {
    const slider = document.getElementById('volSlider');
    const icon = document.getElementById('volToggle');

    slider.value = gameState.audio.volume * 100;

    slider.addEventListener('input', () => {
        gameState.audio.volume = parseInt(slider.value) / 100;
        if (gameState.audio.masterGain) {
            gameState.audio.masterGain.gain.value = gameState.audio.volume;
        }
        gameState.audio.muted = gameState.audio.volume === 0;
        icon.textContent = gameState.audio.muted ? 'üîá' : 'üîä';
    });

    icon.addEventListener('click', () => {
        gameState.audio.muted = !gameState.audio.muted;
        if (gameState.audio.masterGain) {
            gameState.audio.masterGain.gain.value = gameState.audio.muted ? 0 : gameState.audio.volume;
        }
        icon.textContent = gameState.audio.muted ? 'üîá' : 'üîä';
    });
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// MINIMAP
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawMinimap() {
    if (gameState.phase !== 'game' && gameState.phase !== 'paused') return;
    const mc = document.getElementById('minimapCanvas');
    const mctx = mc.getContext('2d');
    const size = 160;

    mctx.fillStyle = 'rgba(6, 8, 26, 0.9)';
    mctx.fillRect(0, 0, size, size);

    // Calcul de l'√©chelle : trouver l'√©tendue max
    let maxDist = 500;
    for (const s of gameState.suns) {
        const d = Math.sqrt(s.x * s.x + s.y * s.y) + s.orbitRadius + 500;
        if (d > maxDist) maxDist = d;
    }
    const scale = (size / 2 - 8) / maxDist;
    const cx = size / 2;
    const cy = size / 2;

    // Trou noir
    mctx.fillStyle = '#000';
    mctx.beginPath();
    mctx.arc(cx, cy, 3, 0, Math.PI * 2);
    mctx.fill();
    mctx.strokeStyle = 'rgba(100,40,180,0.3)';
    mctx.lineWidth = 0.5;
    mctx.stroke();

    // Soleils
    for (const s of gameState.suns) {
        mctx.fillStyle = s.color + '80';
        mctx.beginPath();
        mctx.arc(cx + s.x * scale, cy + s.y * scale, 2, 0, Math.PI * 2);
        mctx.fill();
    }

    // Plan√®tes et lunes
    const bodies = gameState.allBodies;
    for (const b of bodies) {
        if (b.owner !== null && b.owner !== undefined) {
            mctx.fillStyle = gameState.players[b.owner]?.color || '#666';
        } else {
            mctx.fillStyle = 'rgba(150,150,170,0.4)';
        }
        const r = b.type === 'planet' ? 1.5 : 0.8;
        mctx.beginPath();
        mctx.arc(cx + b.x * scale, cy + b.y * scale, r, 0, Math.PI * 2);
        mctx.fill();
    }

    // Jets
    for (const j of gameState.jets) {
        if (!j.alive) continue;
        mctx.fillStyle = j.color;
        mctx.beginPath();
        mctx.arc(cx + j.x * scale, cy + j.y * scale, 1, 0, Math.PI * 2);
        mctx.fill();
    }

    // Nettoyeurs
    for (const cl of gameState.cleaners) {
        mctx.fillStyle = 'rgba(255, 60, 60, 0.6)';
        mctx.fillRect(cx + cl.x * scale - 1, cy + cl.y * scale - 1, 2, 2);
    }

    // Rectangle de vue
    const cam = gameState.camera;
    const vw = gameState.width / cam.zoom * scale;
    const vh = gameState.height / cam.zoom * scale;
    const vx = cx + cam.x * scale - vw / 2;
    const vy = cy + cam.y * scale - vh / 2;
    mctx.strokeStyle = 'rgba(200, 160, 255, 0.5)';
    mctx.lineWidth = 1;
    mctx.strokeRect(vx, vy, vw, vh);
}

function setupMinimap() {
    const mc = document.getElementById('minimapCanvas');
    mc.addEventListener('click', (e) => {
        const rect = mc.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;

        let maxDist = 500;
        for (const s of gameState.suns) {
            const d = Math.sqrt(s.x * s.x + s.y * s.y) + s.orbitRadius + 500;
            if (d > maxDist) maxDist = d;
        }
        const scale = (80 - 8) / maxDist;
        const worldX = (mx - 80) / scale;
        const worldY = (my - 80) / scale;
        gameState.camera.x = worldX;
        gameState.camera.y = worldY;
        if (typeof followingBody !== 'undefined') followingBody = null;
    });
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// INDICATEURS HORS-√âCRAN
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawOffscreenIndicators() {
    if (gameState.phase !== 'game') return;
    const cam = gameState.camera;
    const w = gameState.width;
    const h = gameState.height;
    const ctx = gameState.ctx;
    const margin = 20;

    for (const jet of gameState.jets) {
        if (!jet.alive) continue;
        if (jet.owner === 0) continue; // pas nos propres jets

        // Convertir en coordonn√©es √©cran
        const sx = (jet.x - cam.x) * cam.zoom + w / 2;
        const sy = (jet.y - cam.y) * cam.zoom + h / 2;

        // Si visible, pas besoin d'indicateur
        if (sx >= 0 && sx <= w && sy >= 0 && sy <= h) continue;

        // Calculer le point sur le bord de l'√©cran
        const dx = sx - w / 2;
        const dy = sy - h / 2;
        const angle = Math.atan2(dy, dx);

        // Clamp sur le bord
        let ix = w / 2 + Math.cos(angle) * (w / 2 - margin);
        let iy = h / 2 + Math.sin(angle) * (h / 2 - margin);
        ix = Math.max(margin, Math.min(w - margin, ix));
        iy = Math.max(margin, Math.min(h - margin, iy));

        // Dessiner la fl√®che (hors transformation cam√©ra)
        ctx.save();
        ctx.translate(ix, iy);
        ctx.rotate(angle);

        ctx.fillStyle = jet.color + '90';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-4, -5);
        ctx.lineTo(-4, 5);
        ctx.closePath();
        ctx.fill();

        // Lueur
        ctx.fillStyle = jet.color + '20';
        ctx.beginPath();
        ctx.arc(0, 0, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
    }
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// TIMER DE PARTIE
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateGameTimer() {
    if (gameState.phase !== 'game') return;
    const elapsed = gameState.gameStats.timeElapsed;
    const min = Math.floor(elapsed / 60);
    const sec = Math.floor(elapsed % 60);
    const str = String(min).padStart(2, '0') + ':' + String(sec).padStart(2, '0');
    if (DOM.gameTimer) DOM.gameTimer.textContent = str;
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// TRANSITIONS & LOADING
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function fadeTransition(callback) {
    const fade = document.getElementById('screenFade');
    fade.classList.add('active');
    setTimeout(() => {
        callback();
        setTimeout(() => fade.classList.remove('active'), 50);
    }, 500);
}

function updateLoadingBar(pct, text) {
    document.getElementById('loadingBarFill').style.width = pct + '%';
    if (text) document.getElementById('loadingText').textContent = text;
}

function hideLoading() {
    document.getElementById('loadingScreen').classList.add('hidden');
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// AUDIO ‚Äî Tension adaptative & sons UI
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function updateAudioTension() {
    if (!gameState.audio.initialized || !gameState.audio.ambDrone) return;

    // Calculer la tension : jets ennemis proches de nos astres
    let tensionTarget = 0;
    const human = gameState.players[localSlot()];
    if (human) {
        for (const jet of gameState.jets) {
            if (!jet.alive || jet.owner === 0) continue;
            for (const body of human.bodies) {
                const dx = jet.x - body.x;
                const dy = jet.y - body.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < 300) {
                    tensionTarget += (300 - dist) / 300;
                }
            }
        }
    }
    tensionTarget = Math.min(1, tensionTarget);

    // Lerp vers la cible
    gameState.audio.tension += (tensionTarget - gameState.audio.tension) * 0.02;
    const t = gameState.audio.tension;

    // Appliquer la tension au drone
    const drone = gameState.audio.ambDrone;
    if (drone.gainTension) {
        drone.gainTension.gain.value = t * 0.04;
    }
    if (drone.filterTension) {
        drone.filterTension.frequency.value = 150 + t * 300;
    }
    // Acc√©l√©rer le LFO en tension
    if (drone.lfo) {
        drone.lfo.frequency.value = 0.15 + t * 0.3;
    }
}

function playClickSound() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;
    const t = ac.currentTime;

    const osc = ac.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, t);
    osc.frequency.exponentialRampToValueAtTime(400, t + 0.06);
    const gain = ac.createGain();
    gain.gain.setValueAtTime(0.05, t);
    gain.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    osc.connect(gain);
    gain.connect(master);
    osc.start(t);
    osc.stop(t + 0.08);
}

function updateOrbitHum() {
    if (!gameState.audio.initialized || gameState.audio.muted) return;
    const cam = gameState.camera;

    // Son d'orbite seulement quand tr√®s zoom√©
    if (cam.zoom < 2) {
        if (gameState.audio.orbitHum) {
            gameState.audio.orbitHumGain.gain.value = 0;
        }
        return;
    }

    const ac = gameState.audio.ctx;
    const master = gameState.audio.masterGain;

    // Cr√©er le hum si pas encore fait
    if (!gameState.audio.orbitHum) {
        const osc = ac.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 80;
        const gain = ac.createGain();
        gain.gain.value = 0;
        const filter = ac.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 150;
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(master);
        osc.start();
        gameState.audio.orbitHum = osc;
        gameState.audio.orbitHumGain = gain;
    }

    // Volume bas√© sur le zoom et la proximit√© d'une plan√®te
    let closestDist = Infinity;
    for (const p of gameState.planets) {
        const dx = p.x - cam.x;
        const dy = p.y - cam.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < closestDist) closestDist = dist;
    }

    const proxFactor = Math.max(0, 1 - closestDist / 200);
    const zoomFactor = Math.min(1, (cam.zoom - 2) / 3);
    const vol = proxFactor * zoomFactor * 0.015;
    gameState.audio.orbitHumGain.gain.value = vol;

    // Moduler la fr√©quence selon la plan√®te
    gameState.audio.orbitHum.frequency.value = 60 + proxFactor * 40;
}


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// √âCRAN TITRE ‚Äî Animation
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let _titleAnimPlayed = false;
function animateTitleScreen() {
    const title = document.getElementById('titleText');
    if (!_titleAnimPlayed) {
    const text = 'NEBULA CONQUEST';
    title.innerHTML = '';

    // Lettres anim√©es une par une
    for (let i = 0; i < text.length; i++) {
        const span = document.createElement('span');
        span.className = 'title-letter';
        span.textContent = text[i] === ' ' ? '\u00A0' : text[i];
        span.style.animationDelay = (i * 0.08) + 's';
        title.appendChild(span);
    }
    _titleAnimPlayed = true;
    }

    // Canvas √©toiles filantes en fond
    const canvas = document.getElementById('titleBgCanvas');
    if (!canvas) return;
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const ctx = canvas.getContext('2d');

    const stars = [];
    for (let i = 0; i < 80; i++) {
        stars.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 1.5 + 0.3,
            alpha: Math.random() * 0.5 + 0.1,
            speed: Math.random() * 0.3 + 0.05
        });
    }

    const shooters = [];
    let lastShooter = 0;

    function titleLoop(t) {
        if (gameState.phase !== 'title') return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // √âtoiles scintillantes
        for (const s of stars) {
            const flicker = s.alpha * (0.6 + Math.sin(t * 0.002 * s.speed + s.x) * 0.4);
            ctx.fillStyle = `rgba(200, 215, 255, ${flicker})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
            ctx.fill();
        }

        // √âtoiles filantes
        if (t - lastShooter > 2000 + Math.random() * 3000) {
            lastShooter = t;
            const angle = -0.3 + Math.random() * 0.2;
            shooters.push({
                x: Math.random() * canvas.width,
                y: -20,
                vx: Math.cos(angle) * (200 + Math.random() * 300),
                vy: Math.sin(angle + Math.PI/2) * (200 + Math.random() * 300),
                life: 0.8 + Math.random() * 0.6,
                age: 0,
                length: 40 + Math.random() * 60
            });
        }

        for (let i = shooters.length - 1; i >= 0; i--) {
            const s = shooters[i];
            s.age += 0.016;
            s.x += s.vx * 0.016;
            s.y += s.vy * 0.016;

            const progress = s.age / s.life;
            const alpha = progress < 0.2 ? progress / 0.2 : 1 - (progress - 0.2) / 0.8;
            const speed = Math.sqrt(s.vx * s.vx + s.vy * s.vy);
            const dx = s.vx / speed;
            const dy = s.vy / speed;

            const g = ctx.createLinearGradient(
                s.x - dx * s.length, s.y - dy * s.length,
                s.x, s.y
            );
            g.addColorStop(0, 'rgba(0,0,0,0)');
            g.addColorStop(1, `rgba(200, 220, 255, ${alpha * 0.6})`);
            ctx.strokeStyle = g;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(s.x - dx * s.length, s.y - dy * s.length);
            ctx.lineTo(s.x, s.y);
            ctx.stroke();

            if (s.age >= s.life) shooters.splice(i, 1);
        }

        requestAnimationFrame(titleLoop);
    }

    requestAnimationFrame(titleLoop);
}


// ‚îÄ‚îÄ Panneaux draggables & r√©tractables ‚îÄ‚îÄ
const PANEL_IDS = ['sporeCounter', 'evoPanel', 'scoreBoard', 'minimap', 'uiZoomControl', 'myPlanets', 'eventLog', 'codex'];
const PANEL_LABELS = { sporeCounter: 'SPORES', evoPanel: '√âVOLUTION', scoreBoard: 'SCORES', minimap: 'MINIMAP', uiZoomControl: 'TAILLE UI', myPlanets: 'MES ASTRES', eventLog: '√âV√âNEMENTS', codex: 'CODEX' };
let panelConfig = {};
let _panelsInitialized = false;

const SNAP_DISTANCE = 14;

function _snapPanel(el, id) {
    const r = el.getBoundingClientRect();
    const curLeft = parseInt(el.style.left);
    const curTop = parseInt(el.style.top);
    if (isNaN(curLeft) || isNaN(curTop)) return;
    let dxBest = SNAP_DISTANCE + 1, dyBest = SNAP_DISTANCE + 1;
    let adjX = 0, adjY = 0;
    for (const otherId of PANEL_IDS) {
        if (otherId === id) continue;
        const other = document.getElementById(otherId);
        if (!other || other.style.display === 'none' || other.classList.contains('panel-collapsed')) continue;
        if (!other.offsetWidth) continue;
        const o = other.getBoundingClientRect();
        // Proximit√© verticale suffisante pour snap horizontal ?
        const nearY = (r.bottom > o.top - SNAP_DISTANCE) && (r.top < o.bottom + SNAP_DISTANCE);
        // Proximit√© horizontale suffisante pour snap vertical ?
        const nearX = (r.right > o.left - SNAP_DISTANCE) && (r.left < o.right + SNAP_DISTANCE);
        if (nearY) {
            const tests = [
                r.right - o.left,   // bord droit ‚Üí bord gauche
                r.left - o.right,   // bord gauche ‚Üí bord droit
                r.left - o.left,    // aligner gauches
                r.right - o.right   // aligner droits
            ];
            for (let i = 0; i < tests.length; i++) {
                if (Math.abs(tests[i]) < Math.abs(dxBest)) { dxBest = tests[i]; adjX = -tests[i]; }
            }
        }
        if (nearX) {
            const tests = [
                r.bottom - o.top,   // bord bas ‚Üí bord haut
                r.top - o.bottom,   // bord haut ‚Üí bord bas
                r.top - o.top,      // aligner hauts
                r.bottom - o.bottom // aligner bas
            ];
            for (let i = 0; i < tests.length; i++) {
                if (Math.abs(tests[i]) < Math.abs(dyBest)) { dyBest = tests[i]; adjY = -tests[i]; }
            }
        }
    }
    // Snap aux bords de l'√©cran
    if (Math.abs(r.left) < Math.abs(dxBest)) { dxBest = r.left; adjX = -r.left; }
    if (Math.abs(r.top) < Math.abs(dyBest)) { dyBest = r.top; adjY = -r.top; }
    if (Math.abs(r.right - window.innerWidth) < Math.abs(dxBest)) { adjX = window.innerWidth - r.right; dxBest = -(window.innerWidth - r.right); }
    if (Math.abs(r.bottom - window.innerHeight) < Math.abs(dyBest)) { adjY = window.innerHeight - r.bottom; dyBest = -(window.innerHeight - r.bottom); }
    if (Math.abs(dxBest) <= SNAP_DISTANCE) el.style.left = Math.round(curLeft + adjX) + 'px';
    if (Math.abs(dyBest) <= SNAP_DISTANCE) el.style.top = Math.round(curTop + adjY) + 'px';
}

function _getUIScaleTransform() {
    const slider = document.getElementById('uiZoomSlider');
    if (!slider) return '';
    const val = parseInt(slider.value);
    return val !== 100 ? `scale(${val / 100})` : '';
}

function initPanels() {
    if (_panelsInitialized) return;
    _panelsInitialized = true;
    for (const id of PANEL_IDS) {
        const el = document.getElementById(id);
        if (!el) continue;
        if (!panelConfig[id]) panelConfig[id] = {};
        const handle = document.createElement('div');
        handle.className = 'panel-drag-handle';
        handle.innerHTML = `<span class="panel-label">${PANEL_LABELS[id]}</span><span class="panel-collapse" title="R√©duire/Agrandir">‚ñæ</span>`;
        el.insertBefore(handle, el.firstChild);
        const colBtn = handle.querySelector('.panel-collapse');
        colBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            el.classList.toggle('panel-collapsed');
            colBtn.textContent = el.classList.contains('panel-collapsed') ? '‚ñ∏' : '‚ñæ';
            panelConfig[id].collapsed = el.classList.contains('panel-collapsed');
            debounceSavePanels();
        });
        let dragging = false, startX, startY, origX, origY;
        handle.addEventListener('mousedown', (e) => {
            if (e.target === colBtn) return;
            dragging = true;
            startX = e.clientX; startY = e.clientY;
            const rect = el.getBoundingClientRect();
            origX = rect.left; origY = rect.top;
            el.style.transition = 'none';
            e.preventDefault();
        });
        handle.addEventListener('touchstart', (e) => {
            if (e.target === colBtn) return;
            const touch = e.touches[0];
            dragging = true;
            startX = touch.clientX; startY = touch.clientY;
            const rect = el.getBoundingClientRect();
            origX = rect.left; origY = rect.top;
            el.style.transition = 'none';
        }, { passive: true });
        window.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            el.style.position = 'fixed';
            el.style.left = (origX + e.clientX - startX) + 'px';
            el.style.top = (origY + e.clientY - startY) + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        });
        window.addEventListener('touchmove', (e) => {
            if (!dragging) return;
            const touch = e.touches[0];
            el.style.position = 'fixed';
            el.style.left = (origX + touch.clientX - startX) + 'px';
            el.style.top = (origY + touch.clientY - startY) + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        }, { passive: true });
        const endDrag = () => {
            if (!dragging) return;
            dragging = false;
            el.style.transition = '';
            _snapPanel(el, id);
            const left = parseInt(el.style.left);
            const top = parseInt(el.style.top);
            if (!isNaN(left) && !isNaN(top)) {
                panelConfig[id].x = left;
                panelConfig[id].y = top;
                debounceSavePanels();
            }
        };
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
        if (panelConfig[id].x !== undefined && panelConfig[id].y !== undefined) {
            el.style.position = 'fixed';
            el.style.left = panelConfig[id].x + 'px';
            el.style.top = panelConfig[id].y + 'px';
            el.style.right = 'auto';
            el.style.bottom = 'auto';
            el.style.transform = _getUIScaleTransform() || 'none';
        }
        if (panelConfig[id].collapsed) {
            el.classList.add('panel-collapsed');
            colBtn.textContent = '‚ñ∏';
        }
    }
}

let _savePanelTimer = null;
function debounceSavePanels() {
    clearTimeout(_savePanelTimer);
    _savePanelTimer = setTimeout(savePanelConfig, 1000);
}

async function loadPanelConfig() {
    if (typeof currentUser === 'undefined' || !currentUser) return;
    try {
        const { data } = await _supa.from('profiles').select('panel_config').eq('id', currentUser.id).single();
        if (data && data.panel_config) panelConfig = data.panel_config;
    } catch (e) { console.warn('Panel config load:', e); }
}

async function savePanelConfig() {
    if (typeof currentUser === 'undefined' || !currentUser) return;
    try {
        await _supa.from('profiles').update({ panel_config: panelConfig }).eq('id', currentUser.id);
    } catch (e) { console.warn('Panel config save:', e); }
}

// ‚îÄ‚îÄ Log d'√©v√©nements ‚îÄ‚îÄ
function addEvent(cat, icon, text, body, color) {
    const t = gameState.time;
    const m = Math.floor(t / 60);
    const s = Math.floor(t % 60);
    const time = (m < 10 ? '0' : '') + m + ':' + (s < 10 ? '0' : '') + s;
    gameState.eventLog.unshift({ cat, icon, text, time, body, color: color || '#AAA' });
    if (gameState.eventLog.length > 100) gameState.eventLog.pop();
    refreshEventLog();
}

function refreshEventLog() {
    const logBody = document.getElementById('eventLogBody');
    if (!logBody) return;
    const activeFilter = document.querySelector('#eventLog .log-filter.active');
    const cat = activeFilter ? activeFilter.dataset.cat : 'all';
    const filtered = cat === 'all' ? gameState.eventLog : gameState.eventLog.filter(e => e.cat === cat);
    logBody.innerHTML = filtered.slice(0, 50).map((e, i) =>
        `<div class="log-entry" data-idx="${i}"><span class="log-time">${e.time}</span><span class="log-icon" style="color:${e.color}">${e.icon}</span><span style="display:inline-block;width:8px;height:8px;border-radius:2px;background:${e.color};margin:0 4px;vertical-align:middle;"></span><span class="log-text">${e.text}</span></div>`
    ).join('');
    logBody.querySelectorAll('.log-entry').forEach(el => {
        el.addEventListener('click', () => {
            const idx = parseInt(el.dataset.idx);
            const evt = filtered[idx];
            if (evt && evt.body) {
                gameState.camera.x = evt.body.x;
                gameState.camera.y = evt.body.y;
                gameState.camera.zoom = Math.max(gameState.camera.zoom, 0.8);
                openCodex(evt.body);
            }
        });
    });
}

window.addEventListener('load', init);

</script>

<!-- ‚ïê‚ïê‚ïê VOLUME ‚ïê‚ïê‚ïê -->
<div id="volumeControl">
    <span class="vol-icon" id="volToggle">üîä</span>
    <input type="range" id="volSlider" min="0" max="100" value="0">
</div>

<!-- ‚ïê‚ïê‚ïê √âCRAN DE FIN ‚ïê‚ïê‚ïê -->
<div id="endScreen">
    <h1 id="endTitle">‚Äî</h1>
    <div class="end-subtitle" id="endSubtitle"></div>
    <div class="end-stats" id="endStats"></div>
    <div class="end-buttons">
        <button class="btn" id="btnReplay">REJOUER</button>
        <button class="btn" id="btnEndQuit">MENU</button>
    </div>
</div>


<script>
const CLN_CFG = {
    speedMin: 67, speedMax: 120, turnInterval: 15,
    detectRange: 200, fireRate: 1.5, dmgMin: 34, dmgMax: 106
};

const SKY_CFG = { r: 22, g: 38, b: 78, brightness: 100 };

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// FOND SPATIAL ‚Äî Couches PNG en parallaxe
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

const COMET_CFG = {
    freq: 8, speed: 150, size: 8, tail: 80, fgDebris: 10
};

// ‚ïê‚ïê‚ïê Listener ZOOM UI ‚ïê‚ïê‚ïê
document.getElementById('uiZoomSlider').addEventListener('input', (e) => {
    const val = parseInt(e.target.value);
    document.getElementById('uiZoomVal').textContent = val + '%';
    const scale = val / 100;
    // Appliquer le zoom aux √©l√©ments HUD
    const els = ['evoPanel', 'myPlanets', 'minimap', 'uiZoomControl', 'scoreBoard', 'sporeCounter', 'eventLog', 'codex'];
    els.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
            el.style.transformOrigin = 'top left';
            if (id === 'minimap' || id === 'uiZoomControl') el.style.transformOrigin = 'bottom right';
            if (id === 'scoreBoard' || id === 'sporeCounter') el.style.transformOrigin = 'top right';
            if (id === 'eventLog' || id === 'codex') el.style.transformOrigin = 'bottom left';
            const cur = el.style.transform || '';
            if (cur && cur !== 'none' && /scale\(/.test(cur)) {
                el.style.transform = cur.replace(/scale\([^)]*\)/, `scale(${scale})`);
            } else {
                el.style.transform = scale !== 1 ? `scale(${scale})` : (cur === 'none' ? 'none' : '');
            }
        }
    });
});

// ‚ïê‚ïê‚ïê Listener Jet Ratio ‚ïê‚ïê‚ïê
document.getElementById('jetRatioSlider').addEventListener('input', (e) => {
    const v = parseInt(e.target.value);
    gameState.jetRatio = v / 100;
    document.getElementById('jetRatioVal').textContent = v + '%';
});

// ‚ïê‚ïê‚ïê Tabs √âvolution / Technologies ‚ïê‚ïê‚ïê
document.querySelectorAll('#evoPanel .evo-tab').forEach(tab => {
    tab.addEventListener('click', () => {
        document.querySelectorAll('#evoPanel .evo-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('#evoPanel .evo-tab-content').forEach(c => c.classList.remove('active'));
        tab.classList.add('active');
        const target = document.getElementById(tab.dataset.tab);
        if (target) target.classList.add('active');
    });
});
// ‚ïê‚ïê‚ïê Listeners Tech Tree ‚ïê‚ïê‚ïê
document.getElementById('techHomingBuy').addEventListener('click', () => { const p=gameState.players?.[localSlot()]; if(p&&buyTech(p,'homing')){playClickSound();updateTechPanel();} });
document.getElementById('techTenacityBuy').addEventListener('click', () => { const p=gameState.players?.[localSlot()]; if(p&&buyTech(p,'tenacity')){playClickSound();updateTechPanel();} });
document.getElementById('techMimicryBuy').addEventListener('click', () => { const p=gameState.players?.[localSlot()]; if(p&&buyTech(p,'mimicry')){playClickSound();updateTechPanel();} });

// ‚ïê‚ïê‚ïê Listeners MULTIPLICIT√â ‚ïê‚ïê‚ïê
document.body.appendChild(document.getElementById('spawnPopup'));
document.getElementById('spawnPopupBtn').addEventListener('click', () => { playClickSound(); confirmSpawn(); });
document.getElementById('spawnPopupClose').addEventListener('click', () => { playClickSound(); _spawnTarget = null; document.getElementById('spawnPopup').style.display = 'none'; });
document.getElementById('evoSacrifice').addEventListener('input', (e) => {
    const human = gameState.players[localSlot()];
    if (human) human.multiSacrifice = parseInt(e.target.value);
});
document.getElementById('nidSacrifice').addEventListener('input', (e) => {
    const human = gameState.players[localSlot()];
    if (human) {
        human._nidSacrifice = parseInt(e.target.value);
        document.getElementById('nidSacVal').textContent = e.target.value + '%';
    }
});
document.getElementById('evoGrowth').addEventListener('click', () => {
    const human = gameState.players[localSlot()];
    if (human && human._multiPending) { applyMultiChoice(human, 'growth'); if (gameState.isMulti) sendAction('multi', { stat: 'growth' }); }
});
document.getElementById('evoVelocity').addEventListener('click', () => {
    const human = gameState.players[localSlot()];
    if (human && human._multiPending) { applyMultiChoice(human, 'velocity'); if (gameState.isMulti) sendAction('multi', { stat: 'velocity' }); }
});
document.getElementById('evoDensity').addEventListener('click', () => {
    const human = gameState.players[localSlot()];
    if (human && human._multiPending) { applyMultiChoice(human, 'density'); if (gameState.isMulti) sendAction('multi', { stat: 'density' }); }
});

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AUTH SUPABASE ‚Äî Login + Pseudo
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
const SUPABASE_URL = 'https://hcjajtpbzusqgxkyzbgc.supabase.co';
const SUPABASE_ANON = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhjamFqdHBienVzcWd4a3l6YmdjIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxMTIwNjgsImV4cCI6MjA4NzY4ODA2OH0.UXiZvC3kQmQzZ4BSWp6X19ISPjlac87YZlLonUqzvic';
const _supa = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);

let currentUser = null;
let currentProfile = null;
let currentRoom = null;
let currentRoomChannel = null;
let isHost = false;

async function initAuth() {
    try {
        const { data: { session }, error } = await _supa.auth.getSession();
        if (error) {
            console.warn('Session invalide, nettoyage...', error.message);
            await _supa.auth.signOut();
            currentUser = null;
            currentProfile = null;
            if (inviteChannel) { _supa.removeChannel(inviteChannel); inviteChannel = null; }
            showAuthScreen();
            return;
        }
        if (session && session.user) {
            currentUser = session.user;
            const profile = await loadProfile(currentUser.id);
            if (profile) {
                currentProfile = profile;
                await loadPanelConfig();
                enterGame();
                return;
            }
            await _supa.auth.signOut();
        }
    } catch(e) {
        console.warn('Erreur auth init:', e);
        await _supa.auth.signOut().catch(() => {});
    }
    currentUser = null;
    currentProfile = null;
    if (inviteChannel) { _supa.removeChannel(inviteChannel); inviteChannel = null; }
    showAuthScreen();
}

_supa.auth.onAuthStateChange((event, session) => {
    if (event === 'TOKEN_REFRESHED' && session) {
        currentUser = session.user;
    }
    if (event === 'SIGNED_OUT') {
        currentUser = null;
        currentProfile = null;
    }
});

function onSignedIn(user) {
    currentUser = user;
    loadProfile(user.id).then(async (profile) => {
        if (profile) {
            currentProfile = profile;
            await loadPanelConfig();
            enterGame();
        } else {
            showPseudoStep();
        }
    });
}

function showAuthScreen() {
    document.getElementById('authScreen').classList.remove('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
}

function showPseudoStep() {
    document.getElementById('authScreen').classList.remove('hidden');
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('authStep1').style.display = 'none';
    document.getElementById('authStep2').style.display = 'block';
}

function enterGame() {
    document.getElementById('authScreen').classList.add('hidden');
    const pseudoEl = document.getElementById('titlePseudo');
    if (pseudoEl && currentProfile) pseudoEl.textContent = '‚¨° ' + currentProfile.pseudo;
    setupInviteListener();
    setPhase('title');
}

async function loadProfile(userId) {
    try {
    const { data, error } = await _supa
        .from('profiles')
        .select('*')
        .eq('id', userId)
        .single();
    if (error || !data) return null;
    return data;
    } catch(e) { return null; }
}

document.getElementById('btnAuthLogin').addEventListener('click', async () => {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    const msg = document.getElementById('authMsg');
    if (!email || !email.includes('@')) {
        msg.textContent = 'Entrez un email valide.';
        msg.style.color = '#EF4444';
        return;
    }
    if (password.length < 6) {
        msg.textContent = 'Mot de passe : 6 caract√®res minimum.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'Connexion...';
    msg.style.color = '#8B5CF6';
    const { data, error } = await _supa.auth.signInWithPassword({ email, password });
    if (error) {
        msg.textContent = 'Email ou mot de passe incorrect.';
        msg.style.color = '#EF4444';
    } else if (data && data.user) {
        msg.textContent = '‚úì Connect√© !';
        msg.style.color = '#22C55E';
        onSignedIn(data.user);
    }
});

document.getElementById('btnAuthSignup').addEventListener('click', async () => {
    const email = document.getElementById('authEmail').value.trim();
    const password = document.getElementById('authPassword').value;
    const msg = document.getElementById('authMsg');
    if (!email || !email.includes('@')) {
        msg.textContent = 'Entrez un email valide.';
        msg.style.color = '#EF4444';
        return;
    }
    if (password.length < 6) {
        msg.textContent = 'Mot de passe : 6 caract√®res minimum.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'Cr√©ation du compte...';
    msg.style.color = '#8B5CF6';
    const { data, error } = await _supa.auth.signUp({ email, password });
    if (error) {
        msg.textContent = 'Erreur : ' + error.message;
        msg.style.color = '#EF4444';
    } else if (data && data.user) {
        msg.textContent = '‚úì Compte cr√©√© !';
        msg.style.color = '#22C55E';
        onSignedIn(data.user);
    }
});

document.getElementById('btnAuthPseudo').addEventListener('click', async () => {
    const pseudo = document.getElementById('authPseudo').value.trim();
    const msg = document.getElementById('pseudoMsg');
    if (pseudo.length < 3 || pseudo.length > 20) {
        msg.textContent = 'Le pseudo doit faire entre 3 et 20 caract√®res.';
        msg.style.color = '#EF4444';
        return;
    }
    msg.textContent = 'Enregistrement...';
    msg.style.color = '#8B5CF6';
    const { data, error } = await _supa
        .from('profiles')
        .insert({ id: currentUser.id, pseudo: pseudo })
        .select()
        .single();
    if (error) {
        if (error.code === '23505') {
            msg.textContent = 'Ce pseudo est d√©j√† pris.';
        } else {
            msg.textContent = 'Erreur : ' + error.message;
        }
        msg.style.color = '#EF4444';
    } else {
        currentProfile = data;
        enterGame();
    }
});

async function startMultiGame() {
    if (!isHost || !currentRoom) { console.warn('startMulti: not host or no room'); return; }
    const { data: players, error } = await _supa.from('game_room_players').select('*').eq('room_id', currentRoom.id).order('slot_number');
    if (error) { console.warn('startMulti error:', error); return; }
    if (!players || players.length < 2) {
        document.getElementById('roomStatus').textContent = 'Il faut au moins 2 joueurs.';
        document.getElementById('roomStatus').style.color = '#F87171';
        return;
    }
    if (!players.every(p => p.ready)) {
        document.getElementById('roomStatus').textContent = 'Tous les joueurs doivent √™tre PR√äT.';
        document.getElementById('roomStatus').style.color = '#F87171';
        return;
    }
    const seed = Math.floor(Math.random() * 2147483647);
    const settings = { ...currentRoom.settings, playerCount: players.length };
    const { error: e2 } = await _supa.from('game_rooms').update({ status: 'playing', settings, seed }).eq('id', currentRoom.id);
    if (e2) { console.warn('startMulti update error:', e2); }
}

let gameChannel = null;
let mySlot = -1;
function localSlot() { return gameState.isMulti ? mySlot : 0; }

function setupGameChannel(roomId) {
    if (gameChannel) _supa.removeChannel(gameChannel);
    gameChannel = _supa.channel('game-' + roomId);
    gameChannel.on('broadcast', { event: 'action' }, ({ payload }) => {
        if (payload.slot === mySlot) return;
        handleRemoteAction(payload);
    });
    return new Promise(resolve => {
        gameChannel.subscribe((status) => { if (status === 'SUBSCRIBED') resolve(); });
        setTimeout(resolve, 3000); // fallback si subscribe lent
    });
}

function sendAction(type, data) {
    if (!gameChannel || !gameState.isMulti) return;
    gameChannel.send({ type: 'broadcast', event: 'action', payload: { slot: mySlot, type, ...data } });
}

function handleRemoteAction(payload) {
    const player = gameState.players[payload.slot];
    if (!player) return;
    switch (payload.type) {
        case 'spawn':
            const body = gameState.allBodies.find(b => b.name === payload.bodyName);
            if (body) { player.spawnPlanet = body; body.owner = payload.slot; body.spores = body.maxSpores * 0.5; player.bodies = [body]; }
            break;
        case 'jet':
            const src = gameState.allBodies.find(b => b.name === payload.srcName);
            if (src) launchJet(src, payload.dirX, payload.dirY);
            break;
        case 'multi':
            applyMultiChoice(player, payload.stat);
            break;
        case 'playerLeft':
            player.isHuman = false;
            player.aiTimer = 0;
            player.aiCooldown = gameState.config.difficulty === 'easy' ? 3 : gameState.config.difficulty === 'normal' ? 1.5 : 0.5;
            player.name = 'IA-' + player.name;
            addEvent('neutral', 'üö™', player.name + ' a quitt√© (remplac√© par IA)', null, player.color);
            break;
        case 'playerRejoined':
            player.isHuman = true;
            player.name = player.name.replace(/^IA-/, '');
            addEvent('neutral', 'üîÑ', player.name + ' a repris le contr√¥le', null, player.color);
            break;
    }
}

async function onMultiGameStart(room) {
    currentRoom = room;
    gameState.isMulti = true;
    gameState.multiSeed = room.seed;
    // Appliquer les settings de la room
    const s = room.settings || {};
    gameState.config.sunCount = s.sunCount || 4;
    gameState.config.playerCount = s.playerCount || 4;
    gameState.config.difficulty = s.difficulty || 'normal';
    gameState.config.useIA = s.useIA !== false;
    gameState.config.cleanerCount = s.cleanerCount || 3;
    gameState.config.useAsteroids = s.useAsteroids !== false;
    // Synchroniser les sliders UI
    document.getElementById('cfgSuns').value = gameState.config.sunCount;
    document.getElementById('cfgPlayers').value = gameState.config.playerCount;
    // Charger les joueurs de la room et mon slot
    const { data: rPlayers } = await _supa.from('game_room_players').select('*').eq('room_id', room.id).order('slot_number');
    gameState._roomPlayers = rPlayers || [];
    const me = rPlayers.find(p => p.player_id === currentUser.id);
    mySlot = me ? me.slot_number : 0;
    // Canal broadcast
    await setupGameChannel(room.id);
    // Lancer la partie
    startGame();
}

async function toggleReady() {
    if (!currentRoom || !currentUser) { console.warn('toggleReady: no room or user'); return; }
    const { data: { session } } = await _supa.auth.getSession();
    if (!session) { alert('Session expir√©e. Reconnectez-vous.'); initAuth(); return; }
    const { data, error: e1 } = await _supa.from('game_room_players').select('ready').eq('room_id', currentRoom.id).eq('player_id', currentUser.id).maybeSingle();
    if (e1) { console.warn('toggleReady select:', e1); return; }
    if (!data) { console.warn('toggleReady: player not found in room'); return; }
    const newReady = !data.ready;
    const updateData = { ready: newReady };
    if (newReady) updateData.stats = { ...gameState.playerStats };
    const { error: e2 } = await _supa.from('game_room_players').update(updateData).eq('room_id', currentRoom.id).eq('player_id', currentUser.id);
    if (e2) { console.warn('toggleReady update:', e2); return; }
    const btn = document.getElementById('btnRoomReady');
    btn.textContent = newReady ? '‚úì PR√äT' : 'PR√äT';
    btn.style.borderColor = newReady ? '#4ADE80' : 'rgba(34,197,94,0.5)';
}

async function leaveRoom() {
    if (!currentRoom || !currentUser) return;
    if (_roomPollTimer) { clearInterval(_roomPollTimer); _roomPollTimer = null; }
    if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); currentRoomChannel = null; }
    await _supa.from('game_room_players').delete().eq('room_id', currentRoom.id).eq('player_id', currentUser.id);
    // Si host, supprimer la room
    if (isHost) {
        await _supa.from('game_rooms').delete().eq('id', currentRoom.id);
    }
    currentRoom = null;
    isHost = false;
    setPhase('title');
}

let _roomPollTimer = null;

async function enterRoom(roomId) {
    setPhase('room');
    document.getElementById('roomCode').textContent = 'CODE : ' + roomId.substring(0, 8).toUpperCase();
    const isAuto = currentRoom && currentRoom.settings?.mode === 'auto';
    // Afficher les param√®tres de la partie
    const s = currentRoom ? currentRoom.settings || {} : {};
    const diffLabel = s.difficulty === 'easy' ? 'Facile' : s.difficulty === 'brutal' ? 'Brutal' : 'Normal';
    document.getElementById('roomParams').textContent = `${parseInt(s.sunCount) || 4} soleils ¬∑ ${diffLabel} ¬∑ ${s.useAsteroids !== false ? 'M√©t√©orites' : 'Sans m√©t√©orites'} ¬∑ ${parseInt(s.cleanerCount) || 0} vaisseaux`;
    document.getElementById('btnRoomStart').style.display = (isHost && !isAuto) ? 'inline-block' : 'none';
    document.getElementById('btnRoomReady').style.display = isAuto ? 'none' : 'inline-block';
    // Charger les joueurs
    await refreshRoomSlots(roomId);
    // Subscribe Realtime sur la table game_room_players
    if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); }
    currentRoomChannel = _supa.channel('room-' + roomId)
        .on('postgres_changes', { event: '*', schema: 'public', table: 'game_room_players', filter: 'room_id=eq.' + roomId }, () => {
            refreshRoomSlots(roomId);
        })
        .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'game_rooms', filter: 'id=eq.' + roomId }, (payload) => {
            if (payload.new.status === 'playing') onMultiGameStart(payload.new);
        })
        .on('postgres_changes', { event: 'DELETE', schema: 'public', table: 'game_rooms', filter: 'id=eq.' + roomId }, () => {
            if (_roomPollTimer) { clearInterval(_roomPollTimer); _roomPollTimer = null; }
            if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); currentRoomChannel = null; }
            currentRoom = null; isHost = false;
            alert('L\'h√¥te a ferm√© la partie.');
            setPhase('title');
        })
        .subscribe();
    // Polling de secours (3s) au cas o√π Realtime ne notifie pas
    if (_roomPollTimer) clearInterval(_roomPollTimer);
    _roomPollTimer = setInterval(async () => {
        if (!currentRoom) { clearInterval(_roomPollTimer); _roomPollTimer = null; return; }
        await refreshRoomSlots(roomId);
        // V√©rifier aussi si la room a √©t√© lanc√©e
        const { data: room } = await _supa.from('game_rooms').select('status, seed, settings').eq('id', roomId).single();
        if (!room) {
            clearInterval(_roomPollTimer); _roomPollTimer = null;
            if (currentRoomChannel) { _supa.removeChannel(currentRoomChannel); currentRoomChannel = null; }
            currentRoom = null; isHost = false;
            alert('L\'h√¥te a ferm√© la partie.');
            setPhase('title');
            return;
        }
        if (room && room.status === 'playing') {
            clearInterval(_roomPollTimer); _roomPollTimer = null;
            onMultiGameStart({ ...currentRoom, ...room });
        }
    }, 3000);
}

async function refreshRoomSlots(roomId) {
    const { data: players } = await _supa.from('game_room_players').select('*').eq('room_id', roomId).order('slot_number');
    const max = currentRoom ? currentRoom.max_players : 4;
    const slotsEl = document.getElementById('roomSlots');
    let html = '';
    for (let i = 0; i < max; i++) {
        const p = (players || []).find(x => x.slot_number === i);
        if (p) {
            const readyCls = p.ready ? 'yes' : 'no';
            const readyTxt = p.ready ? 'PR√äT' : '...';
            html += `<div class="room-slot"><div class="slot-color" style="background:${esc(p.color)}"></div><span class="slot-name">${esc(p.pseudo)}</span><span class="slot-ready ${readyCls}">${readyTxt}</span></div>`;
        } else {
            html += `<div class="room-slot empty"><div class="slot-color" style="background:#333"></div><span class="slot-name" style="color:#64748B;">Slot libre</span></div>`;
        }
    }
    slotsEl.innerHTML = html;
    // Compteur joueurs
    const count = (players || []).length;
    document.getElementById('roomCounter').textContent = count + ' / ' + max;
    const allReady2 = players && players.length > 0 && players.every(p => p.ready);
    if (count >= max && allReady2) {
        document.getElementById('roomStatus').textContent = '‚úì TOUS PR√äTS ‚Äî LANCEMENT...';
        document.getElementById('roomStatus').style.color = '#4ADE80';
    } else if (count >= max) {
        document.getElementById('roomStatus').textContent = 'En attente que tous soient PR√äT...';
        document.getElementById('roomStatus').style.color = '#FBBF24';
    } else {
        document.getElementById('roomStatus').textContent = 'En attente de joueurs... (' + count + '/' + max + ')';
        document.getElementById('roomStatus').style.color = '#FBBF24';
    }
    // Activer le bouton LANCER si host et tous pr√™ts
    if (isHost) {
        const allReady = players && players.length > 0 && players.every(p => p.ready);
        document.getElementById('btnRoomStart').style.opacity = allReady ? '1' : '0.4';
        document.getElementById('btnRoomStart').style.pointerEvents = allReady ? 'auto' : 'none';
    }
    // Auto-lancement pour les rooms auto quand pleine et tous pr√™ts
    if (currentRoom && currentRoom.settings?.mode === 'auto') {
        const max = currentRoom.max_players;
        const allReady = players && players.length >= max && players.every(p => p.ready);
        if (allReady && isHost) {
            startMultiGame();
        }
    }
}

async function joinRoom(roomId) {
    if (!currentUser || !currentProfile) return;
    try {
    // Charger la room
    const { data: room, error: re } = await _supa.from('game_rooms').select('*').eq('id', roomId).single();
    if (re || !room || room.status !== 'waiting') { alert('Partie indisponible.'); loadRoomList(); return; }
    // Trouver le prochain slot libre
    const { data: players } = await _supa.from('game_room_players').select('slot_number').eq('room_id', roomId);
    const taken = (players || []).map(p => p.slot_number);
    let slot = -1;
    for (let i = 0; i < room.max_players; i++) { if (!taken.includes(i)) { slot = i; break; } }
    if (slot === -1) { alert('Partie pleine.'); loadRoomList(); return; }
    const autoReady = (room.settings?.mode === 'auto');
    const { error } = await _supa.from('game_room_players').insert({
        room_id: roomId, player_id: currentUser.id,
        pseudo: currentProfile.pseudo,
        color: gameState.teamColors[slot % gameState.teamColors.length],
        slot_number: slot, ready: autoReady,
        stats: autoReady ? { ...gameState.playerStats } : null
    });
    if (error) { console.warn('Erreur join:', error); return; }
    currentRoom = room;
    isHost = (room.host_id === currentUser.id);
    enterRoom(roomId);
    } catch(e) { console.warn('joinRoom:', e); alert('Erreur r√©seau.'); }
}

async function quickMatch() {
    if (!currentUser || !currentProfile) {
        alert('Vous devez √™tre connect√© pour jouer en ligne.');
        showAuthScreen();
        return;
    }
    // Nettoyer les rooms abandonn√©es (>30min en waiting)
    try {
        const cutoff = new Date(Date.now() - 30 * 60 * 1000).toISOString();
        await _supa.from('game_rooms').delete().eq('status', 'waiting').lt('created_at', cutoff);
    } catch(e) { /* ignore */ }
    // Chercher une room auto en attente avec de la place
    const { data: rooms } = await _supa.from('game_rooms').select('*, game_room_players(count)').eq('status', 'waiting').order('created_at', { ascending: true }).limit(20);
    if (rooms) {
        for (const r of rooms) {
            if ((r.settings?.mode) !== 'auto') continue;
            const count = r.game_room_players?.[0]?.count || 0;
            if (count < r.max_players) {
                await joinRoom(r.id);
                return;
            }
        }
    }
    // Aucune room dispo ‚Üí en cr√©er une avec param√®tres al√©atoires
    const suns = 2 + Math.floor(Math.random() * 5); // 2-6
    const players = 2 + Math.floor(Math.random() * 3); // 2-4
    const diffs = ['easy', 'normal', 'brutal'];
    const diff = diffs[Math.floor(Math.random() * 3)];
    const cleaners = Math.floor(Math.random() * 8);
    const aiCount = Math.floor(Math.random() * 5);
    const autoSettings = { sunCount: suns, difficulty: diff, useIA: aiCount > 0, aiCount: aiCount, cleanerCount: cleaners, useAsteroids: Math.random() > 0.4, playerCount: players + aiCount };
    await createRoom('auto', autoSettings, players);
}

async function createRoom(mode = 'custom', settings = null, maxPlayers = 4) {
    if (!currentUser || !currentProfile) return;
    try {
    if (!settings) settings = { sunCount: 4, difficulty: 'normal', useIA: true, cleanerCount: 3, useAsteroids: true };
    const { data, error } = await _supa.from('game_rooms').insert({
        host_id: currentUser.id,
        host_pseudo: currentProfile.pseudo,
        settings: { ...settings, mode },
        max_players: maxPlayers,
        status: 'waiting'
    }).select().single();
    if (error) { console.warn('Erreur cr√©ation room:', error); return; }
    currentRoom = data;
    isHost = true;
    // S'ajouter comme joueur slot 0
    await _supa.from('game_room_players').insert({
        room_id: data.id, player_id: currentUser.id,
        pseudo: currentProfile.pseudo,
        color: gameState.teamColors[0],
        slot_number: 0, ready: true,
        stats: { ...gameState.playerStats }
    });
    enterRoom(data.id);
    } catch(e) { console.warn('createRoom:', e); alert('Erreur r√©seau.'); }
}

async function rejoinGame() {
    if (!_leftRoom) return;
    const { roomId, slot, gameStateBackup } = _leftRoom;
    // V√©rifier que la room existe encore
    const { data: room } = await _supa.from('game_rooms').select('*').eq('id', roomId).single();
    if (!room || room.status !== 'playing') {
        _leftRoom = null;
        alert('La partie est termin√©e.');
        return;
    }
    currentRoom = room;
    mySlot = slot;
    gameState.isMulti = true;
    await setupGameChannel(roomId);
    // Reprendre le contr√¥le du joueur
    const player = gameState.players[slot];
    if (player) {
        player.isHuman = true;
        player.isLocal = true;
        player.name = player.name.replace(/^IA-/, '');
        sendAction('playerRejoined', { slot: slot });
        addEvent('neutral', 'üîÑ', player.name + ' a repris le contr√¥le', null, player.color);
    }
    _leftRoom = null;
    document.getElementById('gameCanvas').style.display = 'block';
    document.getElementById('gameHud').style.display = 'block';
    document.getElementById('minimap').style.display = 'block';
    document.getElementById('uiZoomControl').style.display = 'block';
    document.getElementById('eventLog').style.display = 'block';
    gameState.phase = 'game';
    gameState.running = true;
    initPanels();
}

async function updateQuickMatchPanel() {
    const el = document.getElementById('qmParams');
    if (!el) return;
    try {
        const { data: rooms } = await _supa.from('game_rooms').select('*, game_room_players(count)').eq('status', 'waiting').order('created_at', { ascending: true }).limit(20);
        let found = null;
        if (rooms) {
            for (const r of rooms) {
                if (r.settings?.mode === 'auto') {
                    const count = r.game_room_players?.[0]?.count || 0;
                    if (count < r.max_players) { found = r; found._count = count; break; }
                }
            }
        }
        if (found) {
            const s = found.settings || {};
            el.innerHTML = `${parseInt(s.sunCount) || 4} soleils ¬∑ ${esc(s.difficulty || 'normal')} ¬∑ <span style="color:#4ADE80;">${parseInt(found._count)||0}/${parseInt(found.max_players)||4} joueurs</span>`;
        } else {
            const suns = 2 + Math.floor(Math.random() * 5);
            const pl = 2 + Math.floor(Math.random() * 3);
            const diffs = ['facile', 'normal', 'brutal'];
            const diff = diffs[Math.floor(Math.random() * 3)];
            el.innerHTML = `${suns} soleils ¬∑ ${diff} ¬∑ <span style="color:#94A3B8;">${pl} joueurs (en attente)</span>`;
        }
    } catch(e) {
        el.innerHTML = '4 soleils ¬∑ normal ¬∑ <span style="color:#94A3B8;">2-4 joueurs</span>';
    }
}

// ‚îÄ‚îÄ Syst√®me d'invitation par pseudo ‚îÄ‚îÄ
let inviteChannel = null;
let pendingInvite = null;

function setupInviteListener() {
    if (!currentUser || inviteChannel) return;
    inviteChannel = _supa.channel('invite-' + currentUser.id)
        .on('broadcast', { event: 'invite' }, ({ payload }) => {
            if (gameState.phase !== 'title') return;
            pendingInvite = payload;
            const popup = document.getElementById('invitePopup');
            document.getElementById('invitePopupText').textContent = payload.hostPseudo + ' vous invite √† jouer !';
            const s = payload.settings || {};
            const diffL = s.difficulty === 'easy' ? 'Facile' : s.difficulty === 'brutal' ? 'Brutal' : 'Normal';
            document.getElementById('invitePopupParams').textContent = (s.sunCount||4) + ' soleils ¬∑ ' + diffL + ' ¬∑ ' + (s.cleanerCount||0) + ' vaisseaux';
            popup.classList.remove('hidden');
        })
        .subscribe();
}

document.getElementById('btnInviteAccept').addEventListener('click', async () => {
    document.getElementById('invitePopup').classList.add('hidden');
    if (pendingInvite && pendingInvite.roomId) {
        await joinRoom(pendingInvite.roomId);
    }
    pendingInvite = null;
});

document.getElementById('btnInviteDecline').addEventListener('click', () => {
    document.getElementById('invitePopup').classList.add('hidden');
    pendingInvite = null;
});

document.getElementById('btnInvite').addEventListener('click', async () => {
    const input = document.getElementById('invitePseudoInput');
    const msg = document.getElementById('inviteMsg');
    const pseudo = input.value.trim();
    if (!pseudo) { msg.textContent = 'Entrez un pseudo.'; return; }
    if (!currentRoom) { msg.textContent = 'Aucune room active.'; return; }
    // Trouver le joueur par pseudo
    const { data: target } = await _supa.from('profiles').select('id, pseudo').ilike('pseudo', pseudo).single();
    if (!target) { msg.textContent = 'Joueur "' + pseudo + '" introuvable.'; msg.style.color = '#F87171'; return; }
    // Envoyer l'invitation via Broadcast sur le channel du joueur cible
    const ch = _supa.channel('invite-' + target.id);
    ch.subscribe((status) => {
        if (status === 'SUBSCRIBED') {
            ch.send({ type: 'broadcast', event: 'invite', payload: {
                roomId: currentRoom.id,
                hostPseudo: currentProfile.pseudo,
                settings: currentRoom.settings
            }});
            setTimeout(() => _supa.removeChannel(ch), 2000);
        }
    });
    msg.textContent = 'Invitation envoy√©e √† ' + pseudo + ' ‚úì';
    msg.style.color = '#4ADE80';
    input.value = '';
    setTimeout(() => { msg.textContent = ''; }, 4000);
});

async function loadRoomList() {
    setPhase('title');
}

document.getElementById('btnMulti').addEventListener('click', () => {
    playClickSound();
    if (_leftRoom) {
        if (confirm('Vous avez une partie en cours. Rejoindre ?')) {
            rejoinGame();
            return;
        }
        alert('Vous devez attendre la fin de votre partie ou y retourner.');
        return;
    }
    fadeTransition(() => setPhase('createMulti'));
});
document.getElementById('btnLobbyBack').addEventListener('click', () => {
    playClickSound();
    fadeTransition(() => setPhase('title'));
});
document.getElementById('btnQuickMatch').addEventListener('click', () => {
    playClickSound();
    if (_leftRoom) {
        if (confirm('Vous avez une partie en cours. Rejoindre ?')) {
            rejoinGame();
            return;
        }
        alert('Vous devez attendre la fin de votre partie ou y retourner.');
        return;
    }
    quickMatch();
});
document.getElementById('multiCfgSuns').addEventListener('input', (e) => { document.getElementById('multiCfgSunsVal').textContent = e.target.value; });
document.getElementById('multiCfgHumans').addEventListener('input', (e) => { document.getElementById('multiCfgHumansVal').textContent = e.target.value; });
document.getElementById('multiCfgAI').addEventListener('input', (e) => { document.getElementById('multiCfgAIVal').textContent = e.target.value; });
document.getElementById('multiCfgCleaners').addEventListener('input', (e) => { document.getElementById('multiCfgCleanersVal').textContent = e.target.value; });
document.getElementById('btnCreateRoom').addEventListener('click', () => {
    playClickSound();
    const humans = parseInt(document.getElementById('multiCfgHumans').value);
    const aiCount = parseInt(document.getElementById('multiCfgAI').value);
    const settings = {
        sunCount: parseInt(document.getElementById('multiCfgSuns').value),
        difficulty: document.getElementById('multiCfgDiff').value,
        useIA: aiCount > 0,
        aiCount: aiCount,
        cleanerCount: parseInt(document.getElementById('multiCfgCleaners').value),
        useAsteroids: document.getElementById('multiCfgAsteroids').value === 'on',
        playerCount: humans + aiCount
    };
    createRoom('custom', settings, humans);
});
document.getElementById('btnRoomLeave').addEventListener('click', () => {
    playClickSound();
    leaveRoom();
});
document.getElementById('btnRoomReady').addEventListener('click', () => {
    playClickSound();
    toggleReady();
});
document.getElementById('btnRoomStart').addEventListener('click', () => {
    playClickSound();
    startMultiGame();
});
document.getElementById('btnLogout').addEventListener('click', async () => {
    playClickSound();
    try { await _supa.auth.signOut(); } catch(e) { console.warn('Erreur logout:', e); }
    currentUser = null;
    currentProfile = null;
    document.getElementById('titlePseudo').textContent = '';
    document.getElementById('authStep1').style.display = 'block';
    document.getElementById('authStep2').style.display = 'none';
    document.getElementById('authMsg').textContent = '';
    document.getElementById('authEmail').value = '';
    document.getElementById('authPassword').value = '';
    showAuthScreen();
});

document.getElementById('btnLeaderboard').addEventListener('click', () => {
    playClickSound();
    showLeaderboard();
});

document.getElementById('btnHelp').addEventListener('click', () => {
    playClickSound();
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('helpScreen').classList.remove('hidden');
});

document.getElementById('btnHelpBack').addEventListener('click', () => {
    playClickSound();
    setPhase('title');
});

document.getElementById('btnLeaderboardBack').addEventListener('click', () => {
    playClickSound();
    setPhase('title');
});

async function showLeaderboard() {
    document.getElementById('titleScreen').classList.add('hidden');
    document.getElementById('leaderboardScreen').classList.remove('hidden');
    const body = document.getElementById('leaderboardBody');
    const empty = document.getElementById('leaderboardEmpty');
    body.innerHTML = '<tr><td colspan="5" style="color:#94A3B8; text-align:center; padding:20px;">Chargement...</td></tr>';
    empty.style.display = 'none';

    try {
        const { data, error } = await _supa.from('leaderboard').select('*').limit(50);
        if (error) throw error;
        if (!data || data.length === 0) {
            body.innerHTML = '';
            empty.style.display = 'block';
            return;
        }
        body.innerHTML = data.map((row, i) => {
            const rank = i + 1;
            const medal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : rank;
            const isMe = currentProfile && row.pseudo === currentProfile.pseudo;
            const bg = isMe ? 'background:rgba(139,92,246,0.15);' : '';
            return `<tr style="${bg} border-bottom:1px solid rgba(139,92,246,0.1);">
                <td style="padding:8px; color:#E0E7FF;">${medal}</td>
                <td style="padding:8px; color:${esc(row.avatar_color || '#E0E7FF')}; font-weight:${isMe ? 'bold' : 'normal'};">${esc(row.pseudo)}</td>
                <td style="padding:8px; text-align:center; color:#22C55E;">${row.wins}</td>
                <td style="padding:8px; text-align:center; color:#94A3B8;">${row.total_games}</td>
                <td style="padding:8px; text-align:center; color:#FBBF24;">${row.win_rate}%</td>
            </tr>`;
        }).join('');
    } catch (e) {
        body.innerHTML = '<tr><td colspan="5" style="color:#EF4444; text-align:center; padding:20px;">Erreur de chargement</td></tr>';
        console.warn('Erreur leaderboard:', e);
    }
}

document.getElementById('uiResetBtn').addEventListener('click', () => {
    panelConfig = {};
    _panelsInitialized = false;
    for (const id of PANEL_IDS) {
        const el = document.getElementById(id);
        if (!el) continue;
        const handle = el.querySelector('.panel-drag-handle');
        if (handle) el.removeChild(handle);
        el.classList.remove('panel-collapsed');
        el.style.position = '';
        el.style.left = '';
        el.style.top = '';
        el.style.right = '';
        el.style.bottom = '';
        el.style.transform = '';
        el.style.transformOrigin = '';
    }
    const slider = document.getElementById('uiZoomSlider');
    if (slider) { slider.value = 100; document.getElementById('uiZoomVal').textContent = '100%'; }
    initPanels();
    savePanelConfig();
});

document.querySelectorAll('#eventLog .log-filter').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('#eventLog .log-filter').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        refreshEventLog();
    });
});

initAuth();

</script>
</body>
</html>
